-- MySQL dump 10.13  Distrib 8.0.27, for Linux (x86_64)
--
-- Host: localhost    Database: db_myblog
-- ------------------------------------------------------
-- Server version	8.0.27-0ubuntu0.20.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `t_blog`
--

DROP TABLE IF EXISTS `t_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_blog` (
  `blog_id` int unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标题',
  `uid` int DEFAULT '1' COMMENT 'uid',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT '内容',
  `create_time` datetime NOT NULL COMMENT '注册时间',
  `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `publish` tinyint DEFAULT '0' COMMENT '是否发布',
  `brief` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `is_delete` tinyint(1) DEFAULT '0' COMMENT '是否删除',
  `ext_info` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  `is_top` tinyint DEFAULT NULL,
  PRIMARY KEY (`blog_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=92 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_blog`
--

LOCK TABLES `t_blog` WRITE;
/*!40000 ALTER TABLE `t_blog` DISABLE KEYS */;
INSERT INTO `t_blog` VALUES (17,'玩转mustache模板引擎',1,'\n## 什么是模板引擎？\n>模板引擎的基本机理就是替换（转换），将指定的标签转换为需要的业务数据；将指定的伪语句按照某种流程来变换输出\n\n\n\n### Mustache模板引擎\n> 一个胡子模板是一个包含任意数量的小胡子标签的字符串。标签由围绕它们的双髭指示。\n \n\n* ### `{{data}}`\n\n双花括号就是mustache语法的标识符，花括号中的data表示键名，作用是直接输出与键名匹配的键值。\n```javascript\nvar template = `\n<div>{{data}}</div>\n`\nvar data = \"hello world\"\nvar html = mustache.render(template,data)\n//输出\n`\n<div>hello world</div>\n`\n```\n\n* ### `{{.}}`\n\n表示枚举，可循环输出整个数组,需搭配{{#data}}和{{/data}}使用。\n\n\n* ### `{{#data}}和{{/data}}`\n\n该语法以#开始，并以/结束表示区块，用于对当前上下文的数据进行一次或多次的渲染，类似vue中的`v-for`指令。\n```javascript \n// li标签根据data属性hobbies对应的键值持续迭代\nvar template = `\n  <div>\n  {{#hobbies}}\n    <li>{{.}}</li>\n  {{/hobbies}}\n  </div>`;\nvar hobbies = [\"唱\",\"跳\",\"rap\"]\nvar html = mustache.render(template)\n//输出\n `\n  <div>\n    <li>唱</li>\n    <li>跳</li>\n    <li>rap</li>\n  </div>`\n```\n实现一下mustache模板引擎实现原理，其中包括了以上几种语法的*简单*实现。\n\n## Render函数\n \n```javascript\nwindow.my_templateEngine = {\n  //渲染函数\n  render(templateStr, data) {\n    //将字符串模板转换成tokens数组\n    var tokens = parserTemplateToTokens(templateStr);\n    //结合数据渲染模板\n    var resTemplate = renderTemplate(data, tokens)\n    return resTemplate\n  }\n}\n```\n一个模板引擎最核心的便是其**渲染(render)函数**，渲染函数从主要负责将字符串模板与数据结合，动态渲染出HTML。\n### 嵌套数组(Tokens)\n> **Tokens**为Mustache的底层核心机理：js的嵌套数组，它是模板字符串的js表示形式，并且Tokens 是**抽象语法树（AST）**、**虚拟节点**等的思路来源。  \n \n\n数组形式：  \n ```\n\n0: (2) [\'text\', \'\\n    <ul>\\n      \']\n1: (3) [\'#\', \'students\', Array(5)]\n2: (2) [\'text\', \'\\n    </ul>\\n    \']\n```\n`\'text\'`代表普通字符串，直接拼接,第2项为字符串  \n`\'name\'`代表存储基本类型的键，第2项为键名  \n`\'#\'和\'/\'`表示区块，第2项为键名，第3项为数组  \n\n\n要将字符串模板转换成tokens数组，肯定要对传入的字符串模板进行处理，我们知道，Mustache语法是靠识别双花括号`{{}}`内的参数来进行数据替换的，那么我们必须使用某种识别方法来提取`{{}}`的内容。扫描器（Scanner）就是用来实现它的\n### 扫描器(Scanner)\n```javascript\nexport default class Scanner {\n  constructor(templateStr) {\n    //贮存传入的字符串模板\n    this.templateStr = templateStr\n    //贮存tag之前的字符串\n    this.tail = templateStr\n    //扫描指针\n    this.pos = 0\n  }\n  //扫描方法,传入需要识别的tag\n  scanUntil(stopTag) {\n    //记录一下pos\n    var pos_backup = this.pos\n    //当尾巴的开头不是stopTag的时候 就说明没有扫描到stopTag\n    while(this.tail.indexOf(stopTag) !== 0 && !this.isEnd()) {\n      this.pos ++;\n      this.tail = this.templateStr.substr(this.pos)\n    }\n    return this.templateStr.substring(pos_backup,this.pos)\n  }\n  //跳过传入的tag\n  scan(tag) {\n    while(this.tail.indexOf(tag) === 0) {\n    //过掉tag\n      this.pos += 2;\n      this.tail = this.templateStr.substr(this.pos)\n    }\n  }\n  //判断是否到末尾\n  isEnd() {\n    return this.pos > this.templateStr.length\n  }\n}\n```\n`scanUntil()`方法对传入的字符串进行检索，如果当前字符串中索引为0的字符不是\'{\',就将pos指针`加1`，直到遇到\'{\'，该方法会返回处于\'{\'之前的字符串。  \n`scan()`方法负责跳过tag，因为\"{{\"占用了两个字符的位置并且已经完成了它的使命，所以截去并将pos位置`加2`。下面是该方法示例\n```javascript\n//示例\nimport Scanner from \"./scanner\";\nvar scanner = new Scanner(`<div><ul><li>{{hey}}</li></ul></div>`)\nconsole.log(scanner.scanUntil(\"{{\")) //<div><ul><li>\nscanner.scan(\"{{\") //跳过\nconsole.log(scanner.scanUntil(\"}}\")) //hey\nscanner.scan(\"}}\") //跳过\nconsole.log(scanner.scanUntil(\"}}\")) //</li></ul></div>\n...\n```\n\n\n### 使用扫描器获取Tokens\n```javascript\nimport Scanner from \"./scanner\";\nimport nestTokens from \"./nestTokens\"\nexport default function parserTemplateToTokens(templateStr) {\n  var tokens = [];\n  var words = \"\";\n  var scanner = new Scanner(templateStr)\n  while (scanner.eos()) {\n    //收集mustache开始标记之前的值\n    words = scanner.scanUntil(\"{{\");\n    //过掉标记\n    scanner.scan(\"{{\")\n    if (words !== \'\') {\n      tokens.push([\"text\", words]);\n    }\n    //收集mustache结束标记之前的值\n    words = scanner.scanUntil(\"}}\");\n    //过掉标记\n    scanner.scan(\"}}\")\n    if (words !== \'\') {\n      if(words[0] === \"#\") {\n      tokens.push([\"#\", words.substring(1)]);\n    } else if(words[0] === \"/\"){\n      tokens.push([\"/\", words.substring(1)] );\n    } else {\n      tokens.push([\"name\", words]);\n    }\n    }\n  }\n  return tokens\n}\n```\n根据示例方法，可以实现将截取的字符串形成像下面的形式的数组：  \n```\n0: (2) [\'text\', \'\\n    <ul>\\n      \']\n1: (3) [\'#\', \'students\', Array(5)]\n2: (2) [\'text\', \'\\n        <li>\\n          学生\']\n3: (2) [\'name\', \'name\']\n4: (2) [\'text\', \'的爱好是\\n          <ol>\\n            \']\n5: (3) [\'#\', \'hobbies\', Array(3)]\n6: (2) [\'text\', \'\\n            <li>\']\n7: (2) [\'name\', \'.\']\n8: (2) [\'text\', \'</li>\\n              \']\n9: (2) [\'/\', \'hobbies\']\n10: (2) [\'text\', \'\\n              </ol>\\n        </li>\\n        \']\n11: (2) [\'/\', \'students\']\n12: (2) [\'text\', \'\\n    </ul>\\n    \']\n```\n可以看到 数组中存在有**hobbies**和**students**两个区块，我们所期望的是他们是`嵌套`的关系（像以下的嵌套形式），所以我们的实现方式仍然存在一些问题。\n```\n0: (2) [\'text\', \'\\n    <ul>\\n      \']\n1: Array(3)\n  0: \"#\"\n  1: \"students\"\n  2: Array(5)\n    0: (2) [\'text\', \'\\n        <li>\\n          学生\']\n    1: (2) [\'name\', \'name\']\n    2: (2) [\'text\', \'的爱好是\\n          <ol>\\n            \']\n    3: Array(3)\n      0: \"#\"\n      1: \"hobbies\"\n      2: Array(3)\n        0: (2) [\'text\', \'\\n            <li>\']\n        1: (2) [\'name\', \'.\']\n        2: (2) [\'text\', \'</li>\\n              \']\n4: (2) [\'text\', \'\\n              </ol>\\n        </li>\\n        \']\n2: (2) [\'text\', \'\\n    </ul>\\n    \']\n```\n\n### 数组折叠\n```javascript\nexport default function nestTokens(tokens) {\n  //遍历数组遇到 # \n  let nestTokens = [];\n  let tagStack = [];\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i];\n    switch (token[0]) {\n      case \"#\":\n        //这个存的是层级(几个#)，待会好回去\n        tagStack.push(token);\n        break;\n      case \"/\":\n        let tagStackPop = tagStack.pop();\n        //碰到第一个/触发出栈操作时，可以判断当前栈是否还有值，如果有则将出栈值push到栈顶数组中\n        if(tagStack.length) {\n          tagStack[tagStack.length - 1][2].push(tagStackPop)\n        }else {\n          nestTokens.push(tagStackPop)\n        }\n        break;\n      default:\n        if (tagStack.length === 0) {\n          nestTokens.push(token)\n        } else {\n          tagStack[tagStack.length - 1][2].push(token)\n        }\n        break;\n    }\n  }\n  return nestTokens\n}\n```\n`nestTokens()`方法对传入的tokens数组进行遍历，普通项正常进入nestTokens数组，遍历过程中若是遇到嵌套开始标志`#`,就将其压入tagStack，并且后续对nestTokens的push操作都是在tagStack栈顶数组中，如果遇到嵌套结束标志`/`，可以判断当前tagStack是否还有值，如果有则将出栈值push到栈顶数组中,如果没有值了则将最后一个出栈的数组push到nestTokens中并将nestTokens返回。\n### 嵌套复杂类型的读取\n如果我们需要拿到对象类型的值，需要用上`.`点符号，但目前的渲染函数只能识别简单的数据类型，所以我们需要再封装一个方法，来对数据中的复杂类型进行获取。\n```javascript\n// 根据传入的带点字符串参数 查找对象的值\nexport default function lookup(dataObj, keyName) {\n  let str = \'\'\n  try {\n    let i = keyName.indexOf(\'.\')\n    if (i !== -1 && keyName !== \'.\') {\n      str = keyName.substring(0, i);\n      return lookup(dataObj[str], keyName.substr(i + 1))\n    } else {\n      return dataObj[keyName]\n    }\n  } catch(err) {\n    console.log(err);\n  }\n}\n```\n### 最后一步模板渲染\n最终的Tokens数组我们已经拿到了，接下来便是最后一步但是同样重要，`模板渲染`,将tokens与数据进行结合，并形成最终的domStr。\n```javascript\nimport lookup from \"./lookup\"\nimport parserArr from \"./parserArr\"\n// 实现功能 将数据与tokens数组合成html\nexport default function renderTemplate(data, tokens) {\n  let resStr = \'\';\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i]\n    if (token[0] === \'text\') {\n      resStr += token[1]\n    } else if (token[0] === \'name\') {\n      resStr += lookup(data, token[1])\n    } else if (token[0] === \'#\') {\n      resStr += parserArr(token, data)\n    }\n  }\n  return resStr\n}\n\n```\n测试\n```javascript\n var template = `\n    <ul>\n      {{#students}}\n      <li>\n        学生{{name}}的爱好是\n        <ol>\n          {{#hobbies}}\n          <li>{{.}}</li>\n          {{/hobbies}}\n        </ol>\n      </li>\n      {{/students}}\n    </ul>\n    `\n    var data = {\n      students: [{\n          \'name\': \'小明\',\n          \'hobbies\': [\'游泳\', \'健身\']\n        },\n        {\n          \'name\': \'小红\',\n          \'hobbies\': [\'足球\', \'篮球\', \'羽毛球\']\n        },\n        {\n          \'name\': \'小坤\',\n          \'hobbies\': [\'唱\', \'跳\',\'rap\', \'篮球\']\n        },\n      ]\n    }\n    var domStr = window.my_templateEngine.render(template, data);\n    var container = document.getElementById(\"container\");\n    container.innerHTML = domStr\n```\n浏览器输出结果  \n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc4719225d7e4b4d866f16a81c041d3e~tplv-k3u1fbpfcp-watermark.image?)\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f190c95875fa4125a79a839230a1c04e~tplv-k3u1fbpfcp-watermark.image?)\n\n','2021-11-05 10:09:02','2022-04-25 08:39:50',1,'>模板引擎的基本机理就是替换（转换），将指定的标签转换为需要的业务数据；将指定的伪语句按照某种流程来变换输出',1,NULL,0),(18,'早期模板渲染方式和mustache模板引擎的简单实现',1,'## 早期模板渲染的几种方式\n在模板引擎诞生之前，为了使用js将**动态数据**渲染到页面上，出现了一系列模板渲染的方法，最直接的莫过于是手动创建所有节点：\n```html\n<div id=\"root\"></div>\n  <script>\n    var root = document.getElementById(\'root\')\n    var container = document.createElement(\'h1\')\n    var text = document.createTextNode(\'Hello World!!\')\n    container.appendChild(text)\n    root.appendChild(container)\n  </script>\n```\n这种方式需要手动创建所有节点，操作繁琐，因而无法在实际开发中运用。  \n还有一种方式是使用`innerHTML`来上树。\n```html\n  <div id=\"root\"></div>\n  <script>\n    var root = document.getElementById(\'root\')\n    root.innerHTML = \'<h1>Hello World</h1>\'\n  </script>\n```\n这种方式无疑是方便了许多，但是由于字符串无法换行，一旦遇到那种标签嵌套层级太多的情况，会给自己和他人的后期维护造成极大的困扰。 \n\n再后来有人想到个**很牛逼**的想法\n```html\n    <div id=\"root\"></div>\n    <script>\n      var root = document.getElementById(\"root\");\n\n      var obj = {\n        name: \"洗脚哥\",\n        gender: \"男\",\n        hobby: \"洗脚\",\n      };\n\n      root.innerHTML = [\n        \"<ul>\",\n        \"   <li>姓名：\" + obj.name + \"</li>\",\n        \"   <li>性别：\" + obj.gender + \"</li>\",\n        \"   <li>爱好：\" + obj.hobby + \"</li>\",\n        \"</ul>\"\n      ].join(\'\');\n    </script>\n```\n这个方法将不可换行字符串转成阵列结构，可读性和可维护性都大大提升。  \n\n当然，ES6的模板字符串的出现，使这种阵列结构也失去了用武之地。  \n```html\n <div id=\"root\"></div>\n    <script>\n      var root = document.getElementById(\"root\");\n\n      var obj = {\n        name: \"xjg\",\n        gender: \"男\",\n        hobby: \"洗脚\",\n      };\n\n      root.innerHTML = `\n        <ul>\n           <li>姓名：${obj.name}  </li>\n           <li>性别：${obj.gender}  </li>\n           <li>爱好: ${obj.hobby}  </li>\n        </ul>\n      `\n    </script>\n```\n但是，在实际开发中DOM操作并不是简单的，当DOM结构更加复杂，这种方式也显得力不从心。  \n\n于是**mustache库**横空出世！\n## 什么是模板引擎\n>模板引擎的基本机理就是替换（转换），将指定的标签转换为需要的业务数据；将指定的伪语句按照某种流程来变换输出\n\n\n\n### Mustache\n> 一个胡子模板是一个包含任意数量的小胡子标签的字符串。标签由围绕它们的双髭指示。\n \n\n* ### `{{data}}`\n\n双花括号就是mustache语法的标识符，花括号中的data表示键名，作用是直接输出与键名匹配的键值。\n```javascript\nvar template = `\n<div>{{data}}</div>\n`\nvar data = \"hello world\"\nvar html = mustache.render(template,data)\n//输出\n`\n<div>hello world</div>\n`\n```\n\n* ### `{{.}}`\n\n表示枚举，可循环输出整个数组,需搭配{{#data}}和{{/data}}使用。\n\n\n* ### `{{#data}}和{{/data}}`\n\n该语法以#开始，并以/结束表示区块，用于对当前上下文的数据进行一次或多次的渲染，类似vue中的`v-for`指令。\n```javascript \n// li标签根据data属性hobbies对应的键值持续迭代\nvar template = `\n  <div>\n  {{#hobbies}}\n    <li>{{.}}</li>\n  {{/hobbies}}\n  </div>`;\nvar hobbies = [\"唱\",\"跳\",\"rap\"]\nvar html = mustache.render(template)\n//输出\n `\n  <div>\n    <li>唱</li>\n    <li>跳</li>\n    <li>rap</li>\n  </div>`\n```\n实现一下mustache模板引擎实现原理，其中包括了以上几种语法的*简单*实现。\n\n## Render函数\n \n```javascript\nwindow.my_templateEngine = {\n  //渲染函数\n  render(templateStr, data) {\n    //将字符串模板转换成tokens数组\n    var tokens = parserTemplateToTokens(templateStr);\n    //结合数据渲染模板\n    var resTemplate = renderTemplate(data, tokens)\n    return resTemplate\n  }\n}\n```\n一个模板引擎最核心的便是其**渲染(render)函数**，渲染函数从主要负责将字符串模板与数据结合，动态渲染出HTML。\n### 嵌套数组(Tokens)\n> **Tokens**为Mustache的底层核心机理：js的嵌套数组，它是模板字符串的js表示形式，并且Tokens 是**抽象语法树（AST）**、**虚拟节点**等的思路来源。  \n \n\n数组形式：  \n ```\n\n0: (2) [\'text\', \'\\n    <ul>\\n      \']\n1: (3) [\'#\', \'students\', Array(5)]\n2: (2) [\'text\', \'\\n    </ul>\\n    \']\n```\n`\'text\'`代表普通字符串，直接拼接,第2项为字符串  \n`\'name\'`代表存储基本类型的键，第2项为键名  \n`\'#\'和\'/\'`表示区块，第2项为键名，第3项为数组  \n\n\n要将字符串模板转换成tokens数组，肯定要对传入的字符串模板进行处理，我们知道，Mustache语法是靠识别双花括号`{{}}`内的参数来进行数据替换的，那么我们必须使用某种识别方法来提取`{{}}`的内容。扫描器（Scanner）就是用来实现它的\n### 扫描器(Scanner)\n```javascript\nexport default class Scanner {\n  constructor(templateStr) {\n    //贮存传入的字符串模板\n    this.templateStr = templateStr\n    //贮存tag之前的字符串\n    this.tail = templateStr\n    //扫描指针\n    this.pos = 0\n  }\n  //扫描方法,传入需要识别的tag\n  scanUntil(stopTag) {\n    //记录一下pos\n    var pos_backup = this.pos\n    //当尾巴的开头不是stopTag的时候 就说明没有扫描到stopTag\n    while(this.tail.indexOf(stopTag) !== 0 && !this.isEnd()) {\n      this.pos ++;\n      this.tail = this.templateStr.substr(this.pos)\n    }\n    return this.templateStr.substring(pos_backup,this.pos)\n  }\n  //跳过传入的tag\n  scan(tag) {\n    while(this.tail.indexOf(tag) === 0) {\n    //过掉tag\n      this.pos += 2;\n      this.tail = this.templateStr.substr(this.pos)\n    }\n  }\n  //判断是否到末尾\n  isEnd() {\n    return this.pos > this.templateStr.length\n  }\n}\n```\n`scanUntil()`方法对传入的字符串进行检索，如果当前字符串中索引为0的字符不是\'{\',就将pos指针`加1`，直到遇到\'{\'，该方法会返回处于\'{\'之前的字符串。  \n`scan()`方法负责跳过tag，因为\"{{\"占用了两个字符的位置并且已经完成了它的使命，所以截去并将pos位置`加2`。下面是该方法示例\n```javascript\n//示例\nimport Scanner from \"./scanner\";\nvar scanner = new Scanner(`<div><ul><li>{{hey}}</li></ul></div>`)\nconsole.log(scanner.scanUntil(\"{{\")) //<div><ul><li>\nscanner.scan(\"{{\") //跳过\nconsole.log(scanner.scanUntil(\"}}\")) //hey\nscanner.scan(\"}}\") //跳过\nconsole.log(scanner.scanUntil(\"}}\")) //</li></ul></div>\n...\n```\n\n\n### 使用扫描器获取Tokens\n```javascript\nimport Scanner from \"./scanner\";\nimport nestTokens from \"./nestTokens\"\nexport default function parserTemplateToTokens(templateStr) {\n  var tokens = [];\n  var words = \"\";\n  var scanner = new Scanner(templateStr)\n  while (scanner.eos()) {\n    //收集mustache开始标记之前的值\n    words = scanner.scanUntil(\"{{\");\n    //过掉标记\n    scanner.scan(\"{{\")\n    if (words !== \'\') {\n      tokens.push([\"text\", words]);\n    }\n    //收集mustache结束标记之前的值\n    words = scanner.scanUntil(\"}}\");\n    //过掉标记\n    scanner.scan(\"}}\")\n    if (words !== \'\') {\n      if(words[0] === \"#\") {\n      tokens.push([\"#\", words.substring(1)]);\n    } else if(words[0] === \"/\"){\n      tokens.push([\"/\", words.substring(1)] );\n    } else {\n      tokens.push([\"name\", words]);\n    }\n    }\n  }\n  return tokens\n}\n```\n根据示例方法，可以实现将截取的字符串形成像下面的形式的数组：  \n```\n0: (2) [\'text\', \'\\n    <ul>\\n      \']\n1: (3) [\'#\', \'students\', Array(5)]\n2: (2) [\'text\', \'\\n        <li>\\n          学生\']\n3: (2) [\'name\', \'name\']\n4: (2) [\'text\', \'的爱好是\\n          <ol>\\n            \']\n5: (3) [\'#\', \'hobbies\', Array(3)]\n6: (2) [\'text\', \'\\n            <li>\']\n7: (2) [\'name\', \'.\']\n8: (2) [\'text\', \'</li>\\n              \']\n9: (2) [\'/\', \'hobbies\']\n10: (2) [\'text\', \'\\n              </ol>\\n        </li>\\n        \']\n11: (2) [\'/\', \'students\']\n12: (2) [\'text\', \'\\n    </ul>\\n    \']\n```\n可以看到 数组中存在有**hobbies**和**students**两个区块，我们所期望的是他们是`嵌套`的关系（像以下的嵌套形式），所以我们的实现方式仍然存在一些问题。\n```\n0: (2) [\'text\', \'\\n    <ul>\\n      \']\n1: Array(3)\n  0: \"#\"\n  1: \"students\"\n  2: Array(5)\n    0: (2) [\'text\', \'\\n        <li>\\n          学生\']\n    1: (2) [\'name\', \'name\']\n    2: (2) [\'text\', \'的爱好是\\n          <ol>\\n            \']\n    3: Array(3)\n      0: \"#\"\n      1: \"hobbies\"\n      2: Array(3)\n        0: (2) [\'text\', \'\\n            <li>\']\n        1: (2) [\'name\', \'.\']\n        2: (2) [\'text\', \'</li>\\n              \']\n4: (2) [\'text\', \'\\n              </ol>\\n        </li>\\n        \']\n2: (2) [\'text\', \'\\n    </ul>\\n    \']\n```\n\n### 数组折叠\n```javascript\nexport default function nestTokens(tokens) {\n  //遍历数组遇到 # \n  let nestTokens = [];\n  let tagStack = [];\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i];\n    switch (token[0]) {\n      case \"#\":\n        //这个存的是层级(几个#)，待会好回去\n        tagStack.push(token);\n        break;\n      case \"/\":\n        let tagStackPop = tagStack.pop();\n        //碰到第一个/触发出栈操作时，可以判断当前栈是否还有值，如果有则将出栈值push到栈顶数组中\n        if(tagStack.length) {\n          tagStack[tagStack.length - 1][2].push(tagStackPop)\n        }else {\n          nestTokens.push(tagStackPop)\n        }\n        break;\n      default:\n        if (tagStack.length === 0) {\n          nestTokens.push(token)\n        } else {\n          tagStack[tagStack.length - 1][2].push(token)\n        }\n        break;\n    }\n  }\n  return nestTokens\n}\n```\n`nestTokens()`方法对传入的tokens数组进行遍历，普通项正常进入nestTokens数组，遍历过程中若是遇到嵌套开始标志`#`,就将其压入tagStack，并且后续对nestTokens的push操作都是在tagStack栈顶数组中，如果遇到嵌套结束标志`/`，可以判断当前tagStack是否还有值，如果有则将出栈值push到栈顶数组中,如果没有值了则将最后一个出栈的数组push到nestTokens中并将nestTokens返回。\n### 嵌套复杂类型的读取\n如果我们需要拿到对象类型的值，需要用上`.`点符号，但目前的渲染函数只能识别简单的数据类型，所以我们需要再封装一个方法，来对数据中的复杂类型进行获取。\n```javascript\n// 根据传入的带点字符串参数 查找对象的值\nexport default function lookup(dataObj, keyName) {\n  let str = \'\'\n  try {\n    let i = keyName.indexOf(\'.\')\n    if (i !== -1 && keyName !== \'.\') {\n      str = keyName.substring(0, i);\n      return lookup(dataObj[str], keyName.substr(i + 1))\n    } else {\n      return dataObj[keyName]\n    }\n  } catch(err) {\n    console.log(err);\n  }\n}\n```\n### 最后一步模板渲染\n最终的Tokens数组我们已经拿到了，接下来便是最后一步但是同样重要，`模板渲染`,将tokens与数据进行结合，并形成最终的domStr。\n```javascript\nimport lookup from \"./lookup\"\nimport parserArr from \"./parserArr\"\n// 实现功能 将数据与tokens数组合成html\nexport default function renderTemplate(data, tokens) {\n  let resStr = \'\';\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i]\n    if (token[0] === \'text\') {\n      resStr += token[1]\n    } else if (token[0] === \'name\') {\n      resStr += lookup(data, token[1])\n    } else if (token[0] === \'#\') {\n      resStr += parserArr(token, data)\n    }\n  }\n  return resStr\n}\n\n```\n测试\n```javascript\n var template = `\n    <ul>\n      {{#students}}\n      <li>\n        学生{{name}}的爱好是\n        <ol>\n          {{#hobbies}}\n          <li>{{.}}</li>\n          {{/hobbies}}\n        </ol>\n      </li>\n      {{/students}}\n    </ul>\n    `\n    var data = {\n      students: [{\n          \'name\': \'小明\',\n          \'hobbies\': [\'游泳\', \'健身\']\n        },\n        {\n          \'name\': \'小红\',\n          \'hobbies\': [\'足球\', \'篮球\', \'羽毛球\']\n        },\n        {\n          \'name\': \'小坤\',\n          \'hobbies\': [\'唱\', \'跳\',\'rap\', \'篮球\']\n        },\n      ]\n    }\n    var domStr = window.my_templateEngine.render(template, data);\n    var container = document.getElementById(\"container\");\n    container.innerHTML = domStr\n```\n浏览器输出结果  \n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc4719225d7e4b4d866f16a81c041d3e~tplv-k3u1fbpfcp-watermark.image?)\n\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f190c95875fa4125a79a839230a1c04e~tplv-k3u1fbpfcp-watermark.image?)\n\n','2021-11-05 16:08:05','2022-08-02 03:15:56',1,'>模板引擎的基本机理就是替换（转换），将指定的标签转换为需要的业务数据；将指定的伪语句按照某种流程来变换输出',0,NULL,0),(19,'router.addroutes动态添加路由注意点',1,'## 前言\n### 在开发后台管理系统不可避免地会涉及到根据用户权限来动态渲染侧边栏的问题，在vue2.2.0之后可以使用router.addroutes()来方便动态添加路由了。\n\n## `router.addroutes()`使用\n```javascript\n  addRoutes (routes: RouteConfig[]): void;\n  //动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。\n```\n简易实现侧边栏动态渲染：  \n\n在`router.js`中配置静态路由表:  \n```javascript\nexport const constantRouterMap = [{\n    path: \'/login\',\n    component: () => import(\'@/views/login/index\'),\n    hidden: true\n  },]\n```\n配置需要动态渲染的路由表:  \n```javascript\nexport const asyncRouterMap = [{\n    path: \'/admin\',\n    component: () => import(\'@/views/admin/index\'),\n    hidden: true,\n    meta: {\n          title: \'xxx\',\n          icon: \'xxx\',\n          //角色权限字段\n          role: [\'admin\']\n        }\n    },\n    {\n        ...\n        \n    }]\n``` \n在用户登录跳转时，在导航守卫`router.beforeEach()`内执行操作获取用户信息，根据用户信息拿到对应role字段，与`asyncRouterMap[i].meta.role`进行比对，过滤出角色所属的路由表。\n```javascript\n//permission.js\nrouter.beforeEach(async (to, from, next) => {\n  // 验证用户是否已经登陆过\n  const hasToken = getToken()\n  if (hasToken) {\n    if (to.path === \'/login\') {\n    //是否跳转登录页\n      next({\n        path: \'/\'\n      })\n    } else {\n      //这一步为了路由数据持久化，防止刷新后vuex数据丢失造成的侧边栏显示异常\n      const hasGetRouters = store.getters.routers\n      //是否已经获取用户信息\n      const hasGetUserInfo = store.getters.name\n      if (hasGetUserInfo && hasGetRouters.length) {\n        next()\n      } else {\n        try {\n        //获取角色信息\n          const {\n            role\n          } = await store.dispatch(\'user/getInfo\')\n          //传入角色信息，执行过滤方法\n          await store.dispatch(\'permission/getRoutes\', {\n            role\n          })\n          //动态添加路由\n          router.addRoutes(store.getters.addRouters);\n          next({\n            ...to,\n            replace: true\n          })\n        } catch (error) {\n        }\n      }\n    }\n  }\n})\n```\n\n## 遇到的一些问题\n### 明明已经成功拿到动态路由表了，使用`router.addRoutes()`后并未在`this.$router.options`中更新？ \n其实这是vue-router设计如此，在issue中作者有提到`That is normal, options is the object passed to the vuerouter constructor. It\'s not modified afterwards`。其实相应的路由已经添加了，只是将参数传给了vuerouter构造函数，所以没法在vueRouter实例中看到。  \n### 侧边栏如果通过`v-for=\"route in $router.options\"`渲染，怎么才能实现有效更新？\n因为之前提到过，如果使用`router.addRoutes`来进行添加路由无法更新`this.$router.options`，所以主要的实现方法是通过store来存储路由表。  \n\n```javascript\n//store\nconst state = {\n  routers: [],\n  addRouters: []\n}\n\nconst mutations = {\n  SET_ROUTERS: (state, routers) => {\n    state.addRouters = routers;\n    //与静态路由表拼接\n    state.routers = constantRouterMap.concat(routers);\n  }\n}\nconst actions = {\n  getRoutes({\n    commit\n  }, data) {\n    return new Promise(resolve => {\n      const {\n        role\n      } = data;\n      \n          ...\n          //过滤出role对应路由表accessedRouters\n      commit(\'SET_ROUTERS\', accessedRouters);\n      resolve();\n    })\n  }\n}\n```\n使用：\n```javascript\n//sideBar.vue\n\n    ...mapState(\"permission\", {\n      routers: \"routers\",\n    }),\n```\n### 刷新之后侧边栏显示空白？\n因为vuex无法持久化保存数据，在页面刷新之后数据被清空，所以需要在`router.beforeEach()`内再做一层判断页面是否刷新。','2021-11-05 16:09:59','2022-04-25 08:40:30',1,'> 在开发后台管理系统不可避免地会涉及到根据用户权限来动态渲染侧边栏的问题，在vue2.2.0之后可以使用router.addroutes()来方便动态添加路由了。',1,NULL,0),(20,'node.js实现爬取王者农药官网皮肤（高清无码大图）',1,'直接上代码\n`wCrawl.js`\n```javascript\nconst cheerio = require(\"cheerio\")\nconst fs = require(\"fs\")\n//获取html文档内容  \nconst iconv = require(\"iconv-lite\")\nconst axios = require(\"axios\")\nconst {\n  rmAndMkdir\n} = require(\"./rwFs\")\nlet httpUrl = \"https://pvp.qq.com/web201605/herolist.shtml\"\n/**创建输出目录\n * 输出路径\n * @param {String} path \n */\nfunction crawlPictures(path) {\n  axios.get(httpUrl, {\n    responseType: \'arraybuffer\'\n  }).then(res => {\n    const str = transCoding(res.data, \'gbk\')\n    let $ = cheerio.load(str, {\n      decodeEntities: false\n    })\n    rmAndMkdir(\"./img\")\n    console.log(\"开始爬取网页内容...\");\n    $(\".herolist li a\").each(async (index, element) => {\n      let heroDetailUrl = \"https://pvp.qq.com/web201605/\" +\n        $(element).attr(\"href\")\n      let $_ = cheerio.load(element, {\n        decodeEntities: false\n      })\n      let heroName = $_(\"img\").attr(\'alt\')\n      await sleep();\n      parseImg({\n        heroDetailUrl,\n        heroName\n      })\n    })\n  })\n}\nasync function parseImg({\n  heroDetailUrl,\n  heroName\n}) {\n  let {\n    data\n  } = await axios.get(heroDetailUrl, {\n    responseType: \'arraybuffer\'\n  });\n  let $ = cheerio.load(transCoding(data, \'gbk\'), {\n    decodeEntities: false\n  })\n  let downloadUrl = $(\".wrapper .zk-con1\").attr(\"style\")\n\n  let res = /background\\:url\\(\'(.*?)\'\\) center 0/igs.exec(downloadUrl)[1]\n  fs.mkdir(`./img/${heroName}`, function (err) {\n    if (!err) {\n      $(\".pic-pf ul\").each((index, element) => {\n        let imgName = $(element).attr(\"data-imgname\")\n        let arr = imgName.split(\"&\")\n        arr.pop();\n        let lastArr = arr.map(item => {\n          let index = item.indexOf(\"|\")\n          if (index !== -1) {\n            return item.slice(index + 1)\n          }\n          return item\n        })\n        for (let i = 0; i < lastArr.length; i++) {\n          imgDownload({\n            imgUrl: doHandleUrl(\"https:\" + res, i + 1),\n            skinName: lastArr[i],\n            heroName\n          })\n        }\n\n        function doHandleUrl(url, number) {\n          let lastIndex = url.lastIndexOf(\'.\')\n          if (lastIndex !== -1) {\n            return url.substr(0, lastIndex - 1) + number + url.substr(lastIndex)\n          }\n        }\n      })\n    }\n  })\n}\n\nasync function imgDownload({\n  imgUrl,\n  skinName,\n  heroName\n}) {\n  console.log(skinName);\n  let {\n    data: imgRes\n  } = await axios.get(imgUrl, {\n    responseType: \'stream\'\n  })\n  let ws = fs.createWriteStream(`./img/${heroName}/${skinName}.jpg`, {\n    flags: \"w\",\n\n  })\n  imgRes.pipe(ws)\n}\n\nfunction transCoding(content, format) {\n  return iconv.decode(Buffer.from(content), format)\n}\n\nfunction sleep() {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, 2000);\n  })\n}\nmodule.exports = crawlPictures\n```\n封装的一些promise  \n`rwFs.js`\n```javascript\nconst fs = require(\"fs\")\n/**\n * 写入文件\n * @param {String} path \n * @param {*}} content \n * @returns \n */\nfunction fsWrite(path, content) {\n  return new Promise((resolve, reject) => {\n    fs.writeFile(path, content, {\n      flag: \"a\",\n      encoding: \"utf-8\"\n    }, function (err) {\n      if (!err) {\n        console.log(\"写入成功\");\n        resolve()\n      } else {\n        console.log(err);\n        reject()\n      }\n    })\n  })\n}\n/**\n * 读取文件内容\n * @param {Sting} url \n * @returns \n */\nfunction fsRead(url) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(url, {\n      flag: \'r\',\n      encoding: \"utf-8\"\n    }, function (err, data) {\n      if (err) {\n        reject(err)\n      } else {\n        resolve(data)\n      }\n    });\n  })\n}\n/**\n * 判断文件是否存在\n * @param {String} path \n * @returns\n */\nfunction isFileExisted(path) {\n  return new Promise((resolve, reject) => {\n    fs.access(path, (err) => {\n      if (err) {\n        console.log(\"文件不存在\");\n        resolve(false)\n      } else {\n        resolve(true)\n      }\n    })\n  })\n}\n/**\n * 删除指定路径下的目录文件夹\n * @param {String} path \n * @returns \n */\nfunction rmDir(path) {\n  return new Promise((resolve, reject) => {\n    fs.rmdir(path, {\n      recursive: true\n    }, (err) => {\n      if (err) {\n        reject(err)\n      } else {\n        console.log(\"正在删除\");\n        resolve()\n      }\n    })\n  })\n}\n/**\n * 在指定路径下创建目录\n * @param {String} path \n * @returns \n */\nfunction mkDir(path) {\n  return new Promise((resolve, reject) => {\n    fs.mkdir(path, (err) => {\n      if (err) {\n        reject(err)\n      } else {\n        console.log(\"正在创建目录\");\n        resolve()\n      }\n    })\n  })\n}\n/**\n * 重新创建对应路径下文件夹\n * @param {String} path \n */\nasync function rmAndMkdir(path) {\n  try {\n    var isExist = await isFileExisted(path)\n    if (isExist) {\n      await rmDir(path);\n      await mkDir(path);\n    } else {\n      await mkDir(path);\n    }\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nmodule.exports = {\n  fsWrite,\n  fsRead,\n  isFileExisted,\n  rmDir,\n  mkDir,\n  rmAndMkdir\n}\n```\nindex.js\n```javascript\nconst crawlPictures = require(\"./crawlPictures\")\ncrawlPictures(\"./img\")\n```\n`node ./index.js`  执行  \n还不错的小demo\n\n![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8286a6e2a91246dea629242d2ee612dc~tplv-k3u1fbpfcp-watermark.image)\n爬取完成','2021-11-05 16:12:53','2022-04-25 09:52:16',1,'```javascript const crawlPictures = require(\"./crawlPictures\") crawlPictures(\"./img\") ``` `node ./index.js`  执行  ',0,NULL,0),(21,'router.addroutes()添加动态路由表实现侧边栏有效更新',1,'## 前言\n### 开发后台管理系统会涉及到根据用户权限来动态渲染侧边栏的问题，在vue2.2.0之后可以使用router.addroutes()来方便动态添加路由了。\n\n\n```javascript\n  addRoutes (routes: RouteConfig[]): void;\n  //动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。\n```\n先介绍下实现侧边栏动态渲染的大致方式：  \n\n在`router.js`中配置静态路由表:  \n```javascript\nexport const constantRouterMap = [{\n    path: \'/login\',\n    component: () => import(\'@/views/login/index\'),\n    hidden: true\n  },]\n```\n配置需要动态渲染的路由表:  \n```javascript\nexport const asyncRouterMap = [{\n    path: \'/admin\',\n    component: () => import(\'@/views/admin/index\'),\n    hidden: true,\n    meta: {\n          title: \'xxx\',\n          icon: \'xxx\',\n          //角色权限字段\n          role: [\'admin\']\n        }\n    },\n    {\n        ...\n        //其他路由\n    }]\n``` \n用户登录跳转时，导航守卫`router.beforeEach()`发起ajax获取用户信息，拿到用户信息对应的role字段，再与`asyncRouterMap[i].meta.role`进行比对，将比对结果作为条件滤出角色所属的路由表。\n```javascript\n//permission.js\nrouter.beforeEach(async (to, from, next) => {\n  // 验证用户是否已经登陆过\n  const hasToken = getToken()\n  if (hasToken) {\n    if (to.path === \'/login\') {\n    //是否跳转登录页\n      next({\n        path: \'/\'\n      })\n    } else {\n      //这一步为了路由数据持久化，防止刷新后vuex数据丢失造成的侧边栏显示异常\n      const hasGetRouters = store.getters.routers\n      //是否已经获取用户信息\n      const hasGetUserInfo = store.getters.name\n      if (hasGetUserInfo && hasGetRouters.length) {\n        next()\n      } else {\n        try {\n        //获取角色信息\n          const {\n            role\n          } = await store.dispatch(\'user/getInfo\')\n          //传入角色信息，执行过滤方法\n          await store.dispatch(\'permission/getRoutes\', {\n            role\n          })\n          //动态添加路由\n          router.addRoutes(store.getters.addRouters);\n          next({\n            ...to,\n            replace: true\n          })\n        } catch (error) {\n        }\n      }\n    }\n  }\n})\n```\n\n### 遇到的一些坑\n#### 已经成功拿到动态路由表，为什么使用`router.addRoutes()`添加的路由没有在`router.options`中更新？\n\n作者有提到`That is normal, options is the object passed to the vuerouter constructor. It\'s not modified afterwards`。[链接在此](https://github.com/vuejs/vue-router/issues/1859)，其实相应的路由已经添加了，只是将参数传给了vueRouter构造函数，所以没法在vueRouter实例中看到。 \n\n#### 那么既然侧边栏不能通过`v-for=\"route in $router.options\"`渲染，如何才能实现有效更新？\n如果使用`router.addRoutes`来进行添加路由无法更新`this.$router.options`，所以主要的实现方法是通过store来存储路由表。  \n\n```javascript\n//store\nconst state = {\n  routers: [],\n  addRouters: []\n}\n\nconst mutations = {\n  SET_ROUTERS: (state, routers) => {\n    state.addRouters = routers;\n    //与静态路由表拼接\n    state.routers = constantRouterMap.concat(routers);\n  }\n}\nconst actions = {\n  getRoutes({\n    commit\n  }, data) {\n    return new Promise(resolve => {\n      const {\n        role\n      } = data;\n      \n          ...\n          //过滤出role对应路由表accessedRouters\n      commit(\'SET_ROUTERS\', accessedRouters);\n      resolve();\n    })\n  }\n}\n```\n```javascript\n//sideBar.vue\n\n    ...mapState(\"permission\", {\n      routers: \"routers\",\n    }),\n```\n#### 刷新之后侧边栏显示空白？\n\n因为vuex无法持久化保存数据，在页面刷新之后数据被清空，所以需要在`router.beforeEach()`内再做一层判断页面是否刷新。','2021-11-05 16:15:28','2022-04-25 09:52:17',1,'>监听子组件中获取的数据 在data中初始化一个变量，并在watch中监听，在methods中发起网络请求并将数据赋值给这个变量时，watch中出发的回调函数和methods中还未执行的代码谁先执行？  ',0,NULL,0),(22,'Promise原理解析',1,'```javascript\nclass MyPromise {\n  constructor(executor) {\n    this.initValue();\n    this.initBind();\n    this.onFulFilledCallbacks = []\n    this.onRejectedCallbacks = []\n    try {\n      executor(this.resolve, this.reject);\n    } catch (e) {\n      this.reject(e)\n    }\n  }\n  initBind() {\n    this.resolve = this.resolve.bind(this)\n    this.reject = this.reject.bind(this)\n  }\n  initValue() {\n    this.PromiseResult = null\n    this.PromiseState = \'pending\'\n  }\n  resolve(value) {\n    //如果执行resolve,状态改变为\'fulfilled\',值为传进来的值\n    if (this.PromiseState !== \'pending\') return\n    this.PromiseState = \'fulFilled\'\n    this.PromiseResult = value\n    while (this.onFulFilledCallbacks.length !== 0) {\n      this.onFulFilledCallbacks.shift()()\n    }\n  }\n  reject(reason) {\n    if (this.PromiseState !== \'pending\') return\n    this.PromiseState = \'rejected\'\n    this.PromiseResult = reason\n    while (this.onRejectedCallbacks.length !== 0) {\n      this.onRejectedCallbacks.shift()()\n    }\n  }\n  then(onFulFilled, onRejected) {\n    //参数校验\n    onFulFilled = typeof onFulFilled === \'function\' ? onFulFilled : val => val\n    onRejected = typeof onRejected === \'function\' ? onRejected : reason => {\n      throw reason\n    }\n    var thenPromise = new MyPromise((resolve, reject) => {\n      const resolvePromise = cb => {\n        try {\n          const x = cb(this.PromiseResult) //返回得到结果的MyPromise\n          if (x === thenPromise) {\n            throw new Error(\"不能返回自身\");\n          }\n          if (x instanceof MyPromise) {\n            //返回值是解决，则新promise就是解决\n            //返回值是拒绝，则新promise就是拒绝\n            //返回值不是promise，则新promise为解决\n            x.then(resolve, reject)\n          } else {\n            resolve(x)\n          }\n        } catch (err) {\n          reject(err)\n        }\n      }\n      if (this.PromiseState === \'fulFilled\') {\n        resolvePromise(onFulFilled)\n      } else if (this.PromiseState === \'rejected\') {\n        resolvePromise(onRejected)\n      } else if (this.PromiseState === \'pending\') {\n        this.onFulFilledCallbacks.push(resolvePromise.bind(onFulFilled, this))\n        this.onRejectedCallbacks.push(resolvePromise.bind(onRejected, this))\n      }\n    })\n    return thenPromise\n  }\n}\nconst p4 = new MyPromise((resolve, reject) => {\n    resolve(100)\n  }).then(res => res).then(res => console.log(res))\n  \n```','2021-11-05 16:18:13','2022-08-22 09:13:44',0,'> Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。',0,NULL,0),(23,'理解代理',1,'假如去某个小区找人，DNS可以帮我定位到是哪栋大楼，URI可以帮我定位到是哪个房间。\n\n正向代理:\n   假如我【客户端】想找小强【服务端】借钱，但是我不好意思。我去找小李【代理】，然后让小李找小强借。对于小强来说他以为是小李找他借钱，而不是我。\n\n反向代理:\n  同样是借钱，这回我【客户端】找小李【代理】借钱，小李没钱了，他去找小强【服务端】借钱，然后再把钱借给我，对我来说我认为是小李借钱给我，而不是小强。\n\n  总结:\n   >正向代理的代理服务器是部署在客户端，而对服务端来说，它以为对它发起请求的是代理服务器，而真正请求的客户端对服务端来说是不可见的。\n	 \n\n   > 反向代理的代理服务器是部署在服务端，而对客户端来说，它以为对它做出响应的是代理服务器，而真正响应的服务端对客户端来说是不可见的。\n	 \n	 > 负载均衡代理\n\n<img src=\"https://docs.hgyn23.cn/static/c6050addc2bad0297b300d81c60b5717\" width=\"600px\" height=\"auto\" alt=\"c6050addc2bad0297b300d81c60b5717\">','2021-11-05 16:19:54','2022-08-02 03:12:16',1,'>正向代理的代理服务器是部署在客户端，而对服务端来说，它以为对它发起请求的是代理服务器，而真正请求的客户端对服务端来说是不可见的。    反向代理的代理服务器是部署在服务端，而对客户端来说，它以为对它做出响应的是代理服务器，而真正响应的服务端对客户端来说是不可见的。',0,NULL,0),(24,'vue-element-admin 学习记录',1,'# vue-element-admin 学习记录\nvue-element-admin 是一个**后台前端解决方案**，它基于 **vue** 和 **element-ui**实现。  \n# 项目目录结构\n├── build                      // 构建相关    \n├── config                     // 配置相关  \n├── src                        // 源代码  \n│   ├── api                    // 所有请求  \n│   ├── assets                 // 主题 字体等静态资源  \n│   ├── components             // 全局公用组件  \n│   ├── directive              // 全局指令  \n│   ├── filters                // 全局 filter  \n│   ├── icons                  // 项目所有 svg icons  \n│   ├── lang                   // 国际化 language  \n│   ├── mock                   // 项目mock 模拟数据  \n│   ├── router                 // 路由  \n│   ├── store                  // 全局 store管理  \n│   ├── styles                 // 全局样式  \n│   ├── utils                  // 全局公用方法  \n│   ├── vendor                 // 公用vendor  \n│   ├── views                   // view  \n│   ├── App.vue                // 入口页面  \n│   ├── main.js                // 入口 加载组件 初始化等  \n│   └── permission.js          // 权限管理  \n├── static                     // 第三方不打包资源  \n│   └── Tinymce                // 富文本  \n├── .babelrc                   // babel-loader 配置  \n├── eslintrc.js                // eslint 配置项  \n├── .gitignore                 // git 忽略项  \n├── favicon.ico                // favicon图标  \n├── index.html                 // html模板  \n└── package.json               // package.json  \n## src文件\n### api和views\n所有的api和views都一一对应，从而方便维护。  \n### components\n放一些全局公用的组件。  \n### store\n统一管理如登录token,用户信息，或者是一些全局个人偏好设置等data。  \n### alias\n为路径取别名，理清文件与文件之间的引用关系。  \n### ESLint\n规范代码格式，提高代码可读性。\n\n# 登录权限\n不同权限对应不同的路由，不同的路由异步生成对应不同的侧边栏。\n## 实现思路\n登录： 当用户填写完账号和密码后，向服务端验证是否正确，验证如果通过，则会返回一个**token**，拿到token后，将该token贮存在**cookie**中，保证浏览器刷新后仍然能记录状态，此时前端再根据token向服务器请求用户的详细信息。  \n权限验证：通过获取的**token**请求对应的**role**，根据role中的角色权限并通过**router.addRoutes**来动态挂载路由。  \n以上的所有数据由vuex统一管控，再刷新数据后，vuex的数据将会丢失，所以需要重复上述的步骤。  \n## 实现步骤\n### 登录获取token\n#### 登录页\n```javascript\n//vuex中存储登录数据\nthis.$store.dispatch(\'LoginByUsername\', this.loginForm).then(() => {\n  this.$router.push({ path: \'/\' }); //登录成功之后重定向到首页\n}).catch(err => {\n  this.$message.error(err); //登录失败提示错误\n});\n```\n#### action\n```javascript\n//定义登录方法\nLoginByUsername({ commit }, userInfo) {\n  //去一下空格\n  const username = userInfo.username.trim()\n  return new Promise((resolve, reject) => {\n    loginByUsername(username, userInfo.password).then(response => {\n      const data = response.data\n      Cookies.set(\'Token\', response.data.token) //登录成功后将token存储在cookie之中\n      commit(\'SET_TOKEN\', data.token)\n      resolve()\n    }).catch(error => {\n      reject(error)\n    });\n  });\n}\n```\n### 获取用户信息\n用户登陆成功后，在**router.beforeEach**中拦截路由，判断是否以获取token，判断之后开始获取用户信息。  \n```javascript\n//router.beforeEach\nif (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n  store.dispatch(\'GetInfo\').then(res => { // 拉取user_info\n    const roles = res.data.role;\n    next();//resolve 钩子\n  })\n```\n# 根据权限动态加载侧边栏\n实现思路：前端有一份路由表，它表示了每一个路由可以访问的权限，当用户登录后，通过**token**来获取对应的role，根据role的权限来动态算出对应的路由，再通过```router.addRoutes```来动态挂载路由。  \n## 实现步骤\n1. 在创建vue实例时，将vue-router挂载，但这个时候挂载的只是一些通用的路由，比如登录，或者不用权限的页面。\n2. 登陆成功后，根据token来获取role，并将role中的权限与路由表中的权限一一比对，生成最终用户可以访问的路由表。\n3. 调用```router.addRoutes(store.getters.addRouters)```来添加用户可以访问的路由。\n4. 使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。\n## 具体实现\n### router.js\n```javascript\n// router.js\nimport Vue from \'vue\';\nimport Router from \'vue-router\';\nimport Login from \'../views/login/\';\nconst dashboard = resolve => require([\'../views/dashboard/index\'], resolve);\n//使用了vue-router的懒加载\n//所有权限通用路由表 如首页和登录页和一些不用权限的公用页面\nexport const constantRouterMap = [\n  { path: \'/login\', component: Login },\n  {\n    path: \'/\',\n    component: Layout,\n    redirect: \'/dashboard\',\n    name: \'首页\',\n    children: [{ path: \'dashboard\', component: dashboard }]\n  },\n]\n//实例化vue的时候只挂载constantRouter\nexport default new Router({\n  routes: constantRouterMap\n});\n//异步挂载的路由\n//动态需要根据权限加载的路由表 \nexport const asyncRouterMap = [\n  {\n    path: \'/permission\',\n    component: Layout,\n    name: \'权限测试\',\n    meta: { role: [\'admin\',\'super_editor\'] }, //页面需要的权限\n    children: [\n    { \n      path: \'index\',\n      component: Permission,\n      name: \'权限测试页\',\n      meta: { role: [\'admin\',\'super_editor\'] }  //页面需要的权限\n    }]\n  },\n  { path: \'*\', redirect: \'/404\', hidden: true }\n];\n```\n根据 vue-router官方推荐的方法通过**meta**标签来标示改页面能访问的权限有哪些。如meta: { role: [\'admin\',\'super_editor\'] }表示该页面只有**admin**和**超级编辑**才能有资格进入。  \n### main.js\n```javascript\n// main.js\nrouter.beforeEach((to, from, next) => {\n  if (store.getters.token) { // 判断是否有token\n    if (to.path === \'/login\') { //如果到登录页\n      next({ path: \'/\' }); //回到首页\n    } else {\n      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息\n        store.dispatch(\'GetInfo\').then(res => { // 拉取info\n          const roles = res.data.role;\n          store.dispatch(\'GenerateRoutes\', { roles }).then(() => { // 生成可访问的路由表\n            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表\n            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record\n          })\n        }).catch(err => {\n          console.log(err);\n        });\n      } else {\n        next() //当有用户权限的时候，说明所有可访问路由已生成 如访问没权限的全面会自动进入404页面\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next();\n    } else {\n      next(\'/login\'); // 否则全部重定向到登录页\n    }\n  }\n});\n```\n在导航守卫中判断用户权限，同时根据用户信息动态添加当前用户可访问的路由表。  \n### store/permission.js\n```javascript\n// store/permission.js\nimport { asyncRouterMap, constantRouterMap } from \'src/router\'; //引入通用路由表和异步路由表\nfunction hasPermission(roles, route) { //鉴权\n  if (route.meta && route.meta.role) { \n    return roles.some(role => route.meta.role.indexOf(role) >= 0) //如果当前路由中有role的信息，那就看看在roles是否有这个role，如果有返回true\n  } else {\n    return true \n  }\n}\nconst permission = {\n  state: {\n    routers: constantRouterMap,\n    addRouters: []\n  },\n  mutations: {\n    SET_ROUTERS: (state, routers) => {\n      state.addRouters = routers;\n      state.routers = constantRouterMap.concat(routers); //把有权限的路由和通用路由拼接\n    }\n  },\n  actions: {\n    GenerateRoutes({ commit }, data) { //根据data的信息生成可以访问的路由表\n      return new Promise(resolve => {\n        const { roles } = data;\n        const accessedRouters = asyncRouterMap.filter(v => {\n          if (roles.indexOf(\'admin\') >= 0) return true; //如果roles里是admin，那就返回这个roles\n          if (hasPermission(roles, v)) {\n            if (v.children && v.children.length > 0) {\n              v.children = v.children.filter(child => { //如果有子路由，那就把子路由一个个拿来看有没有权限\n                if (hasPermission(roles, child)) {\n                  return child //把有权限的给他返回\n                }\n                return false; //去掉roles没有权限的路由\n              });\n              return v\n            } else {\n              return v\n            }\n          }\n          return false;\n        });\n        commit(\'SET_ROUTERS\', accessedRouters);\n        resolve();\n      })\n    }\n  }\n};\nexport default permission;\n```\n### 贴一下vuex的状态管理机制\n<!-- ![vuex](./img/vuex.png)   -->\n# 前后端交互\n## 实现思路\n1. UI 组件交互操作；  \n2. 调用统一管理的 api service 请求函数；\n3. 使用封装的 request.js 发送请求；\n4. 获取服务端返回；\n5. 更新 data；\n## 封装axios\n封装步骤：\n```javascript\n//引入axios\nimport axios from \'axios\'\nimport { Message } from \'element-ui\'\nimport store from \'@/store\'\n//引入token获取方法\nimport { getToken } from \'@/utils/auth\'\n// 创建axios实例\nconst service = axios.create({\n  baseURL: process.env.BASE_API, // api的base_url\n  timeout: 5000 // 请求超时时间\n})\n// request拦截器\nservice.interceptors.request.use(config => {\n  //判断store中token是否存在\n  if (store.getters.token) {\n    config.headers[\'X-Token\'] = getToken() // 在请求头中塞入token\n  }\n  return config\n}, error => {\n  // 请求错误时Promise返回reject\n  console.log(error) // for debug\n  Promise.reject(error)\n})\n// respone拦截器\nservice.interceptors.response.use(\n  //意外登出时 判断返回的错误码\n  response => response,\n   const res = response.data;\n      if (res.code !== 20000) {\n        Message({\n          message: res.message,\n          type: \'error\',\n          duration: 5 * 1000\n        });\n        // 50008:非法的token; 50012:其他客户端登录了;  50014:Token 过期了;\n        if (res.code === 50008 || res.code === 50012 || res.code === 50014) {\n          //当前页面弹出警告消息框\n          MessageBox.confirm(\'你已被登出，可以取消继续留在该页面，或者重新登录\', \'确定登出\', {\n            confirmButtonText: \'重新登录\',\n            cancelButtonText: \'取消\',\n            type: \'warning\'\n          }).then(() => {\n            store.dispatch(\'FedLogOut\').then(() => {\n              location.reload();// 为了重新实例化vue-router对象 避免bug\n            });\n          })\n        }\n        return Promise.reject(\'error\');\n      } else {\n        return response.data;\n      }\n  error => {\n    console.log(\'err\' + error)// for debug\n    Message({\n      message: error.message,\n      type: \'error\',\n      duration: 5 * 1000\n    })\n    return Promise.reject(error)\n  })\nexport default service\n```\n封装后使用步骤：  \n```javascript\n//引入封装好的axios请求\nimport request from \'@/utils/request\'\n//使用\nexport function getInfo(params) {\n  //入参为config\n  return request({\n    url: \'/user/info\',\n    method: \'get\',\n    params\n  });\n}\n```\n## 跨域问题纯前端解决方案\n开发环境可以通过配置 vue.config.js来解决  \n```javascript\n  devServer: {\n    port: 2021, // 设置端口号\n    host: \'10.32.120.69\', // ip\n    disableHostCheck: true, //是否关闭用于 DNS 重绑定的 HTTP 请求的 HOST 检查\n    hotOnly: false, // 热更新\n    https: false, // https:{type:Boolean}配置前缀\n    open: false, //配置自动启动浏览器\n    proxy: null,  //设置代理\n    proxy: {\n      \'/api\': { //代理标识,请求接口时遇到此路径则代理到该地址\n        target: \'http://localhost:2022/\', //指向的实际地址\n        changeOrigin: true, //是否跨域\n        ws: true, //如果要代理 websockets，配置这个参数\n        secure: false, // 如果是https接口，需要配置这个参数\n        // 标识替换\n        // 原请求地址为 /api/getData 将\'/api\'替换\'\'时，\n        // 代理后的请求地址为： http://xxx.xxx.xxx/getData\n        // 若替换为\'/other\',则代理后的请求地址为 http://xxx.xxx.xxx/other/getData \n        pathRewrite: { // 标识替换\n          \'^/api\': \'/api/mock\' //\n        }\n      }\n    }\n```\n生产环境可以通过配置 nginx 来解决\n# Mock 数据\n使用mock数据可以分离前后端开发，通过预先与后端约定的接口来模拟数据请求，让前端开发更加独立自主，不被后端开发进度所阻塞。  \n## Easy-Mock\n线上免费服务很不稳定。\n## Mockjs\n实现机制中会重写`XMLHttpRequest`对象，导致`progress`或一些底层依赖`XMLHttpRequest`的库都会不兼容，而且调试不方便。\n## 新方案\n在4.0版本之后，在本地会启动一个`mock-server`来模拟数据。  \n好处：在保留mockjs优势的同时，解决之前的痛点。因为`mock-server`是完全基于`webpack-dev-server`来实现的，所以在启动前端服务时，`mock-server`会自动启动，而且使用`chokidar`来观察mock文件夹内容的变化，支持**热更新**。并且可以通过控制台中的`network`来观察接口返回的数据结构。  \n为了方便在不同的环境使用不同的api，所有的请求都设置了一个`baseURL`，这个baseURL可以通过读取`process.env.VUE_APP_BASE_API`这个环境变量来动态设置。  \n## 移除mock-server\n如果不需要使用`mock-server`可以在`vue.config.js`中移除`webpack-dev-server`中的`proxy`和`after`。 \n## 新增mock数据\n在根目录下找到mock文件，添加对应的路由，对其进行拦截和模拟数据。\n# 使用第三方库\n在Vue.js项目中使用第三方库的一个优雅的方式是将其代理到Vue的原型对象上去 比如说引入Moment库。  \n## main.js\n```javascript\nimport moment from \'moment\'\nObject.defineProperty(Vue.prototype, \'$moment\', { value: moment })\n```\n为什么不直接`Vue.prototype.$moment = moment`呢？ 因为使用`Object.defineProperty`能够配置对象内置属性，比如是否可被迭代，是否只读等，用来防止出现意料之外的操作导致他的数据被修改。  \n# 构建\n当项目开发完毕 运行`npm run build:prod`打包正式环境，运行`npm run build:stage`打包预发布环境。如需要自定义构建，如dist文件输出目录，可在`config`中`outputDir`中进行配置。  \n# 环境变量\n环境变量都保存在`.env.xxxx`文件中，他们都会通过webpack.DefinePlugin插件注入到全局。\n> 一定要注意的是，环境变量必须要以`VUE_APP_`开头，如：VUE_APP_API等  \n获取环境变量使用如下方式：  \n> ```javascript\n> console.log(process.env.VUE_APP_xxxx)\n> ```\n# 分析构建文件体积\n通过`webpack-bundle-analyzer`命令分析代码体积分布来优化代码  \n```javascript\nnpm run preview -- --report\n```\n# 文件命名规则\n## Component\n所有的`Component`文件都以大写开头，除了index.vue。。  \n如：  \n> @/components/BackToTop/index.vue  \n> @/components/Charts/Line.vue  \n> @/views/example/components/Button.vue\n## JS文件\n所有的.js文件都遵循横线连接。  \n如：  \n> @/utils/open-window.js  \n> @/views/svg-icons/require-icons.js  \n> @/components/MarkdownEditor/default-options.js\n## Views\n在views文件下的.vue文件都代表一个路由，遵循横线连接。  \n如：  \n> @/views/svg-icons/index.vue  \n> @/views/svg-icons/require-icons.js\n为什么呢要这样命名？因为横线链接连接也是命名规范之一，views下的.vue文件代表的是一个路由，所以要和component区分（component都是以大写开头），还有页面的URL也是用横线连接的，比如`https://www.xxx.admin/export-excel`，所以对应的view也要保持统一，也没有大小写敏感的问题。\n# 路由懒加载\n把不同的路由组件分割成不同的代码块，当路由被访问的时候才加载对应的组件。\n```javascript\nconst Foo = () => import(\'./Foo.vue\')\n// 一来可以聚合webpackChunkName名字一样的为一个模块，也是当前版本推荐的加载姿势\nconst Home = () =>\n  import(/* webpackChunkName: \"HomePage\" */ \"@/views/home/index.vue\");\n```\n# Echarts\n## 按需引入\n```javascript\n// 按需引入 引入 ECharts 主模块\nvar echarts = require(\'echarts/lib/echarts\')\n// 引入柱状图\nrequire(\'echarts/lib/chart/bar\')\n// 引入提示框和标题组件\nrequire(\'echarts/lib/component/tooltip\')\nrequire(\'echarts/lib/component/title\')\n```\n## 全部引入\n```javascript\nvar echarts = require(\'echarts\')\n```\n## 初始化\n因为ECharts初始化必须绑定dom，所以只能在mounted生命周期里进行初始化。\n```javascript\nmounted() {\n  this.initCharts(); //初始化ECharts\n},\nmethods: {\n  initCharts() {\n    this.chart = echarts.init(this.$el);\n    this.setOptions();\n  },\n  setOptions() { //配置\n    this.chart.setOption({\n      title: {\n        text: \'ECharts 入门示例\'\n      },\n      tooltip: {},\n      xAxis: {\n        data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]\n      },\n      yAxis: {},\n      series: [{\n        name: \'销量\',\n        type: \'bar\',\n        data: [5, 20, 36, 10, 10, 20]\n      }]\n    })\n  }\n}\n```\n如果ECharts的data是远程获取的，那么可以用`watch`来触发`setOptions`方法。  \n```javascript\n//第一种 watch options变化 利用vue的深度 watcher，options 一有变化就重新setOption\nwatch: {\n  options: {\n    handler(options) {\n      this.chart.setOption(this.options)\n    },\n    deep: true\n  },\n}\n//第二种 只watch 数据的变化 只有数据变化时触发ECharts\nwatch: {\n  seriesData(val) {\n    this.setOptions({series:val})\n  }\n}\n```','2021-11-05 16:21:32','2022-04-25 09:52:13',1,'>vue-element-admin 是一个**后台前端解决方案**，它基于 **vue** 和 **element-ui**实现。',0,NULL,0),(25,'vue的双向绑定原理及实现(待完善)',1,'# 先贴上地址 供后续参考\n[vue的双向绑定原理及实现](https://www.cnblogs.com/canfoo/p/6891868.html)\n','2021-11-11 16:18:30','2022-04-25 09:52:14',0,' >简要介绍及实现vue的双向绑定',0,NULL,0),(26,'虚拟dom和diff算法实现原理（snabbdom）',1,'>先埋个坑','2021-11-11 16:41:03','2022-04-25 09:52:06',0,'>简要介绍并实现snabbdom',0,NULL,0),(27,'Vuejs搭建Server-render项目简要流程',1,'## 使用vue-ssr构建服务端渲染流程\n### 概要\n#### Vue.js\n>Vue.js是构建客户端程序的框架，**默认**情况下，Vue.js可以在浏览器输出vue组件，并进行生成和操作DOM。  \n#### 服务端渲染\n>服务端渲染（Server-Side Rendering），是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。  \n#### 与客户端渲染的区别\n两张图说明\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/421469d3f7694f5da604a2c12169ec89~tplv-k3u1fbpfcp-watermark.image?)\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e3e6270b7d42d0b09a10d72c7f2d47~tplv-k3u1fbpfcp-watermark.image?)\n\n第1张是单页应用（SPA）渲染结果，第2张是服务端渲染过的（SSR）。很容易看出来，相比于客户端渲染利用AJAX获取js文件再渲染出HTML的方式，服务端渲染在首次获取HTML的时候，模板包括数据已经被完整带过来了。\n#### 为什么使用服务端渲染\n- 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。\n- 更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。网站如果注重用户体验，这个指标是绝对关键的，在这种情况下，服务器端渲染 (SSR) 可以实现最佳的初始加载性能。\n\n\n### 服务端构建流程\n#### 目录结构\n    ├── client  \n    │   ├── build                      // 构建相关  \n    │   ├── config                     // 配置相关  \n    │   ├── public                     // 公共文件  \n    │   ├── src                        // 源代码  \n    │   │   ├── api                    // 所有请求  \n    │   │   ├── assets                 // 主题 字体 CSS等静态资源  \n    │   │   ├── components             // 全局公用组件  \n    │   │   ├── filters                // 全局 filter  \n    │   │   ├── router                 // 路由  \n    │   │   ├── store                  // 全局 store管理  \n    │   │       ├── modules                  // vuex子模块  \n    │   │   ├── utils                  // 全局公用方法  \n    │   │   ├── views                  // view  \n    │   │   ├── entry-client.js        // 仅运行于浏览器  \n    │   │   ├── entry-server.js        // 仅运行于服务器  \n    │   │   ├── App.vue                // 入口页面  \n    │   │   └── main.js                // 入口 加载组件 初始化等  \n    │   ├── static                     // 第三方不打包资源  \n    │   ├── .babelrc                   // babel-loader 配置  \n    │   ├── eslintrc.js                // eslint 配置项  \n    │   ├── .gitignore                 // git 忽略项  \n    │   ├── .postcssrc.js              // css前缀配置  \n    │   └── index.html                 // html模板  \n    ├── server\n    │   ├── bin                    // bin  \n    │   ├── config                 // 数据库配置  \n    │   ├── dao                    // 交互模型  \n    │   ├── db                     // 数据库文件  \n    │   ├── middleware             // 中间件  \n    │   ├── model                  // 数据模型  \n    │   ├── route                  // 路由  \n    │   ├── mock                   // 项目mock 模拟数据  \n    │   ├── router                 // 路由  \n    │   ├── sql                    // 通用sql语句管理  \n    │   ├── static                 // 静态文件  \n    │   └── utils                  // 全局公用方法  \n    └── package.json               // package.json  \n\n### 构建流程(客户端)\n 输入命令`vue init webpack vue-ssr-demo` 使用vue初始化一个基于webpack的vue-ssr-demo项目，生成大致的client结构。\n#### `main.js`\n`main.js`为应用通用入口，再纯客户端应用程序中，在此创建vue根实例，并直接挂载到DOM，但对于服务端渲染，因为此时运行在node环境，所以将挂载DOM的步骤转移到`entry-client.js`中，`main.js`中仅导出`createApp`函数。\n```javascript\nimport Vue from \'vue\'\nimport App from \'./App\'\nexport function createApp (context) {\n  const app = new Vue({\n    render: h => h(App)\n  })\n  return { store, router, app }\n}\n```\n#### `entry-client.js`\n`entry-client.js`在浏览器运行，负责创建应用程序，并挂载到DOM\n```javascript\nimport { createApp } from \"./main\";\nconst { app } = createApp();\n//  挂载#app\nrouter.onReady(() => {\n  app.$mount(\"#app\");\n});\n```\n#### `entry-server.js`\n`entry-server.js`在服务端运行，在每次渲染中将重复调用此函数，用来创建并返回应用实例。\n```javascript\nimport { createApp } from \"./main\";\nexport default (context) => {\n  //传入路由参数等构成的对象，后续将在此执行服务器端路由匹配和数据预取\n  const { app } = createApp();\n  return app\n};\n```\n#### 使用vue-router的路由\n类似于`main.js`中导出的`createApp`函数，在router文件夹下创建index.js文件,在这里创建路由并已函数形式导出。\n```javascript\nimport Vue from \"vue\";\nimport VueRouter from \"vue-router\";\n\nVue.use(VueRouter);\n// 解决重复点击路由报错的BUG\nconst originalPush = VueRouter.prototype.push;\nVueRouter.prototype.push = function push(location) {\n  return originalPush.call(this, location).catch(err => err);\n};\nexport function createRouter() {\n  const router = new VueRouter({\n    routes: [\n      {\n        path: \"/\",\n        redirect: \"home\"\n      },\n      {\n        path: \"/home\",\n        name: \"Home\",\n        component: () => import(\"../views/home.vue\")\n      },\n      {\n        path: \"/about\",\n        name: \"About\",\n        component: () => import(\"../views/about.vue\")\n      }\n    ]\n  });\n  return router\n}\n```\n在`main.js`中导入vue-router\n```javascript\nimport Vue from \'vue\'\nimport App from \'./App\'\nimport { createRouter } from \'./router\'\nVue.config.productionTip = false\n/* eslint-disable no-new */\nexport function createApp (context) {\n  const router = createRouter()\n  const app = new Vue({\n    router,\n    context,\n    render: h => h(App)\n  })\n  return { router, app }\n}\n```\n#### 使用vuex 的状态管理\n类似于`main.js`中导出的`createApp`函数，在store文件夹下创建index.js文件,在这里创建vuex并以函数形式导出。\n```javascript\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport getters from \"./getters\";\n//导入所有分割的vuex模块\nconst modulesFiles = require.context(\"./modules\", true, /\\.js$/);\nconst modules = modulesFiles.keys().reduce((modules, modulePath) => {\n  const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, \"$1\");\n  const value = modulesFiles(modulePath);\n  modules[moduleName] = value.default;\n  return modules;\n}, {});\nVue.use(Vuex);\nexport function createStore() {\n  const store = new Vuex.Store({\n    modules,\n    getters\n  });\n  return store;\n}\n```\n在`main.js`中导入vuex\n```javascript\nimport Vue from \'vue\'\nimport App from \'./App\'\nimport { createStore } from \'./store\'\nimport { createRouter } from \'./router\'\nVue.config.productionTip = false\n/* eslint-disable no-new */\nexport function createApp (context) {\n  const store = createStore()\n  const router = createRouter()\n  const app = new Vue({\n    router,\n    store,\n    context,\n    render: h => h(App)\n  })\n  return { store, router, app }\n}\n```\n#### 数据预取\n>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的\"快照\"，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。  \n>另一个需要关注的问题是在客户端，在挂载 (mount) 到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。\n\n混合所谓的意思就是在服务器端预先收到并处理的数据必须存放到一个数据容器或状态容器中，客户端进行挂载时需要取到这些数据来保证数据是同步的。  \n所以在数据预取之前需要做些准备工作，这里使用官方的状态管理库`vuex`，模块代码如下：\n```javascript\n// list.js\nconst state = {\n  num: 0\n}\nconst mutations = {\n  ADD (state) {\n    state.num ++\n    console.log(state.num);\n  }\n}\nconst actions = {\n\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n```\n\n```javascript\n// getters.js\nconst getters = {\n  num: state => state.list.num\n}\nexport default getters\n```\n\n```javascript\n// index.js\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport getters from \"./getters\";\n//用于读取modules文件夹下的模块\nconst modulesFiles = require.context(\"./modules\", true, /\\.js$/);\nconst modules = modulesFiles.keys().reduce((modules, modulePath) => {\n  const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, \"$1\");\n  const value = modulesFiles(modulePath);\n  modules[moduleName] = value.default;\n  return modules;\n}, {});\nVue.use(Vuex);\nexport function createStore() {\n  const store = new Vuex.Store({\n    modules,\n    getters\n  });\n  return store;\n}\n```\n然后修改 `main.js`\n```javascript\n//main.js\n\nimport Vue from \'vue\'\nimport App from \'./App\'\nimport { createStore } from \'./store\'\nimport { createRouter } from \'./router\'\nimport { sync } from \'vuex-router-sync\' //用于同步路由状态(router.state)到vuex\nimport \'./elementUI/index\'\nVue.config.productionTip = false\nexport function createApp (context) {\n  const store = createStore()\n  const router = createRouter()\n  //同步路由状态\n  sync(store, router)\n  const app = new Vue({\n    //将router和store注入\n    router,\n    store,\n    context,\n    render: h => h(App)\n  })\n  return { store, router, app }\n}\n```\n准备工作做好了，下一步是进行数据的预取，在纯客户端应用程序里，我们通过访问一个路由，在其生命周期钩子函数里可以进行AJAX请求获取所需数据。所以在路由组件中进行数据预取是最合适和自然的方式。\n>由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染 (SSR) 过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。\n\n首先想到在created钩子中获取，但是这个钩子同样在客户端会执行，明显是不行的。所以我们将在路由组件上暴露出一个自定义静态函数 preFetch。\n```javascript\n//xxx.vue\n\nexport default {\npreFetch(store) {\n  //返回Promise\n    return store.dispatch(\"list/getOneBlog\", store.state.route.params.id);\n  },\n  ...\n  computed: {\n    // 从 store 的 state 对象中的获取 item。\n    item () {\n      return this.$store.state.list.blogs[this.$route.params.id]\n    }\n}\n\n```\n#### 服务器端数据预取\n通过`router.getMatchedComponents()`获取与路由相匹配的组件，如果组件暴露出`preFetch`方法，就调用这个方法来将数据存到store里。并将解析完成以后的状态附加到渲染上下文中。\n```javascript\n//entry-server.js\n\nimport { createApp } from \"./main\";\nexport default (context) => {\n  const { router, store, app } = createApp();\n  return new Promise((resolve, reject) => {\n    router.push(context.url);//传入路由\n    //router.onReady(callback, [errorCallback]):该方法把一个回调排队，在路由完成初始导航时调用，这意味着它可以解析所有的异步进入钩子和路由初始化相关联的异步组件。这可以有效确保服务端渲染时服务端和客户端输出的一致。\n    router.onReady(() => {\n      const matchComponents = router.getMatchedComponents();\n      if (!matchComponents.length) {\n        reject(context);\n      }\n      Promise.all(\n        matchComponents.map((component) => {\n          if (component.preFetch) {\n            return component.preFetch(store);\n          }\n        })\n      )\n        .then(() => {\n          //将解析完成的状态附加到渲染上下文中\n          context.state = store.state;\n          resolve(app);\n        })\n        .catch(reject);\n    });\n  });\n};\n\n```\n>当使用 template 时，`context.state` 将作为`window.__INITIAL_STATE__` 状态，自动嵌入到最终的 HTML 中。\n\n在客户端中,在挂载应用程序之前，store需要与服务端同步。\n```javascript\n//entry-client.js\nimport { createApp } from \'./main\'\nconst { router, store, app } = createApp()\n// store替换使client rendering和server rendering匹配\nif (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}\n//  挂载#app\nrouter.onReady(() => {\n  app.$mount(\'#app\')\n})\n```\n### 客户端激活\n>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。\n在页面模板index.html 中，需要加一行注释`<!--vue-ssr-outlet-->`，这是vue-ssr注入HTML的地方\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head><title>Hello</title></head>\n  <body>\n    <!--vue-ssr-outlet-->\n  </body>\n</html>\n```\n注入后\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head><title>Hello</title></head>\n  <body>\n    <div id=\"app\" data-server-rendered=\"true\">\n            <button>home</button>\n            <button>about</button>\n            <div data-v-4782137e>\n                <h1 data-v-4782137e>about页</h1>\n            </div>\n  </body>\n</html>\n```\n>data-server-rendered 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。\n\n### 构建流程(服务器)\n使用`express-generator`生成`express`应用程序框架。\n```javascript\n//app.js\n\nvar express = require(\"express\");\nvar path = require(\"path\");\nvar cookieParser = require(\"cookie-parser\");\nvar logger = require(\"morgan\");\nvar fs = require(\"fs\");\nvar cache = require(\"lru-cache\");\nconst { createBundleRenderer } = require(\"vue-server-renderer\");\nconst resolve = (file) => path.resolve(__dirname, file);\nconst isProd = true;\nvar app = express();\nlet readyPromise;\n// 跨域配置\napp.all(\"*\", function (req, res, next) {\n  // 设置允许跨域的域名，*代表允许任意域名跨域\n\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  // 允许的header类型\n  res.header(\n    \"Access-Control-Allow-Headers\",\n    \"Content-Type,Access-Token,Appid,Secret,Authorization\"\n  );\n  // 跨域允许的请求方式\n  res.header(\"Access-Control-Allow-Methods\", \"DELETE,PUT,POST,GET,OPTIONS\");\n  if (req.method.toLowerCase() == \"options\") res.sendStatus(200);\n  // 让options尝试请求快速结束\n  else next();\n});\napp.use(logger(\"dev\"));\napp.use(express.json());\napp.use(\n  express.urlencoded({\n    extended: false,\n  })\n);\napp.use(cookieParser());\n\nlet renderer;\nfunction createRenderer(bundle, options) {\n  return createBundleRenderer(\n    bundle,\n    Object.assign(options, {\n      cache: new cache({\n        max: 1000,\n        maxAge: 1000 * 60 * 10,\n      }),\n      runInNewContext: false,\n    })\n  );\n}\n//微缓存服务\nconst serve = (path, cache) => express.static(resolve(path), {\n  maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0\n})\napp.use(\'/dist/\', serve(\'../client/dist\', true))\napp.use(\'/public/\', serve(\'../client/public\', true))\n\nif (isProd) {\n  const bundle = require(\"../client/dist/vue-ssr-server-bundle.json\");\n  const template = fs.readFileSync(\n    resolve(\"../client/public/index.html\"),\n    \"utf-8\"\n  );\n  const clientManifest = require(\"../client/dist/vue-ssr-client-manifest.json\");\n\n  renderer = createRenderer(bundle, { template, clientManifest });\n} else {\n  readyPromise = require(\"../client/build/setup-dev-server\")(\n    app,\n    resolve(\"../client/public/index.html\"),\n    (bundle, options) => {\n      renderer = createRenderer(bundle, options);\n    }\n  );\n}\n\nasync function render(req, res) {\n  const s = Date.now();\n  res.setHeader(\"Content-Type\", \"text/html\");\n  const context = {\n    title: \"lan bi tou\", // default title\n    url: req.originalUrl,\n  };\n  let result = await renderToStringPromise(context);\n  res.send(result);\n}\nfunction renderToStringPromise(context) {\n  return new Promise((resolve, reject) => {\n    renderer.renderToString(context, (err, html) => {\n      if (err) {\n        console.log(err);\n      }\n      if (!isProd) {\n        console.log(`whole request: ${Date.now() - s}ms`);\n      }\n      resolve(html);\n    });\n  });\n}\napp.get(\n  \"*\",\n  isProd\n    ? (req, res) => {\n        render(req, res);\n      }\n    : (req, res) => {\n        readyPromise.then(() => render(req, res));\n      }\n);\nmodule.exports = app;\n\n```\n### webpack配置\n配置可参考[构建配置](https://ssr.vuejs.org/zh/guide/build-config.html#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE-server-config)或参考demo中webpack配置  \n### 体验[demo](https://github.com/huangyan321/vue-ssr-demo)\n\n参考文献：[Vue SSR指南](https://ssr.vuejs.org/zh/)\n','2021-11-16 18:00:37','2022-04-25 08:40:37',1,'>服务端渲染（Server-Side Rendering），是指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。  ',0,NULL,0),(28,'服务端渲染中引入 element-ui样式 报错 窗口未定义',1,'ReferenceError: window is not defined  \n    at main.js:202:3  \n    at main.js:192:47  \n    at module.exports.module.exports (/style-loader/addStyles.js:47:0)  \n    at Object.<anonymous> (~/element-ui/lib/theme-chalk/pagination.css?0a5d:7:58)  \n    at __webpack_require__ (webpack:/webpack/bootstrap 7ab030b04d49d10f26c2:25:0)  \n    at Object.<anonymous> (main.js:752:100)  \n    at __webpack_require__ (webpack:/webpack/bootstrap 7ab030b04d49d10f26c2:25:0)  \n    at Object.<anonymous> (client/src/main.js:1:0)  \n    at __webpack_require__ (webpack:/webpack/bootstrap 7ab030b04d49d10f26c2:25:0)  \n    at Object.<anonymous> (main.js:796:64)  \n\n> 解决方案： 引入加载器**isomorphic-style-loader**','2021-11-23 09:58:21','2022-04-25 09:52:05',1,'>服务端渲染中引入 element-ui样式 报错 窗口未定义',0,NULL,0),(29,'webpack详解',1,'>待完善','2021-11-24 20:17:29','2022-04-25 08:40:37',0,'>webpack知识点',0,NULL,0),(30,'服务器部署站点时的简要配置',1,'> 今天把服务器玩崩了 重装了一下 顺便过了一下部署站点的流程 以此记录 日后再次部署可加快效率\n\n### 更新软件包\n\n- 确保 apt-get 安装最新版本的软件包  \n  `sudo apt update`\n\n### Git 安装和配置\n\n#### 安装\n\n `sudo apt-get install git`\n\n#### 配置\n\n1. 配置git用户名和邮箱：  \n    `git config --global user.name \"Your Name\"`  \n     `git config --global user.email \"youremail@yourdomain.com\"`\n2. 验证配置：  \n    `git config --list`  \n\n    该配置被存储在`~/.gitconfig`文件中  \n3. 配置SSH key\n    - 查看是否已有密钥  \n      `cd ~/.ssh`\n    - 生成密钥  \n      `ssh-keygen -trsa -C \"youremail@yourdomain.com\"`  \n\n      接着按3个回车，密码为空。  \n      命令执行结束之后，`~`目录下会生成`.ssh`目录，`cd`到该目录下，使用`ls`命令可以看出得到了两个文件：`id_rsa（私钥）`和`id_rsa.pub（公钥）`。查看`id_rsa.pub`文件：  \n      `vim id_rsa.pub`\n\n      复制全部内容 粘贴到版本管理系统的SSH公钥中。\n\n#### 管理多个ssh公钥\n\n1. 启动 ssh-agent\n\n  ```\n  eval `ssh-agent -s`  \n  ssh-add\n  ```\n\n2. 配置ssh代理\n\n    - 查询系统ssh key的代理：\n\n      ```\n      ssh-add -l\n      ```\n\n    - 如果系统已经设置了代理，需要删除：\n\n      ```\n      $ ssh-add -D\n      All identities removed.\n      ```\n\n    - 接下来添加刚才创建的ssh key的私钥：\n\n      ```\n      //第一个\n        $ ssh-add ~/.ssh/id_rsa_github\n        Enter passphrase for /Users/XXX/.ssh/id_rsa_github: \n        Identity added: /Users/XXX/.ssh/id_rsa_github (/Users/XXX/.ssh/id_rsa_github)\n\n      //第二个\n        $ ssh-add ~/.ssh/id_rsa_gitee\n        Enter passphrase for /Users/XXX/.ssh/id_rsa_gitee: \n        Identity added: /Users/XXX/.ssh/id_rsa_gitee (/Users/XXX/.ssh/id_rsa_gitee)\n      ```\n\n3. 添加公钥\n\n    添加公钥到版本管理系统的SSH公钥中\n\n4. 配置文件config\n\n    - 在/.ssh目录下创建config配置文件：\n\n        ```\n        vim ~/.ssh/config\n        ```\n\n        ```\n        # gitee\n          Host gitee\n            User git\n            HostName gitee.com\n            PreferredAuthentications publickey\n            IdentityFile ~/.ssh/id_rsa\n            ServerAliveInterval 300\n            ServerAliveCountMax 10\n        # github\n          Host github\n            User git\n            HostName github.com\n            PreferredAuthentications publickey\n            IdentityFile ~/.ssh/github\n            ServerAliveInterval 300\n            ServerAliveCountMax 10\n        ```\n\n    - 编辑保存后，再次查看ssh key的代理：\n\n      ```\n      ssh-add -l\n      ```\n\n    - 如果看到如下，说明设置成功了：\n\n      ```\n      2048 SHA256:............ /Users/XXX/.ssh/id_rsa_github (RSA)\n      2048 SHA256:............ /Users/XXX/.ssh/id_rsa_gitee (RSA)\n      ```\n\n5. 验证ssh key\n\n    - 终端中输入如下验证命令，如果返回如下，说明配置成功了：\n\n      ```\n      $ ssh -T git@github.com\n      Hi XXXXXX! You\'ve successfully authenticated, but GitHub does not provide shell access.\n\n      $ ssh -T git@gitee.com\n      Hi XXXXXX! You\'ve successfully authenticated, but Gitee.com does not provide shell access.\n\n      ```\n\n6. **注意**\n\n      ssh-agent可以手动运行，有两条命令可以用来启动：\n\n      >`ssh-agent $SHELL` ：它会在当前 shell 中启动一个默认shell作为当前shell 的**子 shell**，ssh-agent 会在子shell中运行；可以明确指定$SHELL ，比如 ssh-agent bash ， ssh-agent 会随当前 ssh 会话的结束而结    束，这是一种安全机制。\n\n      >eval \\`shell-agent\\` : 在windows中为 `eval $(ssh-agent` ： 它并不会    启动一个子shell，而是直接启动一个`ssh-agen`t 进程；此时当我们退出当前     bash 后，ssh-agent进程并**不会**自动关闭。我们可以在当前bash退出之前，使    用`ssh-agent -k` ，或者在当前 `bash` 退出之后，使用 `kill` 令，关闭对应    的 ssh-agent 进程。\n\n运行 ssh agent 以后，会加载默认的私钥，\n\n如果有多个密钥，则需要在 ~/.ssh/config 中进行配置：\n\nFAQ: 在 git 的安装目录中。找到 etc 下的 bash.bashrc 文件,在文件末尾添加以下内容（其中里面的 ssh-add 添加的私钥是前面自己的生成的），这样的目的就是每次启动 shell 的时候会自动执行这些命令\n<img src=\"http://159.75.104.17:9000/static/343719c9f234317e33dfe1aa8fa0a76d\" width=\"600px\" height=\"auto\" alt=\"343719c9f234317e33dfe1aa8fa0a76d\">\n<img src=\"http://159.75.104.17:9000/static/2aed99c16e3e326479fad6606f48743c\" width=\"600px\" height=\"auto\" alt=\"2aed99c16e3e326479fad6606f48743c\">\n```\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_rsa_me_gitee\n```\n\n### NVM 安装\n\n#### 安装\n\nShell脚本可用于在Ubuntu 20.04 Linux系统上安装NVM， 使用以下命令在系统上安装`curl`并运行NVM安装程序脚本。\n\n `sudo apt install curl`\n`curl https://raw.githubusercontent.com/creationix/nvm/master/install.sh | bash`\n\nNVM安装程序脚本会为当前用户的登录脚本创建一个环境条目。 可以注销然后重新登录以加载环境，或者运行以下命令来执行相同的操作。\n`source ~/.profile`\n\n#### Node安装\n\n安装最新版本的Node.js：\n`nvm install node`\n\n安装特定版本的Node.js：  \n`nvm install xx.xx.x(版本号)`  \n\n可以输入`nvm`来查看帮助列表。\n\n### MYSQL 安装和配置\n\n#### 安装\n\n  1. 检查是否已经安装mysql  \n\n      `sudo netstat -tap | grep mysql`\n\n  2. 安装mysql\n\n      `sudo apt-get install mysql-server mysql-client`\n\n    在此安装过程中会让你输入root用户(管理MySQL数据库用户，非Linux系统用户)密码，按照要求输入即可。\n  \n#### 配置\n\n  1. 修改配置文件的端口绑定\n\n       `sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf`\n\n      在下面行的开头加上#，注释掉该行，然后保存退出vim：\n\n       `bind-address = 127.0.0.1`\n\n  2. 修改密码\n\n      - mysql**5.7**以下  \n         `update user set password=PASSWORD(\"123456\") where user=root;`  \n        或者是  \n           `update user set authentication_string=PASSWORD(“123456”) where user=‘root’;`\n\n           执行完命令之后 flush privileges;  更新所有操作权限，重启数据库 service mysql restart\n\n      - 默认安装的最新版mysql**8.0**  \n          `use mysql;`  \n\n          `update user set authentication_string=\'\' where user=\'root\';`  \n          将 `authentication_string`  字段置空  \n\n          `alter user \'root\'@\'localhost\' identified with mysql_native_password by \'123456\';`  修改密码为123456\n\n  3. 数据库导入导出  \n       - 建一个空数据库‘target_database’作为目标数据库\n       - `mysql> create database target_database;`\n       - 导出数据库\n         - 使用mysqldump命令导出数据库\n         - `mysqldump -u 用户名 -p 密码 database > xxx.sql(导出文件路径)`\n         - 只导出建表指令\n           - `mysqldump -uroot -p -d original_database > xxx.sql(导出文件路径)`\n         - 只导出插入数据的sql指令\n           - `mysqldump -uroot -p -t original_database > xxx.sql(导出文件路径)`\n       - 导入数据库\n         - `mysql -uroot -p target_database < xxx.sql(导入文件路径)`\n\n  4. 主机配置\n\n ```\n\n use mysql;\n\n select host from user where user=\'root\';\n\n update user set host = \'%\' where user =\'root\'; //设置所有(%)IP可连接\n\n ```\n\n### NGINX安装和配置\n\n#### 安装\n\n  Nginx 在默认的 Ubuntu 源仓库中可用  运行下面的命令\n  > `sudo apt install nginx`  \n\n  一旦安装完成，Nginx 将会被自动启动。可以运行下面的命令来验证它：\n  > `sudo systemctl status nginx`\n\n  所有的 Nginx 配置文件都在/etc/nginx/目录下。  \n\n- 测试安装  \n    在浏览器中打开`http://yourip`，可以看到默认的 Nginx 加载页面。\n\n#### 配置\n\n可通过 [nginxconfig](https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN) 在线配置，只需要选择场景，填写好参数，系统将自动生成配置文件。按照流程走就行了。\n','2021-12-03 16:14:35','2022-07-05 01:21:00',1,'> 服务器：配置部署站点所需环境完整流程',0,NULL,0),(31,'资料整理',1,'### 技术文档\n- [Waline,一款基于 Valine 衍生的简洁、安全的评论系统。](https://waline.js.org/)\n- [《ECMAScript 6 教程》](https://wangdoc.com/es6/index.html)\n- [浏览器内核、JS 引擎、页面呈现原理及其优化](https://www.zybuluo.com/yangfch3/note/671516)\n- [推送+pushplus](https://www.pushplus.plus/doc/#%E5%BC%95%E8%A8%80)\n- [现代 JavaScript 教程](https://zh.javascript.info/)\n- [Vue SSR](https://www.ltonus.com/Vue3/guide/ssr/routing.html#%E5%9F%BA%E4%BA%8E-vue-router-%E7%9A%84%E8%B7%AF%E7%94%B1)\n- [Variant Form - 可视化低代码表单](https://www.vform666.com/)\n- [Docker — 从入门到实践](https://vuepress.mirror.docker-practice.com/)\n- [google chromium v8](https://chromium.googlesource.com/v8/v8/+/refs/tags/3.29.45)\n- [esbuild](https://esbuild.docschina.org/)\n- [基于vue compositionApi的使用函数库](https://vueuse.org/guide/)\n\n#### 应用框架\n\n- [umijs 企业级前端应用框架](https://umijs.org/)\n- [weex](http://doc.weex.io/zh/)\n\n#### CSS框架\n\n- [Tailwind CSS](https://www.tailwindcss.cn/docs)\n- [windicss](https://cn.windicss.org/)\n\n### JS库\n\n- [vue状态管理工具pinia](https://pinia.vuejs.org/)\n- [播放器插件dplayer](http://dplayer.js.org/zh/)\n- [Vue图片浏览组件v-viewer，支持旋转、缩放、翻转等操作](https://mirari.cc/2017/08/27/Vue%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E7%BB%84%E4%BB%B6v-viewer%EF%BC%8C%E6%94%AF%E6%8C%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE%E3%80%81%E7%BF%BB%E8%BD%AC%E7%AD%89%E6%93%8D%E4%BD%9C/)\n- [抽奖插件](https://100px.net/)\n\n### 优秀站点\n\n- [**前端瓶子君**](https://www.pzijun.cn/)\n- [冴羽的博客](https://github.com/mqyqingfeng/Blog)\n- [springleo\'s blog](https://lq782655835.github.io/blogs/)\n- [代码干燥计划](https://drylint.com/)\n- [码志](https://mazhuang.org/)\n- [阮一峰的个人网站](http://www.ruanyifeng.com/)\n- [编程导航](https://www.code-nav.cn/)\n- [被删的前端游乐场](http://www.godbasin.com/)\n- [张鑫旭](https://www.zhangxinxu.com/)\n- [廖雪峰的官方网站](https://www.liaoxuefeng.com/)\n- [miguoer](https://miguoer.github.io/blog/)\n- [web全栈体系](https://hejialianghe.gitee.io/)\n- [九旬的博客](https://www.zhangningle.top/articles/)\n- [vercel](https://ssh-blog.vercel.app/)\n- [cyc大神](http://www.cyc2018.xyz/)\n- [若川的博客](https://lxchuan12.gitee.io/)\n- [全栈潇晨](https://xiaochen1024.com/courseware/60b4f11ab1aa91002eb53b18)\n- [**书栈网-深入剖析Vuejs源码**](https://www.bookstack.cn/read/5865c0921b69e6006b3145a1/README.md)\n- [飞书文档](https://bytedance.feishu.cn/base/app8Ok6k9qafpMkgyRbfgxeEnet?table=tblLUxZFqOA2vI2F&view=vew0lbb2R4)\n- [阿里前端九部](https://www.yuque.com/fe9/basic/dwoufv)\n- [前端进化论](https://finget.github.io/)\n\n### 后台管理系统模板\n\n- [Vben Admin](https://vvbin.cn/doc-next/)\n\n### 组件库\n- [VARLET](https://varlet.gitee.io/varlet-ui/#/zh-CN/home)\n\n### 图标库\n- [Icônes](https://icones.netlify.app/)\n\n### 算法\n- [**algorithm-visualizer可视化算法**](https://algorithm-visualizer.org/)\n- [机器学习 K-means](https://zhuanlan.zhihu.com/p/78798251)\n- [thinkbucket](https://thinkbucket.cn/)\n- [javascript-algorithms](https://github.com/trekhleb/javascript-algorithms)\n- [全栈潇晨](https://xiaochen1024.com/)\n\n### eq\n- [认知偏差手册](https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf?continueFlag=c645eb56deb5defaca5e9b73e57333a8#RirzLG)\n\n### 项目\n- [年度明星项目](https://risingstars.js.org/2020/zh)\n\n### 网络安全\n- [破解](https://www.sohu.com/a/497592516_568398)\n\n### 规范\n- [semver规范](https://semver.org/lang/zh-CN/)\n- [ESModule](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/)\n\n### 测试\n- [vue-test-utils](https://v1.test-utils.vuejs.org/zh/)','2021-12-03 16:24:31','2022-10-27 03:49:12',0,'> 平时收集的资料',0,NULL,1),(32,'通过向日葵远程更新服务器文件的相关操作',1,'1. 远程登录医院电脑\n2. 要到医院地址 服务器ip 和密码\n3. 使用 `finallShell` 登录服务器\n4. cd到 `home/nginx90 `\n5. 打包本地`dist`\n7. 删除当前dist文件目录（注意）\n6. 使用上传命令`rz` 上传压缩文件\n7. [解压文件](https://www.jianshu.com/p/ca41f32420d6)命令','2021-12-13 11:00:39','2022-04-25 08:40:38',1,'>通过向日葵远程更新服务器文件的相关操作',0,NULL,0),(33,'键入网址再按下回车，背后的技术步骤？',1,'<img src=\"https://docs.hgyn23.cn/static/7d48a4d1f3d4bd2b93d700b31b1b6446\" width=\"600px\" height=\"auto\" alt=\"7d48a4d1f3d4bd2b93d700b31b1b6446\">\n## 系统层\n1. 发起http请求，解析域名\n2. DNS\n   1. Chrome搜索自身DNS缓存。chrome输入[chrome://net-internals/#dns](chrome://net-internals/#dns)可查看\n   2. 搜索操作系统自身DNS缓存\n   3. 读取本地HOST文件\n   4. 以上都查询不到时，浏览器发送一个DNS的系统调用，DNS请求到达宽带运营商服务器。\n   5. 宽带运营商服务器查询自身缓存\n   6. 没查询时，发起一个迭代（顶级域--次级域名--...）的DNS解析请求,直到获取到域名对应的IP地址。\n3. 拿到域名对应的IP并缓存\n   1. 宽带运营商服务器缓存DNS\n   2. 结果返回操作系统并缓存DNS\n   3. 结果返回浏览器并缓存DNS\n4. 获取到目标IP，发起Http“三次握手”，建立起TCP/IP连接\n   1. 客户端发送一个带有SYN标志的数据包给服务端\n   2. 服务端回传一个带有SYN/ACK标志的数据包\n   3. 客户端再回传一个带ACK标志的数据包给服务端\n<img src=\"http://159.75.104.17:9000/static/c58d3eb970fd7c478e6055076801581f\" width=\"600px\" height=\"auto\" alt=\"c58d3eb970fd7c478e6055076801581f\">\n\n5. 连接成功后，浏览器向服务器发起标准Http请求\n   1. 构建Http请求报文\n      - 起始行（start line）：描述请求或响应的基本信息；\n        - 请求行由三部分构成：请求方法：是一个动词，如 GET/POST，表示对资源的操作；\n        - 请求目标：通常是一个 URI，标记了请求方法要操作的资源；\n        - 版本号：表示报文使用的 HTTP 协议版本。  \n         这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。\n      - 头部字段集合（header）：使用 key-value 形式更详细地说明报文；\n        - 允许客户端向服务器传递请求的附加信息\n        - 常见请求报头：Content-Type, Cache-Control,CookieAccept-Encoding,Accept-Language,等\n      - 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。\n        - 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。\n<img src=\"https://docs.hgyn23.cn/static/d176da34d3253c7ae18279448707c004\" width=\"600px\" height=\"auto\" alt=\"d176da34d3253c7ae18279448707c004\">\n   2. 过TCP协议，发送到服务器指定端口（Http协议默认80端口、Https协议默认443）\n6. 服务器收到请求后，经过后端处理返回结果。（前后端分离）\n   - 响应报文\n     - 状态码\n       - 1xx：指示信息–表示请求已接收，继续处理。\n       - 2xx：成功–表示请求已被成功接收、理解、接受。\n       - 3xx：重定向–要完成请求必须进行更进一步的操作。\n       - 4xx：客户端错误–请求有语法错误或请求无法实现。\n       - 5xx：服务器端错误–服务器未能实现合法的请求。\n     - 响应报头\n     - 响应报文\n7. 返回Html页面等资源，html包含css/js等资源，重复以上http请求\n## 渲染层\n1. Chrome浏览器的渲染引擎 Blink（常说的浏览器内核）边接收边解析 HTML 内容，浏览器自上而下逐行解析 HTML 内容，经过词法分析、语法分析，构建 DOM 树。HTML文档被加载和解析完成时（DOM树构建完成），触发DOMContentLoaded事件，此时页面可以渲染展示出内容了。（html引用的图片可能还在http请求加载，当所有资源全部请求完成，触发load事件）\n   1. 当遇到外部 CSS 链接时，不阻塞而继续构建 DOM 树。\n   2. 当遇到外部 JS 链接时，异步获取资源。JS下载后，V8引擎（常说的JavaScript引擎）会解析、编译JS内容。由于 JS 可能会修改 DOM 树和 CSSOM 树而造成回流和重绘，故JS会阻塞DOM树的构建。\n2. 下载CSS后，主线程会在合适时机解析CSS内容，构建 CSSOM 树。本来构建DOM树和CSSOM树是并行的，互不影响，但当解析到上文提到的JavaScript时，需要构建完成CSSOM树后，才能执行js代码（DOM树此时被挂起），因为js可以查询/修改任意对象的样式，此时需要CSSOM树构建完成。 \n3. 浏览器结合 DOM 树和 CSSOM 树构建 Render 树。Render树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。\n4. 浏览器渲染（布局 + 绘制 + 复合图层化），布局（Layout）环节主要负责各元素尺寸、位置的计算，绘制（Paint）环节则是绘制页面像素信息，合成（Composite）环节是多个复合层的合成，最终合成的页面被用户看到。\n   1. 回流：DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等\n   2. 重绘：当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容\n<img src=\"https://docs.hgyn23.cn/static/6d2975e8355b1a3fa81fb8f9f65456b1\" width=\"600px\" height=\"auto\" alt=\"6d2975e8355b1a3fa81fb8f9f65456b1\">\n## 浏览器渲染流程总体解析\n<img src=\"https://docs.hgyn23.cn/static/43bd55d4c7a920da184a2c811028ae19\" width=\"600px\" height=\"auto\" alt=\"43bd55d4c7a920da184a2c811028ae19\">  \n\n结合上图，一个完整的渲染流程大致可总结为如下：\n1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。\n2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。\n3. 创建布局树，并计算元素的布局信息。\n4. 对布局树进行分层，并生成分层树。\n5. 为每个图层生成绘制列表，并将其提交到合成线程。\n6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。\n7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。\n8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。\n\n阻塞机制：\n1. html内容从上到下解析，浏览器遇到body标签开始显示内容。CSS 不会阻塞 DOM 的解析，JS 会阻止DOM的解析。\n2. 当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。\n3. 现代浏览器都使用了预加载器，在js挂起DOM解析时，会继续解析后面的html，寻找需要下载的资源。预加载器下载这些资源，以减少JS阻塞带来的影响。\n\n## chrome架构图\n<img src=\"https://docs.hgyn23.cn/static/e0c6f66f79f53e670dd21517563d4f81\" width=\"600px\" height=\"auto\" alt=\"e0c6f66f79f53e670dd21517563d4f81\">\n\n## 优化方案\n- 减少http请求数，如：雪碧图、合并CSS/JS文件、缓存资源等（针对http1.1）\n- 减少http请求资源体积，如：启用gzip压缩、图片压缩、减少cookie、按需加载等\n- css放在head中。由于同时具有 DOM 和 CSSOM 才能构建渲染树，所以HTML 和 CSS 都是阻塞渲染的资源，所以尽量精简CSS也是优化方式之一。\n- js放在body底部，减少白屏时间。因为js会阻止浏览器解析。\n- 减少回流和重绘制，比如不要一条一条修改DOM样式、使用documentFragment操作DOM等。','2021-12-18 11:41:21','2022-09-10 17:11:29',1,'> 一道经典的面试题，涵盖的知识点非常多，这里探寻下该问题，以对自己的知识体系进行梳理。',0,NULL,0),(34,'JS垃圾回收标记清除技术',1,'js是具有垃圾回收机制的一门语言，下面介绍js的标记清除法\n\n**核心思想：给当前不使用的值加上标记，然后再回收其内存。**\n\n### 可达性\n  JavaScript 中内存管理的主要概念是可达性。\n  简单地说，“可达性” 值就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。\n1. 有一组基本的固有可达值，由于显而易见的原因无法删除。例如:\n  - 本地函数的局部变量和参数\n  - 当前嵌套调用链上的其他函数的变量和参数\n  - 全局变量\n  - 还有一些其他的，内部的 \n这些值称为根\n2. 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。\n   基本的垃圾回收算法称为“**标记-清除**”，定期执行以下“垃圾回收”步骤:\n   - 垃圾回收器获取根并“**标记**”(记住)它们。\n   - 然后它访问并“标记”所有来自它们的引用。\n   - 然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，以便以后不再访问同一个对象两次。\n   - 以此类推，直到有未访问的引用(可以从根访问)为止。\n   - 除标记的对象外，所有对象都被删除。\n  例如，对象结构如下\n<img src=\"https://docs.hgyn23.cn/static/d89c2f28755041e51b766f6f1dcf7b8b\" width=\"600px\" height=\"auto\" alt=\"d89c2f28755041e51b766f6f1dcf7b8b\">\n\n\n  我们可以清楚地看到右边有一个“不可到达的块”。现在让我们看看“标记并清除”垃圾回收器如何处理它。\n\n  **第一步标记根**\n<img src=\"https://docs.hgyn23.cn/static/457fdba5c918cbb8e9029082c54b7c02\" width=\"600px\" height=\"auto\" alt=\"457fdba5c918cbb8e9029082c54b7c02\">\n  **然后标记（也可以说是清除标记）他们的引用**\n<img src=\"https://docs.hgyn23.cn/static/99c53fff27f852d278ceddc2765ee55c\" width=\"600px\" height=\"auto\" alt=\"99c53fff27f852d278ceddc2765ee55c\">\n  **以及子孙代的引用:**\n<img src=\"https://docs.hgyn23.cn/static/308ef8447c2cd9deedb7a418e5c5006e\" width=\"600px\" height=\"auto\" alt=\"308ef8447c2cd9deedb7a418e5c5006e\">\n  **现在进程中不能访问的对象（也就是说是未被清除的对象）被认为是不可访问的，将被删除:**\n<img src=\"https://docs.hgyn23.cn/static/34d0c24521d83697475b9a0fd2856a63\" width=\"600px\" height=\"auto\" alt=\"34d0c24521d83697475b9a0fd2856a63\">\n**介绍之前，我们先记住，垃圾回收系统会按照周期性进行**\n#### 正常执行\n\n```javascript\nvar a = 1 \n\nfunction bFunc() {\n  b = 2;\n  c = {\n    aaa: 3,\n  } \n}\nfunction cFunc() { \n  d = 2; \n  e = {\n    bbb: 3, \n  } \n  console.log(e)\n}\nbFunc() \ncFunc()\n```\n假设执行到  `console.log(e)`时，垃圾收集器开始执行  \n此时内存占用情况是什么样的呢？看下图\n\n|  a   | b  |  c   | d  |  e   |\n|  ----  | ----  |  ----  | ----  |  ----  |\n| 1  | 2 | 0X1F  | 2 | 0XFF  |\n\n1. 标记内存中所有变量\n\n|  a   | b  |  c   | d  |  e   |\n|  ----  | ----  |  ----  | ----  |  ----  |\n| `1`  | `2` | `0X1F`  | `2` | `0XFF`  |\n\n2. 去掉当前执行环境中的变量标记\n   \n|  a   | b  |  c   | d  |  e   |\n|  ----  | ----  |  ----  | ----  |  ----  |\n| 1  | `2` | `0X1F`  | 2 | 0XFF  |\n\n3. 此时 b c 变量还保留有标记，说明此时b c变量在环境中已经访问不到了，所以需要被清除来释放内存。\n4. 最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。\n\n|  a   | b  |  c   | d  |  e   |\n|  ----  | ----  |  ----  | ----  |  ----  |\n| 1  |  |    | 2 | 0XFF  |\n\n#### 闭包的情况下\n```javascript\nvar a = 1 \n\nfunction bFunc() {\n  b = 2;\n  c = {\n    aaa: 3,\n  }\n  return function(){console.log(b)} \n}\nfunction cFunc() { \n  d = 2; \n  e = {\n    bbb: 3, \n  } \n  console.log(e)\n}\nvar cls = bFunc() \ncls()\ncFunc()\n```\n假设执行到  `console.log(e)`时，垃圾收集器开始执行  \n此时内存占用情况是什么样的呢？看下图\n\n|  a   | b  |  c   | d  |  e   |  cls   |\n|  ----  | ----  |  ----  | ----  |  ----  |  ----  |\n| 1  | 2 | 0x1f  | 2 | 0xff  | 0Xa0  |\n\n1. 标记内存中所有变量\n\n|  a   | b  |  c   | d  |  e   |  cls   |\n|  ----  | ----  |  ----  | ----  |  ----  |  ----  |\n| `1`  | `2` | `0x1f`  | `2` | `0xff`  |`0Xa0`  |\n\n2. 去掉当前执行环境中的变量标记\n   \n|  a   | b  |  c   | d  |  e   |  cls   |\n|  ----  | ----  |  ----  | ----  |  ----  |  ----  |\n| 1  | 2 | 0x1f  | 2 | 0xff  |  0Xa0  |\n\n3. 此时 变量cls 仍然维持着对 bFunc 上下文的引用（闭包），所以作用域内依然可以访问 b c 变量，所以b c 变量无法被清除。\n4. 最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。\n\n|  a   | b  |  c   | d  |  e   |  cls   |\n|  ----  | ----  |  ----  | ----  |  ----  |  ----  |\n| `1`  | `2` | `0x1f`  | `2` | `0xff`  |`0Xa0`  |\n\n以此得出结论，闭包在一定程度下会影响垃圾回收的效率，所以要慎用。','2021-12-24 11:43:59','2022-08-02 03:13:56',1,'js是具有垃圾回收机制的一门语言，下面介绍js的标记清除法\n\n**核心思想：给当前不使用的值加上标记，然后再回收其内存。**',0,NULL,0),(35,'Vuejs使用watch侦听器侦听数据时遇到的一系列问题',1,'## 执行顺序的问题\n### 侦听子组件中获取的数据\n在data中初始化一个变量，并在watch中侦听，在methods中发起异步请求前将数据赋值给这个变量时，watch中触发的回调函数和methods中等待异步执行完毕前还未执行的代码谁会先执行？  \n`等待methods异步执行完毕，继续执行还未执行的代码，然后执行监听器中的回调函数。`\n### 父组件获取数据，传递给子组件\n父组件中的data初始化一个变量，通过异步请求获取数据赋给该变量并传递给子组件，子组件中使用watch进行侦听，代码谁先执行？  \n`继续执行父组件还未执行的代码，执行完后按顺序被子组件中的watch侦听到并执行回调函数。`\n### watch如何监听到数据的变化?\n**只要是对象和数组，无论是否是空值**，第一次都可以侦听到数据变化，这个数据是按代码最后赋的值来决定传入watch的newValue,**(除了null,undefine,和空字符串在变量本身就为这些值时无法监听到)**,我认为，watch如果侦听的是复杂数据类型，如对象，数组，那么它侦听的是变量内存地址的变化来决定是否执行回调。`null不是有效的对象实例，因此没有为它分配内存。它只是一个值，指示对象引用当前不引用对象。`，估计undefine,和空字符串也是如此。\n### 父组件给子组件传递数据，子组件使用watch侦听props数据，在watch的回调函数中将自身变量赋值为传递过来的数组，会导致无限循环？\n```javascript\nwatch: {\n      provinceList: {\n        deep: true,\n        handler(val) {\n          this.dataList = val //浅复制了数组\n          this.init()\n          this.option && this.chart.setOption(this.option);\n        }\n      }\n    },\n```\n因为子组件的watch回调函数中直接使用了普通的`=`号，因为数组跟对象一样也是引用类型，所以此时的操作只是将指向数组的地址赋值给了`dataList`，所以后续对dataList的数组操作仍然会被监听到，导致无限循环。  \n以上均为个人见解，如有不正确的地方，欢迎指正！','2021-12-24 17:48:49','2022-04-25 08:40:39',1,'> 在data中初始化一个变量，并在watch中侦听，在methods中发起异步请求前将数据赋值给这个变量时，watch中触发的回调函数和methods中等待异步执行完毕前还未执行的代码谁会先执行？  ',0,NULL,0),(36,'http完全解析1-认识http',1,'## 山雨欲来\n1989年，任职于欧洲核子研究中心(CERN)的蒂姆·伯纳斯-李(Tim Berners-Lee)发表了一篇论文，提出了在互联网上构建超链接文档的构想。这篇论文他确立了三项关键技术。  \n1. URI：即统一资源标识符，作为互联网上的唯一身份；\n2. HTML：即超文本标记语言，描述超文本文档；\n3. HTTP：即超文本传输协议，用来传输超文本；\n\n给予他们，就可以把超文本系统完美的运行在互联网上，蒂姆把这个系统成为“万维网”（World Wide Web），也就是我们熟知的Web。  \n所以这一年，“HTTP”诞生了。  \n## HTTP/0.9\n由于20世纪90年代初期的互联网非常简陋，计算机处理能力低，存储容量小，网速很慢，所以网络上绝大多数资源都是纯文本，很多的通信协议都是使用的纯文本，所以HTTP的设计也不可避免受到了时代的限制。  \n这一时期的HTTP被定义为0.9版，结构比较简单，为了便于服务器和客户端处理，它也采用了纯文本格式。蒂姆·伯纳斯-李最初设想的系统文档都是只读的，所以只允许使用“GET”动作从服务器获取文档，并在响应请求后立即关闭连接，功能非常有限（简单）。  \n但这也是他的优点，因为  \n`“把简单的东西变复杂”，要比“把复杂的东西变简单”容易的多。`\n## HTTP/1.0\n顺应时代的发展HTTP/1.0版本在1996年正式发布，形式上已经和如今使用的HTTP差别不大了，例如：  \n1. 增加了HEAD、POST等新方法\n2. 增加了响应状态码，标记可能的错误原因\n3. 引入协议版本号等概念\n4. 引入了HTTP Header（头部）的概念\n5. 传输的数据不在仅限于文本。\n\n当时的HTTP/1.0并不是一个标准，而是一份参考，并没有实际的约束力。所以当时也没激起什么波澜。\n\n## HTTP/1.1\n\n1995年的浏览器大战：网景的Netscape Navigator和微软的 Internet Explorer 都希望在互联网上占据主导地位。胜负且不说，不可否认的是，它再一次极大的推动了Web的发展，HTTP/1.0也在这个过程中经受了实践考验，于是，在1999年。HTTP/1.1发布了RFC文档，编号2616，正式确立了延续十余年的传奇。\n\n版本号我们可以看到，HTTP/1.1是对HTTP/1.0的小服务修正。并且它是一个`正式的标准`，所以今后互联网上的任何浏览器、服务器、网关、代理等，只要用到HTTP协议，就必须严格遵守这个标准。相当于是互联网世界的`立法`。\n\n比起0.9/1.0少了“学术气”，更加“接地气”，同时表述也更加严谨。HTTP/1.1的主要变更点有：\n1. 增加了PUT、DELETE等新方法；\n2. 增加缓存控制；\n3. 明确了链接管理，允许持久连接；\n4. 允许响应数据分块（chunked），有利于传输大文件；\n5. 强制要求Host头，让互联网主机托管成为可能。\n\n## HTTP/2\n过去十余年来，HTTP/1.1标准一直巍然不动，但其间也出现一切对HTTP不满的意见，主要是连接慢，无法更上迅猛发展的互联网。\n\n终于有一天，Google忍不住了，决定揭竿而起，就像马云说的“如果银行不改变，我们就改变银行”\n\nGoogle首先开发了自己的浏览器Chrome，然后推出SPDY协议，并在Chrome里应用于自家的服务器，以实际的用户方来倒逼HTTP协议的变革。\n\n目前Chrome的全球占有率超过了60%，“挟用户以号令天下”，Google借此顺势把SPDY推上了标准的宝座，互联网标准化组织以SPDY为基础，开始指定新版本HTTP协议，最终在2015年发布了HTTP/2，RFC编号7540，其在高度兼容HTTP/1.1的同时在性能改善方面做了很大的努力，主要的特点有：\n\n1. 二进制协议，不再是纯文本\n2. 可发起多次请求，废弃了1.1的管道\n3. 使用专用算法压缩头部，减少数据传输量\n4. 允许服务器主动向客户端推送数据\n5. 增强了安全性，“事实上”要求加密通信\n\n## HTTP是什么\n超文本传输协议，顾名思义，他有三层意思，分别是：“超文本” “传输”和 “协议”\n\n1. “协议”的特点\n   - 协议必须要有两个或多个参与者，也就是“协”。\n   - 协议是对参与者的一种行为约定和规范，也就是“议”。\n    > HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。\n2. HTTP 是一个“传输协议”，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A<===>B”,所以：\n   - HTTP 协议是一个“双向协议”。\n   - 数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。\n    > HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。\n3. “超文本”\n    - 所谓“文本”（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。\n    - 所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。\n> HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范\n\n## HTTP不是什么\n\n- HTTP 不是编程语言\n- HTTP 不是 HTML\n- HTTP 不是一个孤立的协议\n\n>把这些综合起来，使用递归缩写方式（模仿 PHP），我们可以把 HTTP 定义为`“与 HTTP 协议相关的所有应用层技术的总和”`\n\n<img src=\"https://docs.hgyn23.cn/static/6eb0731793fda95866176b4a03886ef3\" width=\"600px\" height=\"auto\" alt=\"6eb0731793fda95866176b4a03886ef3\">','2021-12-27 08:45:02','2022-08-02 03:14:39',1,'\n超文本传输协议，顾名思义，他有三层意思，分别是：“超文本” “传输”和 “协议”',0,NULL,0),(37,'面试指南',1,'- [互联网大厂面试每日一题](https://q.shanyue.tech/)\n- [JavaScript 面试知识点总结](https://github.com/CavsZhouyou/Front-End-Interview-Notebook)\n- [前端面试指南](https://interview2.poetries.top/)\n- [面试鸭](https://www.mianshiya.com/)\n- [前端面试每日 3+1](http://www.h-camel.com/index.html)','2021-12-27 09:16:35','2022-08-31 02:09:15',0,'> 帮助建立知识网络 准备好面试',0,NULL,1),(38,'文章图片预览功能的实现',1,'### 前言\n目前对博客项目的文章页进行优化，想给页面新增一个图片预览的功能，我首先想到的办法是通过接口获取HTML字符，在解析成html时添加事件监听来实现。但是因为Vue不是基于字符串实现的模板编译，所以无法通过v-html指令渲染组件和解析Vue的语法。后来在网上找到个使用特殊组件（v-viewer）添加到父级元素的解决方案，该方案在普通spa应用下可以解析，放在ssr项目里就解析不了了，经过多次尝试，暂时找不到合适的解决方法，故放弃。\n\n后续发现在父级元素中监听内部的点击事件，通过事件冒泡机制，就能获取到点击的元素target，通过判断tag类型，可以获取到img元素对应的src，参照el-image图片预览组件的实现方式实现了建议的预览功能。\nTips：实现预览图片时阻止body滚动\n```javascript\nprevOverflow = document.body.style.overflow;\ndocument.body.style.overflow = \'hidden\';\n```\n示例：  \n<img src=\"https://docs.hgyn23.cn/static/d26bc5b2221a603c6fadd6539a06fb5f\" width=\"600px\" height=\"auto\" alt=\"d26bc5b2221a603c6fadd6539a06fb5f\">','2021-12-27 18:05:24','2022-08-02 03:14:08',1,'> 前对博客项目的文章页进行优化，想给页面新增一个图片预览的功能，我首先想到的办法是通过接口获取HTML字符，在解析成html时添加事件监听来实现。',0,NULL,0),(39,'babel编译器执行原理',1,'# 设计引导\n1. 模板设计中可以控制各个元素的宽高、位移、字体大小、颜色等各类常用属性，保存后会同步设置到设备，设备在下一次自动刷新数据时会重载最新的配置； \n2. 元素的ID/类名命名以英文拼接为主，如医院logo(hosLogo)、患者性别(patientSex)在设备端将作为定位标识，根据规则自动渲染实际接口获取的参数值进行替换，按下表进行配置即可；\n\n#元素命名规则\nlogo元素:**#hosLogo**且为img标签\n科室/等候区/就诊名称:**#sujectTitle**\n检查室名称:**#checkTitle**\n正在就诊/检查/取药队列父元素盒子:**#callBox**\n等待就诊/检查/取药队列父元素盒子:**#waitBox**\n科室介绍:**#deptIntro**\n诊室介绍:**#roomIntro**\n护理级别:**#careLevel**\n护理级别底色:**#careLevelBack**\n护理标签:**#careLabel**\n床号:**#bedNum**\n房号:**#roomNum**\n医院logo:**#hosLogo**\n诊断结果:**#diagnosis**\n患者姓名:**#patientName**\n患者性别:**#patientSex**\n患者年龄:**#patientAge**\n入院时间:**#hosTime**\n入院日期:**#hosDate**\n责任医生:**#docName/areaDirectorName**\n责任护士:**#nurseName/areaHeadNurseName**\n病区主任:**#areaDirectorName**\n护士长:**#areaHeadNurseName**\n住院编号:**#hosNum**\n二维码:**#qrcode**\n日期:**#date**\n时间:**#time**\n星期:**#week**\n血型:**#bloodType**\n医生职称:**#docJob**\n诊室屏滑动职工列表:**#workerList**\n诊室屏医生姓名:**#docName**\n诊室屏医生头像:**#docImg**\n诊室屏医生介绍:**#docIntro**\n妇产科患者孩子名称:**#childName**\n妇产科患者孩子性别:**#childSex**\n体检编号:**#physicalExamNum**\n出生日期:**#birthday**\n陪护家属:**#patientFamilyName**\n护士长:**#areaHeadNurseName**','2021-12-29 11:10:29','2022-04-25 08:40:40',0,'> ',0,NULL,0),(40,'nginx配置问题集合',1,'#### 1. nginx反向代理404问题？\n在nginx中配置proxy_pass反向代理时，当在后面的url加上了/，相当于是绝对根路径，则nginx不会把location中匹配的路径部分给代理走;如果没有/，则会把匹配的路径部分也给代理走。 如： \n\n### 访问路径:\n```\n/pss/bill.html\n```\n1. 当nginx配置文件proxy_pass后边的url带\"/\"时:\n```\nlocation /pss/ {\n    proxy_pass http://127.0.0.1:18081/;\n} \n```\n代理到后端的路径为：`http://127.0.0.1:18081/bill.html`，省略了匹配到的/pss/路径；\n\n2. 当nginx配置文件proxy_pass后边的url不带\"/\"时：\n```\nlocation /pss/ {\n    proxy_pass http://127.0.0.1:18081;\n}\n```\n代理到后端的路径为：`http://127.0.0.1:18081/pss/bill.html`，连同匹配到的/pss/路径，一起进行反向代理；','2022-03-01 18:55:25','2022-04-25 08:40:40',1,'> 总结遇到的问题 和 解决方法',0,NULL,0),(41,'JavaScript 设计模式核心原理与应用实践',1,'\n## SOLID设计原则\n> \"SOLID\" 是由罗伯特·C·马丁在 21 世纪早期引入的记忆术首字母缩略字，指代了面向对象编程和面向对象设计的五个基本原则。\n\n设计原则是设计模式的指导理论，它可以帮助我们规避不良的软件设计。SOLID 指代的五个基本原则分别是：\n- 单一功能原则（Single Responsibility Principle）\n  > 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中，即又定义有且仅有一个原因使类变更。（甲类负责两个不同的职责：职责A，职责B。当由于职责A需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责B功能发生故障。也就是说职责A和B被耦合在了一起”）。\n- 开放封闭原则（Opened Closed Principle）:\n  > 对拓展开放，对修改封闭。说得更准确点，软件实体（类、模块、函数）可以扩展，但是不可修改。\n- 里式替换原则（Liskov Substitution Principle）\n  > 一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。\n  经典的例子: 正方形不是长方形的子类。原因是正方形多了一个属性“长 == 宽”。这时，对正  方形类设置不同的长和宽，计算面积的结果是最后设置那项的平方，而不是长*宽，从而发生了 与长方形不一致的行为。如果程序依赖了长方形的面积计算方式，并使用正方形替换了长方形， 实际表现与预期不符。\n- 接口隔离原则（Interface Segregation Principle）\n  > 接口隔离原则表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中的方法分组，然后用多个接口替代它，每个接口服务于一个子模块。简单地说，就是使用多个专门的接口比使用单个接口要好很多。\n- 依赖反转原则（Dependency Inversion Principle）\n  > 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象（接口）编程，而不是针对实现细节编程。\n## 设计模式的核心思想——封装变化\n在实际开发中，不发生变化的代码可以说是不存在的。我们能做的只有将这个变化造成的影响最小化 —— 将变与不变分离，确保变化的部分灵活、不变的部分稳定。\n\n这个过程，就叫“封装变化”；封装的正是软件中那些不稳定的要素，它是一种防患于未然的行为 —— 提前抽离了变化，就为后续的拓展提供了无限的可能性，如此，我们才能做到在变化到来的时候从容不迫。\n## 创建型\n> 创建型模式封装了创建对象过程中的变化\n### 工厂模式\n**工厂模式其实就是将创建对象的过程单独封装。**\n\n\n### 抽象工厂模式\n抽象工厂本质上处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对共性作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：\n- **抽象工厂（抽象类，它不能被用于生成具体实例）**： 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个，每一个抽象工厂对应的这一类的产品，被称为“产品族”。\n- **具体工厂（用于生成产品族里的一个具体的产品）**： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。\n- **抽象产品（抽象类，它不能被用于生成具体实例）**： 具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。\n- **具体产品（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）**： 比如具体的一种操作系统、或具体的一种硬件等。\n### 单例模式\n\n#### 单例模式的实现思路 \n一般情况下，当我们创建了一个类（本质是构造函数）后，可以通过new关键字调用构造函数进而生成任意多的实例对象。  \n```javascript\nclass SingleMode {\n	alert() {console.log(\"我是一个单例对象\")}\n}\nconst s1 = new SingleMode()\nconst s2 = new SingleMode()\ns1 === s2 //false\n```\n我们先 new 了一个 s1，又 new 了一个 s2，很明显 s1 和 s2 之间没有任何瓜葛，两者是相互独立的对象，各占一块内存空间。而单例模式想要做的就是**不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。**  \n要做到这一点，就需要构造函数**具备判断自己是否已经创建过一个实例**的能力。\n```javascript\nclass SingleMode {\n	alert() {console.log(\"我是一个单例对象\")}\n	static getInstance() {\n		if(!SingleMode.instance) {\n    //如果不存在实例 ，那么先创建它\n			SingleMode.instance = new SingleMode()\n		}\n    //如果已经存在，直接返回\n		return SingleMode.instance\n	}\n}\nconst s1 = new SingleMode()\nconst s2 = new SingleMode()\ns1 === s2 //false\n```\n通过闭包实现单例模式：\n```javascript\nSingleMode.getInstance = (function() {\n    // 定义自由变量instance，模拟私有变量\n    let instance = null\n    return function() {\n        // 判断自由变量是否为null\n        if(!instance) {\n            // 如果为null则new出唯一实例\n            instance = new SingleMode()\n        }\n        return instance\n    }\n})()\n```\n可以看出，在getInstance方法的判断和拦截下，我们不管调用多少次，SingleMode都只会给我们返回一个实例，s1和s2现在都指向这个唯一的实例。\n### 原型模式\n原型模式不仅是一种设计模式，它还是一种**编程范式（programming paradigm）**，是 JavaScript 面向对象系统实现的根基。  \n在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过克隆原型的方式来创建出一个与原型一样（共享一套数据/方法）的对象。在 JavaScript 里，`Object.create`方法就是原型模式的天然实现——准确地说，只要我们还在借助`Prototype`来实现对象的创建和原型的继承，那么我们就是在应用原型模式。\n#### JavaScript 中的“类”\n> ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法不会为 JavaScript 引入新的面向对象的继承模型。 ——MDN\n当我们尝试用 class 去定义一个 Student 类时：\n```javascript\nclass Student {\n  constructor(name,age,phone) {\n    this.name = name\n    this.age = age\n    this.phoneNum = phone\n  }\n  call() {\n    console.log(`${name}的电话是${this.phoneNum}`)\n  }\n}\n```\n其实完全等价于写了这么一个构造函数:\n```javascript\nfunction Student(name,age,phone) {\n  this.name = name\n  this.age = age\n  this.phoneNum = phone\n}\nStudent.prototype.call = function() {\n    console.log(`小明的电话是${this.phoneNum}`)\n}\n```\n原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础。在 JavaScript 中，原型编程范式的体现就是基于原型链的继承。  \n\n所以说 JavaScript 这门语言的根本就是原型模式。在 Java 等强类型语言中，原型模式的出现是为了实现类型之间的解耦。而 JavaScript 本身类型就比较模糊，不存在类型耦合的问题，所以说咱们平时根本不会刻意地去使用原型模式。因此我们此处不必强行把原型模式当作一种设计模式去理解，把它作为一种编程范式来讨论会更合适。\n`Tips：原型链神图`\n<img src=\"https://docs.hgyn23.cn/static/47518d2cb0d40b35e550ba00c6c3b392\" width=\"600px\" height=\"auto\" alt=\"47518d2cb0d40b35e550ba00c6c3b392\">\n## 结构型\n> 结构型模式封装的是对象之间组合方式的变化，目的在于灵活地表达对象间的配合与依赖关系\n### 装饰器模式\n它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”\n### 适配器模式\n适配器模式通过把一个类的接口变换成客户端所期待的另一种接口，可以帮我们解决不兼容的问题。  \n好的适配器的自我修养——把变化留给自己，把统一留给用户。在此处，所有关于 http 模块、关于 xhr 的实现细节，全部被 Adapter 封装进了自己复杂的底层逻辑里，暴露给用户的都是十分简单的统一的东西——统一的接口，统一的入参，统一的出参，统一的规则。\n### 代理模式\n代理模式，式如其名——在某些情况下，出于种种考虑/限制，一个对象不能直接访问另一个对象，需要一个第三者（代理）牵线搭桥从而间接达到访问目的，这样的模式就是代理模式。\n## 行为型\n> 行为型模式则将是对象千变万化的行为进行抽离，确保我们能够更安全、更方便地对行为进行更改\n### 观察者模式\n**观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。 —— Graphic Design Patterns**  \n观察者模式，是所有 JavaScript 设计模式中**使用频率最高**，**面试频率也最高**的设计模式，所以说它十分重要.  \n观察者模式有一个“别名”，叫发布 - 订阅模式（之所以别名加了引号，是因为两者之间存在着细微的差异，下个小节里我们会讲到这点）。这个别名非常形象地诠释了观察者模式里两个核心的角色要素——“发布者”与“订阅者”。 [后续文章]()将实现简单的发布订阅模式，并探寻vue的双向绑定的实现原理。 \n\n### 策略模式\n策略模式的定义：\n**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。**  \n“封装”就是把某一功能点对应的逻辑给提出来；“可替换”建立在封装的基础上，只是说这个“替换”的判断过程，**咱们不能直接怼 if-else，而要考虑更优的映射方案**。\n### 状态模式\n状态模式的定义：  \n**状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。**\n解决的问题:  \n**状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。**\n### 迭代器模式\n**迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。 ——《设计模式：可复用面向对象软件的基础》**  \n迭代器模式是设计模式中少有的目的性极强的模式。所谓“目的性极强”就是说它不操心别的，它就解决这一个问题——遍历。\n#### ES6对迭代器的实现\n在“公元前”，JS原生的集合类型数据结构，只有Array（数组）和Object（对象）；而ES6中，又新增了Map和Set。四种数据结构各自有着自己特别的内部实现，但我们仍期待以同样的一套规则去遍历它们，所以ES6在推出新数据结构的同时也推出了一套统一的接口机制——迭代器（Iterator）。  \n```javascript\n// 编写一个迭代器生成函数\nfunction *iteratorGenerator() {\n    yield \'1号选手\'\n    yield \'2号选手\'\n    yield \'3号选手\'\n}\n\nconst iterator = iteratorGenerator()\n\niterator.next() //{value:\'1号选手\',done: false}\niterator.next()	//{value:\'2号选手\',done: false}\niterator.next()	//{value:\'3号选手\',done: false}\n```\n#### 用ES5去写一个能够生成迭代器对象的迭代器生成函数\n```javascript\n// 定义生成器函数，入参是任意集合\nfunction iteratorGenerator(list) {\n    // idx记录当前访问的索引\n    var idx = 0\n    // len记录传入集合的长度\n    var len = list.length\n    return {\n        // 自定义next方法\n        next: function() {\n            // 如果索引还没有超出集合长度，done为false\n            var done = idx >= len\n            // 如果done为false，则可以继续取值\n            var value = !done ? list[idx++] : undefined\n            \n            // 将当前值与遍历是否完毕（done）返回\n            return {\n                done: done,\n                value: value\n            }\n        }\n    }\n}\n\nvar iterator = iteratorGenerator([\'1号选手\', \'2号选手\', \'3号选手\'])\niterator.next()\niterator.next()\niterator.next()\n```\n参考： 掘金小册[《JavaScript 设计模式核心原理与应⽤实践》](https://juejin.cn/book/6844733790204461070)\n','2022-03-02 12:39:46','2022-08-02 03:10:42',1,'>能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西\n所谓“不变的东西”，说的就是这种驾驭技术的能力。\n\n具体来说，它分为以下三个层次：\n\n- 能用健壮的代码去解决具体的问题；\n- 能用抽象的思维去应对复杂的系统；\n- 能用工程化的思想去规划更大规模的业务。',0,NULL,0),(42,'v8执行过程详解',1,'[详细解析](https://segmentfault.com/a/1190000039380905)\n<img src=\"https://docs.hgyn23.cn/static/14a2fb0d4de652c36446cee66e01b4a1\" width=\"600px\" height=\"auto\" alt=\"14a2fb0d4de652c36446cee66e01b4a1\">','2022-04-04 18:11:00','2022-08-02 03:13:18',1,'>v8引擎执行过程',0,NULL,0),(43,'call\\apply\\bind实现原理解析',1,'## 前言\n> 此文章中Api为`javascript`模拟，原由`c++`编写\n\n### call实现\n```javascript\nFunction.prototype.v2call = function (thisArg, ...args) {\n  //目的：将传入的thisArg对象作为调用v2call的函数的this指向\n\n  //使用fn变量存储this 此时fn指向调用v2call的函数对象 这里是foo\n  var fn = this;\n  //边界判断 如果不为空 将原始字面量转化为实例对象 否则thisArg指向window\n  thisArg = thisArg ? Object(thisArg) : window;\n  //thisArg新增fn属性引用函数对象fn\n  thisArg.fn = fn;\n  args = !isNone(args) ? args : [];\n  //隐式绑定： 函数在不同上下文调用时会影响this的指向\n  //此时在thisArg上下文中调用时fn的this会绑定thisArg\n  var res = thisArg.fn(...args);\n  //做完删除fn\n  delete thisArg.fn;\n  //返回函数调用的返回值\n  return res;\n};\nfunction isNone(v) {\n  return v === undefined || v === null\n}\nvar a = \'这是全局的a\';\nfunction foo() {\n  console.log(\'this指向：\', this);\n  var sum = Array.prototype.reduce.call(\n    arguments,\n    (pre, cur) => {\n      return pre + cur;\n    },\n    0\n  );\n  console.log(\'value:\', sum);\n  return sum;\n}\nvar obj = {\n  a: \'这是obj对象里的a\',\n};\nconsole.log(foo.v2call(obj, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n\n```\n输出结果：  \n<img src=\"https://docs.hgyn23.cn/static/77b30a406e58d0308b71d80082b59889\" width=\"600px\" height=\"auto\" alt=\"77b30a406e58d0308b71d80082b59889\">\n### apply实现\n```javascript\nFunction.prototype.v2apply = function (thisArg, args) {\n  //目的：将传入的thisArg对象作为调用v2call的函数的this指向\n\n  //使用fn变量存储this 此时fn指向调用v2call的函数对象 这里是foo\n  var fn = this;\n  //边界判断 如果不为空 将原始字面量转化为实例对象 否则thisArg指向window\n  thisArg = thisArg ? Object(thisArg) : window;\n  //关键： 利用隐式绑定： 函数的调用方式会影响this的指向\n  //thisArg新增fn属性引用函数对象fn\n  thisArg.fn = fn;\n  //此时在thisArg上下文中调用时fn的this会绑定thisArg\n  args = !isNone(args) ? args : [];\n  var res = thisArg.fn(...args);\n  //做完删除fn\n  delete thisArg.fn;\n  //返回函数调用的返回值\n  return res;\n};\nfunction isNone(v) {\n  return v === undefined || v === null\n}\nvar a = \'这是全局的a\';\nfunction foo() {\n  console.log(\'this指向：\', this);\n  var sum = Array.prototype.reduce.call(\n    arguments,\n    (pre, cur) => {\n      return pre + cur;\n    },\n    0\n  );\n  console.log(\'value:\', sum);\n  return sum;\n}\nvar obj = {\n  a: \'这是obj对象里的a\',\n};\nconsole.log(foo.v2apply(obj, [1, 2, 3, 4,5]));\n\n```\n输出结果：  \n<img src=\"https://docs.hgyn23.cn/static/d03c30e655d8b1c70bf2ae93c27ca630\" width=\"600px\" height=\"auto\" alt=\"d03c30e655d8b1c70bf2ae93c27ca630\">\n### bind 实现\n```javascript\nFunction.prototype.v2bind = function (thisArg, ...argsArr) {\n  //目的：将传入的thisArg对象作为调用v2call的函数的this指向,并返回这个函数,且传入的参数可先固定\n\n  //使用fn变量存储this 此时fn指向调用v2call的函数对象 这里是foo\n  var fn = this;\n  //边界判断 如果不为空 将原始字面量转化为实例对象 否则thisArg指向window\n  thisArg = thisArg ? Object(thisArg) : window;\n  function proxyFn(...args) {\n    thisArg.fn = fn;\n    var concatParams = [...argsArr, ...args];\n    //隐式绑定： 函数在不同上下文调用时会影响this的指向\n    //此时在thisArg上下文中调用时fn的this会绑定thisArg\n    var res = thisArg.fn(...concatParams);\n    //调用完删除fn\n    delete thisArg.fn;\n    //返回fn返回值\n    return res;\n  }\n  //返回这个绑定this后的函数\n  return proxyFn;\n};\nfunction isNone(v) {\n  return v === undefined || v === null;\n}\nvar a = \'这是全局的a\';\nfunction foo() {\n  console.log(\'this指向：\', this);\n  var sum = Array.prototype.reduce.call(\n    arguments,\n    (pre, cur) => {\n      return pre + cur;\n    },\n    0\n  );\n  console.log(\'value:\', sum);\n  return sum;\n}\nvar obj = {\n  a: \'这是obj对象里的a\',\n};\nvar bindFn = foo.v2bind(obj, 1, 2, 3, 4, 5);\nconsole.log(bindFn);\nconsole.log(bindFn(6, 7, 8, 9, 10));\n\n```\n输出结果：  \n<img src=\"https://docs.hgyn23.cn/static/ca844c6114193b8dea5d05161ddae1f8\" width=\"600px\" height=\"auto\" alt=\"ca844c6114193b8dea5d05161ddae1f8\">','2022-04-05 22:05:18','2022-08-13 18:24:45',1,'> call和apply：改变了函数的this上下文后执行该函数\nbind:返回改变了上下文后的一个函数。\ncall、bind和apply的第一个参数都是要改变上下文的对象，而call、bind从第二个参数开始以参数列表的形式展现. apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。',0,NULL,0),(44,'防抖函数解析',1,'>','2022-04-05 22:06:46','2022-04-25 08:40:41',1,'>只有当输入完成后才会触发函数，防止在不停是输入时调用函数，减少资源的浪费。',1,NULL,0),(45,'防抖函数的实现',1,'# 防抖 debounce\n\n## 什么是防抖\n\n在事件触发n秒后再执行回调，如果在这n秒期间又被触发，则重新记时，也就是说在n秒之内只执行最后一次触发\n\n## 执行过程\n\n- 当事件触发时，相应的函数不会立即触发，而是会等待一定的时间\n- 当事件密集触发时，函数的触发将会频繁重置延迟\n- 只有延迟时间内再无任何事件触发，才会执行真正的响应函数\n\n<img src=\"https://docs.hgyn23.cn/static/a426833e5d485957c71ee7c5a7870856\" width=\"600px\" height=\"auto\" alt=\"a426833e5d485957c71ee7c5a7870856\">\n\n## 应用场景\n\n- 输入框中频繁输入内容，搜索或提交信息\n- 频繁点击按钮，触发某个事件\n- 浏览器监听滚动事件完成某些操作\n- 用户缩放浏览器的resize事件\n\n## 实现\n\n### 简易实现\n\n  ```javascript\nfunction debounce(func, delay) {\n  //存储上一次触发的timer\n  let timer = 0;\n  return function (...args) {\n    //清除上一次触发的timer\n    timer ? clearTimeout(timer) : \'\';\n    timer = setTimeout(() => {\n      //绑定调用该函数上下文的this\n      func.apply(this,args);\n    }, delay);\n  };\n}\n  ```\n\n简易版实现了最基本的防抖函数\n\n### 功能新增（立即执行）\n\n```javascript\nfunction debounce(func, delay, immediate = false) {\n  //存储上一次触发的timer\n  let timer = 0;\n  //\n  let invoke = false;\n  return function (...args) {\n    //清除上一次触发的timer\n    timer ? clearTimeout(timer) : \'\';\n    //在触发延迟回调前只执行一次\n    if (immediate && !invoke) {\n      invoke = true;\n      func.apply(this, args);\n    } else {\n      timer = setTimeout(() => {\n        //触发回调后 再次初始化\n        invoke = false;\n        //绑定调用该函数上下文的this\n        func.apply(this, args);\n      }, delay);\n    }\n  };\n}\n```\n\n### 功能新增（封装取消功能）\n\n```javascript\nfunction debounce(func, delay, immediate = false) {\n  //存储上一次触发的timer\n  let timer = null;\n  let invoke = false;\n  return function _debounce(...args) {\n    //清除上一次触发的timer\n    timer ? clearTimeout(timer) : \'\';\n    //在触发延迟回调前只执行一次\n    if (immediate && !invoke) {\n      invoke = true;\n      func.apply(this, args);\n    } else {\n      timer = setTimeout(() => {\n        //触发回调后 再次初始化\n        invoke = false;\n        //绑定调用该函数上下文的this\n        func.apply(this, args);\n      }, delay);\n    }\n  };\n  //封装取消功能\n  _debounce.cancel = function () {\n    timer ? clearTimeout(timer) : \'\';\n    timer = null;\n    invoke = false;\n  };\n}\n```\n\n### 功能新增（获取func返回值）\n\n- 使用Promise\n\n```javascript\nfunction debounce(func, delay, immediate = false) {\n  //存储上一次触发的timer\n  let timer = null;\n  let invoke = false;\n  return function _debounce(...args) {\n    return new Promise((resolve, reject) => {\n      //清除上一次触发的timer\n      timer ? clearTimeout(timer) : \'\';\n      //在触发延迟回调前只执行一次\n      if (immediate && !invoke) {\n        invoke = true;\n        const result = func.apply(this, args);\n        //使用resolve把返回值抛出\n        resolve(result);\n      } else {\n        timer = setTimeout(() => {\n          //触发回调后 再次初始化\n          invoke = false;\n          //绑定调用该函数上下文的this\n          const result = func.apply(this, args);\n          resolve(result);\n        }, delay);\n      }\n    });\n  };\n  _debounce.cancel = function () {\n    timer ? clearTimeout(timer) : \'\';\n    timer = null;\n    invoke = false;\n  };\n}\n```\n\n- 使用回调函数参数callback\n\n```javascript\nfunction debounce(func, delay, immediate = false, callback) {\n  //存储上一次触发的timer\n  let timer = null;\n  //\n  let invoke = false;\n  return function _debounce(...args) {\n    //清除上一次触发的timer\n    timer ? clearTimeout(timer) : \'\';\n    //在触发延迟回调前只执行一次\n    if (immediate && !invoke) {\n      invoke = true;\n      const result = func.apply(this, args);\n      //利用回调函数把返回值抛出\n      if (callback) callback(result);\n    } else {\n      timer = setTimeout(() => {\n        //触发回调后 再次初始化\n        invoke = false;\n        //绑定调用该函数上下文的this\n        const result = func.apply(this, args);\n        if (callback) callback(result);\n      }, delay);\n    }\n  };\n  _debounce.cancel = function () {\n    timer ? clearTimeout(timer) : \'\';\n    timer = null;\n    invoke = false;\n  };\n}\n```\n','2022-04-05 22:08:50','2022-08-02 03:09:09',1,'\n> 防抖: 只有当输入完成后才会触发函数，防止在不停输入时调用函数，减少资源的浪费。',0,NULL,0),(46,'深拷贝实现（JS）',1,'# 概念\n\n- 浅拷贝：\n\n>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。\n浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象，如果你修改了“副本”的值，那么原来的对象也会被修改\n\n- 深拷贝：\n\n>深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。  \n深拷贝把要复制的对象所引用的对象都复制了一遍。如果你修改了“副本”的值，那么原来的对象不会被修改，两者是相互独立的。\n\n## 实现\n\n### 浅拷贝\n\n浅拷贝比较简单，只是浅层的拷贝，内部引入对象时，依然会相互影响\n\n通常的浅拷贝方法有：\n\n`Object.assign`\n\n```javascript\nconst obj = {\n  name: \'Kobe\',\n  age: 18,\n  son: {\n    name: \'Merry\',\n    age: 2,\n  },\n  hobbies: [\'唱\', \'跳\', \'rap\', \'篮球\'],\n  skill: function basketball() {\n    console.log(\'ji ni tai mei\');\n  },\n};\nconst copyObj = Object.assign({}, obj);\ncopyObj.name = \'caicai\'\ncopyObj.son.name = \'xuxu\'\nconsole.log(obj);\nconsole.log(copyObj);\n```\n\n输出结果：\n\n<img src=\"https://docs.hgyn23.cn/static/135a1cc204ed5612f448df0881ac0f2d\" width=\"600px\" height=\"auto\" alt=\"135a1cc204ed5612f448df0881ac0f2d\">\n\n### 深拷贝\n\n- `JSON.parse` + `JSON.stringify`\n\n```javascript\nconst obj = {\n  name: \'Kobe\',\n  age: 18,\n  son: {\n    name: \'Merry\',\n    age: 2,\n  },\n  hobbies: [\'唱\', \'跳\', \'rap\', \'篮球\'],\n  skill: function basketball() {\n    console.log(\'ji ni tai mei\');\n  },\n};\n//1.使用JSON.stringify和JSON.parse来实现\nconst obj1 = JSON.parse(JSON.stringify(obj));\nobj1.son.name = \'caicai\';\nconsole.log(obj);\nconsole.log(obj1);\n//无法转换函数，Symbol\n\n```\n\n<img src=\"https://docs.hgyn23.cn/static/43f83f0bbfc1e3aa88ae47d72eb067b0\" width=\"600px\" height=\"auto\" alt=\"43f83f0bbfc1e3aa88ae47d72eb067b0\">\n\n`JSON.parse(JSON.stringify(obj))`的缺点在于无法转换`Symbol`类型和`Function`类型的对象，如果用此方法，这两种类型在复制过程中会被**忽略**，并且有个非常大的弊端是该方法**不支持循环引用**\n\n- 手写深拷贝函数\n\n```javascript\n\nfunction deepClone(originVal, newMap = new WeakMap()) {\n  //判断传入参数是否是对象类型\n  const valuetype = typeof originVal;\n  const isSet = originVal instanceof Set;\n  const isMap = originVal instanceof Map;\n  const isFunction = valuetype === \'function\';\n  const isSymbol = valuetype === \'symbol\';\n  const isObject =\n    (valuetype === \'object\' || valuetype === \'function\') && valuetype !== null;\n  if (isSet) {\n    return new Set(...originVal);\n  }\n  if (isMap) {\n    return new Map(...originVal);\n  }\n  if (isFunction) {\n    //对象拷贝\n    return originVal;\n  }\n  if (isSymbol) {\n    //Symbol拷贝\n    return Symbol(originVal.description);\n  }\n  if (!isObject) {\n    //值拷贝\n    return originVal;\n  }\n\n  if (newMap.has(originVal)) {\n    return newMap.get(originVal);\n  }\n  //判断是数组还是对象\n  //解决循环引用导致的栈溢出的情况\n  const newObj = Array.isArray(originVal) ? [] : {};\n  newMap.set(originVal, newObj);\n\n  for (const key in originVal) {\n    newObj[key] = deepClone(originVal[key], newMap);\n  }\n  //对Symbol类型的key做特殊处理\n  const symbolKeys = Object.getOwnPropertySymbols(originVal);\n  for (const sKey of symbolKeys) {\n    // const newSKey = Symbol(sKey.description)\n    newObj[key] = deepClone(originVal[sKey], newMap);\n  }\n  return newObj;\n}\n```\n\n运行结果：\n\n<img src=\"https://docs.hgyn23.cn/static/a44e71b6ca83add93c94cea29a8ae00f\" width=\"600px\" height=\"auto\" alt=\"a44e71b6ca83add93c94cea29a8ae00f\">\n','2022-04-05 22:11:20','2022-08-02 03:11:49',1,'>### 浅拷贝：\n>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。\n浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象，如果你修改了“副本”的值，那么原来的对象也会被修改\n>### 深拷贝：\n>深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。  \n深拷贝把要复制的对象所引用的对象都复制了一遍。如果你修改了“副本”的值，那么原来的对象不会被修改，两者是相互独立的。\n',0,NULL,0),(47,'数组方法实现原理解析',1,'>','2022-04-08 08:58:18','2022-04-25 08:40:42',0,'>',0,NULL,0),(48,'如何将函数\"柯里化\"？',1,'```javascript\n// 功能： 传入一个函数 将该函数自动柯里化\n\n/**\n *\n * @param {Function} fn\n */\nfunction currying(fn) {\n  //返回柯里化后的函数\n  //此函数可接受部分参数\n  return function curryed(...args) {\n    //如果此时函数接收的参数大于目标参数长度 则直接调用该函数\\\n    if (fn.length <= args.length) {\n      console.log([...args]);\n      return fn.apply(this, [...args]);\n    } else {\n      //如果此时函数接收的参数小于目标的参数长度 则返回一个函数 该函数可再次接收剩余参数\n      return function (...argsed) {\n        return curryed.apply(this, [...args, ...argsed]);\n      };\n    }\n  };\n}\nfunction add(num1, num2, num3, num4, num5) {\n  return Array.prototype.reduce.call(arguments,((p,c) => p=p+c),0);\n}\nvar curryAdd = currying(add);\nconsole.log(curryAdd(1, 2, 3, 4, 5));\nconsole.log(curryAdd(1, 2)(3, 4, 5));\nconsole.log(curryAdd(1)(2)(3)(4)(5));\n```\n输出结果：\n<img src=\"https://docs.hgyn23.cn/static/df1d0c0b25c7a0d5b25a3124d0c62c84\" width=\"600px\" height=\"auto\" alt=\"df1d0c0b25c7a0d5b25a3124d0c62c84\">','2022-04-08 09:08:00','2022-08-13 18:24:24',1,'> 柯里化，把接收多个参数的函数，变成接受一个单一参数的函数，并且返回接收余下参数的函数，而且返回结果的新函数的技术\n柯里化声称 如果你固定**某些参数**，你将得到接收**余下参数**的一个函数。\n其符合设计模式 **单一职责原则**，可对函数某个阶段进行定制化开发',0,NULL,0),(49,'闭包内存模型解析',1,'<img src=\"https://docs.hgyn23.cn/static/bffaf1d128b8b426dad60b5c6be253ef\" width=\"600px\" height=\"auto\" alt=\"bffaf1d128b8b426dad60b5c6be253ef\">\n\n\n\n### 解析（parse）\n> 创建变量的过程，它属于执行上下文创建中的一环。创建变量的过程会产生作用域，作用域也被称为词法环境\n1. 在执行上下文栈（`ECS`）中创建全局执行上下文`GEC`,`VO(variable object)`指向全局对象`GO(global object)`;\n2. 此时变量foo为函数定义，js引擎在堆内存中开辟一段新空间存储函数对象，该函数对象分为两部分：**作用域和执行体**，作用域`[[scope]]`在定义该函数时确定（**函数内部作用域**+**父级作用域**）;GO.foo指向该函数对象;\n3. 变量a此时为`undefined`;\n\n### 执行（exec）\n1. 代码运行时，执行到var a = foo(),此时为**函数调用**;\n2. foo开始执行，执行上下文栈（`ECS`）中压入函数执行上下文`FEC`，并且**创建AO对象**。函数内部变量开始解析（parse）\n3. name为undefined;变量bar为函数定义，js引擎在堆内存中开辟一段新空间存储bar函数对象，作用域在定义该函数时确定（**函数内部作用域**+**父级作用域**），AO.bar指向该函数对象。\n4. 解析后立即执行，将字符串\'hgyn\'赋给变量name,返回bar函数，将bar函数内存地址赋给全局变量a，此时全局变量指向bar函数，foo函数执行上下文弹出。\n5. 因为foo函数在执行时定义了bar函数，bar函数的`[[scope]]`储存了他的自身和他的父级作用域(AO(foo))，还存在引用关系,所以其父级foo函数的AO不会被销毁。\n6. 又因为此时全局变量指向bar函数，bar函数不会被销毁。形成**闭包**','2022-04-08 11:33:31','2022-08-23 09:24:45',1,'> 闭包是指有权访问另一个函数作用域中变量的函数',0,NULL,0),(50,'讨论原型式继承、寄生式继承存在的弊端以及继承的终极解决方案',1,'### 前言','2022-04-09 20:21:54','2022-04-25 08:40:43',0,'> ',1,NULL,0),(51,'ES6 class语法的pollyfill源码解析',1,'# 前言\nES6的类继承其实是寄生-组合式继承的语法糖，本质上还是对原型的继承。\n### es6 class语法实现继承代码\n```javascript\nclass Person {\n	constructor(name,age) {\n      this.name=name;\n      this.age=age;\n    }\n  eating() {\n  	console.log(this.name+\'eating\')\n  }\n}\n\nclass student extends Person{\n	constructor(name,age,sno){\n    super(name,age)\n      this.sno = son\n    }\n  study(){\n  console.log(this.name+this.sno+\'styding\')\n  }\n}\n```\n### pollyfill源码及注释\n```javascript\n\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n  return (\n    (_typeof =\n      \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n        ? function (obj) {\n            return typeof obj;\n          }\n        : function (obj) {\n            return obj &&\n              \"function\" == typeof Symbol &&\n              obj.constructor === Symbol &&\n              obj !== Symbol.prototype\n              ? \"symbol\"\n              : typeof obj;\n          }),\n    _typeof(obj)\n  );\n}\n\nfunction _inherits(subClass, superClass) {\n  console.log(subClass);\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  // 创建一个空对象 并把父类的原型关联到这个空对象的原型上 在空对象上添加subClass的构造函数\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: { value: subClass, writable: true, configurable: true }\n  });\n  //将子类的原型配置为不可写\n  Object.defineProperty(subClass, \"prototype\", { writable: false });\n  //让函数subClass的__proto__指向superClass（静态方法的继承）\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf =\n    Object.setPrototypeOf ||\n    function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n  return _setPrototypeOf(o, p);\n}\n//创建super\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      /**\n       * Super: Person\n       * arguments: 传入的参数\n       * NewTarget： Student\n       * Reflect.construct的作用是通过Super创建一个实例并将这个实例的原型的constructor指向NewTarget\n      */\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    //返回这个实例\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\n      \"Derived constructors may only return object or undefined\"\n    );\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\n      \"this hasn\'t been initialised - super() hasn\'t been called\"\n    );\n  }\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(\n      Reflect.construct(Boolean, [], function () {})\n    );\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf\n    ? Object.getPrototypeOf\n    : function _getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n      };\n  return _getPrototypeOf(o);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  //类型检测 检查this是否是目标构造函数的实例 如果不是就表示没有用new调用\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n//为目标对象使用defineProperty添加属性\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    //除非明确配置enumerable 否则不可枚举\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    //如果protoProp本身属性中有value 则设置为可写\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n// 如果protoProps数组有值 则调用defineProperties 为构造函数的原型添加（加工后的）属性\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n// 如果staticProps数组有值 则调用defineProperties 为构造函数的对象添加（加工后的）属性\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", { writable: false });\n  return Constructor;\n}\n// 立即执行函数 防止变量污染  /*#__PURE__*/  纯函数 可被tree shaking\nvar Person = /*#__PURE__*/ (function () {\n  function Person(name, age) {\n    //类型检测 检查是否使用new调用 如果是直接调用 则抛出错误\n    _classCallCheck(this, Person);\n\n    this.name = name;\n    this.age = age;\n  }\n  //创建类 _createClass\n  _createClass(Person, [\n    {\n      key: \"eating\",\n      value: function eating() {\n        console.log(this.name + \"eating\");\n      }\n    }\n  ]);\n\n  return Person;\n})();\nvar Student = /*#__PURE__*/ (function (_Person) {\n  //继承_Person原型上的方法和静态方法\n  _inherits(Student, _Person);\n  //获取父类构造函数创建的实例（此时他的原型的constructor指向Student）\n  var _super = _createSuper(Student);\n\n  function Student(name, age, sno) {\n    var _this;\n\n    _classCallCheck(this, Student);\n    //因为不能通过Person函数直接调用（不允许） 继承属性\n    _this = _super.call(this, name, age);\n    _this.sno = sno;\n    return _this;\n  }\n\n  _createClass(Student, [\n    {\n      key: \"study\",\n      value: function study() {\n        console.log(this.name + this.sno + \"styding\");\n      }\n    }\n  ]);\n\n  return Student;\n})(Person);\nvar stu = new Student(\'lihua\',18,1)\n```','2022-04-10 01:15:58','2022-04-25 08:40:43',1,'> ES6的类继承其实是寄生-组合式继承的语法糖，本质上还是对原型的继承。',0,NULL,0),(52,'Vue3 响应式设计原理(Proxy)',1,'```javascript\nfunction reactive(obj) {\n  return new Proxy(obj, {\n    get(target, key, receiver) {\n      const depend = getDepend(target, key);\n      depend.addDepend();\n      return Reflect.get(target, key, receiver);\n    },\n    set(target, key, newValue, receiver) {\n      console.log(`对象的${key}值改变为了${newValue}`);\n      Reflect.set(target, key, newValue, receiver);\n      const depend = getDepend(target, key);\n      depend.notify();\n    },\n  });\n}\nlet curDepsFunc = null;\nclass Deps {\n  constructor() {\n    this.dep = new Set();\n  }\n  addDepend() {\n    if (curDepsFunc) {\n      this.dep.add(curDepsFunc);\n    }\n  }\n  notify() {\n    for (const fn of this.dep) {\n      fn();\n    }\n  }\n}\n\nconst dependWeakMap = new WeakMap();\nfunction getDepend(target, key) {\n  let depsMap = dependWeakMap.get(target);\n  if (!depsMap) {\n    depsMap = new Map();\n    dependWeakMap.set(target, depsMap);\n  }\n  let deps = depsMap.get(key);\n  if (!deps) {\n    deps = new Deps();\n    depsMap.set(key, deps);\n  }\n  return deps;\n}\nfunction watchEffect(fn) {\n  curDepsFunc = fn;\n\n  fn();\n}\nconst proxyObj = reactive({\n  name: \'Kobe\',\n  age: 18,\n});\nwatchEffect(function () {\n  console.log(proxyObj.name);\n  console.log(proxyObj.age);\n});\n// watchEffect(function () {\n//   console.log(proxyObj.age);\n// });\nproxyObj.name = \'wangweiping\';\nproxyObj.name = \'xieting\';\nproxyObj.age = 2012;\n\n```','2022-04-11 16:43:50','2022-04-25 08:40:43',1,'> ',0,NULL,0),(53,'Iterator-Generator协议与async、await实现原理推导',1,'>','2022-04-12 17:01:36','2022-07-24 08:50:49',0,'> 迭代器是使用户可在**容器对象**(container,如链表或数组)上**遍访**的对象，使用该接口无需关心对象内部的实现细节',0,NULL,0),(54,'浏览器 事件循环(EventLoop)&事件队列模型',1,'在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：\n\n执行一个宏任务（栈中没有就从事件队列中获取）\n执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\n<img src=\"https://docs.hgyn23.cn/static/841007981b288c879dfc6297dd98afa0\" width=\"600px\" height=\"auto\" alt=\"841007981b288c879dfc6297dd98afa0\">','2022-04-13 09:38:55','2022-09-02 09:53:00',1,'>事件循环就像是一个**桥梁**，连接着应用程序的Javascript和系统调用之间的通道\n事件循环会**不断**的从**任务队列**中取出对应的事件（回调函数）进行执行',0,NULL,0),(55,'Node 事件循环&事件队列模型',1,'Node中的事件循环相较于浏览器更为复杂\n- 宏任务(macrotask):setTimeout、setInterval、IO事件、setImmediate、close事件;\n- 微任务(microtask):Promise的then回调、process.nextTick、queueMicrotask;\n\n但是，Node中的事件循环不只是微任务队列和宏任务队列\n- 微任务队列\n	- next tick queue:process.nextTick\n	- other queue:Promise的then回调、queueMicrotask；\n- 宏任务队列\n	- timer queue:setTimeout、setInterval;\n	- poll queue:IO事件;\n	- check queue:setImmediate;\n	- close queue:close事件','2022-04-13 10:55:45','2022-07-25 05:33:31',1,'> Node 中的EventLoop是由**libuv**实现的，其主要维护了一个**EventLoop**和**worker threads（线程池）**\nEventLoop负责调用系统的一些其他操作，如**文件的IO**、**NetWork**、**child-process**等',0,NULL,0),(56,'blog优化计划',1,'1. 新增标签头部随文章标题变化\n2. 新增搜索功能，封装搜索组件 ✔\n3. 平台新增标签管理\n4. 新增文章置顶功能 ✔\n5. 新增设定通知功能：设置提醒事项，在指定时间使用pushPlus给我的微信发送提醒。\n6. 新增文章关联功能，比如说相同section的文章以上一篇、下一篇展示','2022-04-13 16:08:29','2022-08-26 08:31:32',0,'>',0,NULL,1),(57,'节流函数的实现',1,'# 节流 throttle\n\n## 什么是节流\n\n为了限制函数一段时间内只能执行一次。 通过使用定时任务，延时方法执行。 在延时的时间内，方法若被触发，则直接退出方法。 从而实现一段时间内只执行一次。\n\n## 执行过程\n\n- 当事件触发时，相应的函数不会立即触发，而是会等待一定的时间\n- 当事件密集触发时，函数的触发将会在间隔指定时间后触发一次\n<img src=\"https://docs.hgyn23.cn/static/09d59b2ae785070fbe1b8a8fac6e14de\" width=\"600px\" height=\"auto\" alt=\"09d59b2ae785070fbe1b8a8fac6e14de\">\n## 应用场景\n\n- scroll 事件，每隔一秒计算一次位置信息等\n- 浏览器播放事件，每个一秒计算一次进度信息等\n- input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (防抖也可)\n\n## 实现\n\n### 简易实现\n\n  ```javascript\nfunction throttle(func, interval) {\n  //记录上一次开始时间\n  let lastTime = 0;\n  return function _throttle(...args) {\n    //获取当前事件触发的时间\n    const nowTime = new Date().getTime();\n    //计算还需要多长时间才触发函数\n    //给定的时间间隔减去当前时间与上次开始时间之差\n    const remainTime = interval - (nowTime - lastTime);\n    if (remainTime <= 0) {\n      func.apply(args);\n      lastTime = nowTime;\n    }\n  };\n}\n\n\n  ```\n\n简易版实现了最基本的节流函数，但是它有个缺陷，在第一次触发节流函数时，他的回调总是会立即执行一次，原因是在计算remainTime时，由于lastTime为0，导致计算结果远小于0。\n\n### 功能新增（立即执行）\n\n```javascript\nfunction throttle(\n  func,\n  interval,\n  options = { immediate: true }\n) {\n  //记录上一次开始时间\n  let lastTime = 0;\n  const { immediate } = options;\n  return function _throttle(...args) {\n    //获取当前事件触发的时间\n    const nowTime = new Date().getTime();\n    //只有当第一次执行的时候会被触发\n    if (!lastTime && !immediate) lastTime = nowTime;\n    //计算还需要多长时间才触发函数\n    //给定的时间间隔减去当前时间与上次开始时间之差\n    const remainTime = interval - (nowTime - lastTime);\n    if (remainTime <= 0) {\n      func.apply(args);\n      lastTime = nowTime;\n    }\n  };\n}\n\n```\n\n### 功能新增（尾随）\n\n```javascript\nfunction throttle(\n  func,\n  interval,\n  options = { immediate: true, trailing: true }\n) {\n  //记录上一次开始时间\n  let lastTime = 0;\n  let timer = null;\n  const { immediate, trailing } = options;\n  return function _throttle(...args) {\n    //获取当前事件触发的时间\n    const nowTime = new Date().getTime();\n    if (!lastTime && !immediate) lastTime = nowTime;\n    //计算还需要多长时间才触发函数\n    //给定的时间间隔减去当前时间与上次开始时间之差\n    const remainTime = interval - (nowTime - lastTime);\n    if (remainTime <= 0) {\n      clearTimeout(timer);\n      timer = null;\n      func.apply(args);\n      lastTime = nowTime;\n      return\n    }\n    if (trailing && !timer) {\n      timer = setTimeout(() => {\n        timer = null\n        func.apply(args);\n        //如果是立即执行，那么在间隔内第二次触发时会进入该延时回调\n        //例如在第1s时再次触发，那么延时回调会在1s后回调，此时如果用户在2.1s时再进入节流函数，此定时器已经在2s时被执行了，lastTime置0会导致调用两次的bug\n        //解决方法：如果是立即执行，那么在触发该回调时将当前时间给lastTime 让上面的函数不执行\n        //解决方法：如果不是立即执行，那么将其置0 让上面的函数不执行\n        lastTime = !immediate ? 0 : new Date().getTime();\n      }, remainTime);\n    }\n  };\n}\n\n\n```\n\n### 功能新增（获取func返回值）\n\n- 使用Promise\n\n```javascript\nfunction throttle(\n  func,\n  interval,\n  options = { immediate: true, trailing: true }\n) {\n  //记录上一次开始时间\n  let lastTime = 0;\n  let timer = null;\n  const { immediate, trailing } = options;\n  return function _throttle(...args) {\n    return new Promise(function (resolve, reject) {\n      //获取当前事件触发的时间\n      const nowTime = new Date().getTime();\n      if (!lastTime && !immediate) lastTime = nowTime;\n      //计算还需要多长时间才触发函数\n      //给定的时间间隔减去当前时间与上次开始时间之差\n      const remainTime = interval - (nowTime - lastTime);\n      if (remainTime <= 0) {\n        clearTimeout(timer);\n        timer = null;\n        const result = func.apply(args);\n        resolve(result);\n        lastTime = nowTime;\n        return;\n      }\n      if (trailing && !timer) {\n        timer = setTimeout(() => {\n          timer = null;\n          const result = func.apply(args);\n          resolve(result);\n          lastTime = !immediate ? 0 : new Date().getTime();\n        }, remainTime);\n      }\n    });\n  };\n}\n\n```','2022-04-17 21:47:08','2022-08-02 03:10:03',1,'> 为了限制函数一段时间内只能执行一次。 通过使用定时任务，延时方法执行。 在延时的时间内，方法若被触发，则直接退出方法。 从而实现一段时间内只执行一次。',0,NULL,0),(58,'Vue2 响应式设计原理(Object.defineProperty)',1,'```javascript\nfunction reactive(obj) {\n  Object.keys(obj).forEach((key) => {\n    let value = obj[key];\n    Object.defineProperty(obj, key, {\n      get() {\n        const depend = getDepend(obj, key);\n        depend.addDepend();\n        return value;\n      },\n      set(newVal) {\n        value = newVal;\n        const depend = getDepend(obj, key);\n        depend.notify();\n      },\n    });\n  });\n  return obj;\n}\nlet curDepsFunc = null;\nclass Deps {\n  constructor() {\n    this.dep = new Set();\n  }\n  addDepend() {\n    if (curDepsFunc) {\n      this.dep.add(curDepsFunc);\n    }\n  }\n  notify() {\n    for (const fn of this.dep) {\n      fn();\n    }\n  }\n}\n\nconst dependWeakMap = new WeakMap();\nfunction getDepend(target, key) {\n  let depsMap = dependWeakMap.get(target);\n  if (!depsMap) {\n    depsMap = new Map();\n    dependWeakMap.set(target, depsMap);\n  }\n  let deps = depsMap.get(key);\n  if (!deps) {\n    deps = new Deps();\n    depsMap.set(key, deps);\n  }\n  return deps;\n}\nfunction watchEffect(fn) {\n  curDepsFunc = fn;\n\n  fn();\n}\nconst proxyObj = reactive({\n  name: \'Kobe\',\n  age: 18,\n});\nwatchEffect(function () {\n  console.log(proxyObj.name);\n  console.log(proxyObj.age);\n});\n// watchEffect(function () {\n//   console.log(proxyObj.age);\n// });\nproxyObj.name = \'wangweiping\';\nproxyObj.name = \'xieting\';\nproxyObj.age = 2012;\n\n```','2022-04-18 16:42:25','2022-04-25 08:40:45',1,'>',0,NULL,0),(59,'Vuejs中 watch computed属性与生命周期之间的关系与执行顺序（详细）',1,'# 前言\n\n在工作中频繁遇到Vue的生命周期与`watch`、`computed`之间联系紧密的逻辑，所以特地起了一个项目专门研究他们之间的关系和执行顺序。\n\n本项目页面分成两个组件，父组件和其包含的子组件，分别定义其各个生命周期钩子函数，函数作用是输出执行时机，以此来判断执行顺序。\n\n接下来直接做验证：\n\n## 初始化\n\n- 如果只有单个组件，在Vue初始化时的组件执行顺序如下\n\n> `beforeCreate` > `watch`(?立即监听) > `created` > `beforeMount` > `computed` > `mounted`\n\n- 如果父组件中\n  - 页面中关联了`computed`计算属性,但与`watch`无关联\n\n> 父组件`beforeCreate` > 父组件`watch`(?立即监听) > 父组件`created` > 父组件`beforeMount` > **（父组件`computed`）** > 子组件`beforeCreate` > 子组件`watch`(?立即监听) > 子组件`created` > 子组件`beforeMount` >**(子组件`computed`)** > 子组件`mounted` > 父组件`mounted`\n\n- 如果父组件中\n  - `watch`中关联了`computed`属性，但未与页面关联\n\n> 父组件`beforeCreate` > 父组件`watch`(?立即监听) > **(父组件`computed` > 父组件`watch`(?立即监听))** > 父组件`created` > 父组件`beforeMount` >  子组件`beforeCreate` > 子组件`watch`(?立即监听)  >**(子组件`computed` > 子组件`watch`(?立即监听))** > 子组件`created` > 子组件`beforeMount` > 子组件`mounted` > 父组件`mounted`\n\n- 如果父组件中\n  - `watch`中关联了`computed`属性，又与`页面`关联\n\n与（`watch`中关联了`computed`属性，但未与`页面`关联）执行顺序相同\n\n> Tips: 以上watch都是配置了immediate=true的情况 且做了标注，如果为false，则不会立即执行\n\n## 运行时\n\n- 执行组件`methods`中的方法使组件中与页面相关联的`data`发生变化执行顺序如下\n\n> `watch` > `beforeUpdate` > `computed` > `updated`\n\n- 执行父组件`methods`中的方法使子组件中与页面相关联的`data`发生变化(有传值给子组件)\n  - 页面中关联了`computed`计算属性,但与`watch`无关联\n\n> 父组件`watch` > 父组件`beforeUpdate` > （父组件`computed`） > 子组件`watch` > 子组件`beforeUpdate` > （子组件`computed`） > 子组件`update` > 父组件`updated`\n\n- 执行父组件`methods中`的方法使子组件中与页面相关联的data发生变化(有传值给子组件)\n  - `watch`中关联了`computed`属性，但未与页面关联\n\n> 父组件`watch` > （父组件`computed` > 父组件`watch`） > 父组件`beforeUpdate` > 子组件`watch` > （子组件`computed` > 子组件`watch`） > 子组件`beforeUpdate` > 子组件`update` > 父组件`updated`\n\n- 执行父组件`methods`中的方法使子组件中与页面相关联的data发生变化(有传值给子组件)\n  - `watch`中关联了`computed`属性，又与页面关联\n\n与（`watch`中关联了`computed`属性，但未与`页面`关联执行顺序）相同\n\n\n\n## 结论\n\n1. computed计算属性在首次初始化时在beforeMount和mounted之间会执行一次。\n2. 初始化时，只要与computed关联的watch设置了立即监听，computed总是会在create钩子执行之前提前执行（可能是因为watch侦听属性如果设置了immdiate属性为true，那么在初始化时会在beforeCreate和created之间执行一次，会导致computed强制提前）。\n3. 组件中data、props值改变后，首先是关联的watch执行回调，然后在beforeUpdate和updated之间关联的computed会执行回调，如果此时有watch与computed有关联，那么watch会再次执行。\n','2022-04-22 16:09:48','2022-07-24 03:34:13',1,'> 在工作中频繁遇到Vue的生命周期与`watch`、`computed`之间联系紧密的逻辑，所以特地起了一个项目专门研究他们之间的关系和执行顺序。',0,NULL,0),(60,'块级格式上下文（BFC）定义及应用场景',1,'### 什么是BFC？\n\nFormatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n### 触发条件\n\n一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：\n\n- 根元素（<html>）\n- 浮动元素（元素的 float 不是 none）\n- 绝对定位元素（元素的 position 为 absolute 或 fixed）\n- 行内块元素（元素的 display 为 inline-block）\n- 表格单元格（元素的 display 为 table-cell，HTML表格单元格默认为该值）\n- 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）\n- 匿名表格单元格元素（元素的 display 为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 inline-table）\n- overflow 计算值(Computed)不为 visible 的块元素\n- display 值为 flow-root 的元素\n- contain 值为 layout、content 或 paint 的元素\n- 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素）\n- 网格元素（display 为 grid 或 inline-grid 元素的直接子元素）\n- 多列容器（元素的 column-count 或 column-width (en-US) 不为 auto，包括 column-count 为 1）\n- column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。\n\n### BFC渲染规则\n1. BFC垂直方向边距重叠\n\n2. BFC的区域不会与浮动元素的box重叠\n\n3. BFC是一个独立的容器，外面的元素不会影响里面的元素\n\n4. 计算BFC高度的时候浮动元素也会参与计算\n\n### 应用场景\n	\n	1. BFC 可以包含浮动的元素（清除浮动）\n	2. 避免外边距折叠\n	3. 阻止元素被浮动元素覆盖\n\n参考：[理解 BFC 原理](https://zhuanlan.zhihu.com/p/25321647)\n	\n	','2022-04-23 21:04:48','2022-04-25 09:50:32',1,' W3C对BFC的定义如下：\n>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为\"visiable\"的块级盒子，都会为他们的内容创建新的BFC（Block Fromatting Context， 即块级格式上下文）。',0,NULL,0),(61,'测试',1,'测试','2022-04-26 10:13:50','2022-04-26 02:13:58',0,'测试',1,NULL,0),(62,'实现盒子居中的若干方法（持续补充）',1,'## 盒子宽高已知\n- 使用绝对定位将top left 都设为50%，并减去盒子一般宽高，盒子将居中显示。\n\n```css\n	.box {\n	  height: 200px;\n	  width: 200px;\n	  background-color: black;\n	  position: absolute;\n	  top: 50%;\n	  left: 50%;\n	  margin-top: -100px;\n	  margin-left: -100px;\n	}\n```\n\n```html\n<div class=\"box\"></div>\n```\n\n## 盒子宽高未知\n\n- 使用绝对定位将top left right bottom 都设为0，盒子将居中显示。\n\n```css\n	.box {\n	  height: 200px;\n	  width: 200px;\n	  background-color: black;\n	  position: absolute;\n	  top: 0;\n	  left: 0;\n	  right: 0;\n	  bottom: 0;\n	  margin: auto;\n	}\n```\n\n```html\n  <div class=\"box\"></div>\n```\n\n- 使用绝对定位将top left 都设为50%，并使用`transform:translate(-50%,-50%)`将盒子移动自身50%，盒子将居中显示。\n\n```css\n	.box {\n 	  height: 200px;\n 	  width: 200px;\n 	  background-color: black;\n 	  position: absolute;\n 	  top: 50%;\n 	  left: 50%;\n 	  transform: translate(-50%, -50%);\n 	}\n```\n\n```html\n    <div class=\"box\"></div>\n```\n\n- 使用flex布局。\n\n```css\n	.body {\n  	display: flex;\n	}\n  .box {\n    height: 200px;\n    width: 200px;\n    background-color: black;\n    justify-content: center;\n    align-items: center;\n  }\n```\n\n```html\n  <div class=\"box\"></div>\n```\n- flex布局变种,垂直居中使用marin:auto 0;代替，此方法可以使该盒子内部的文本在居中的同时保持开头在盒子中显示。\n```css\n	.body {\n  	display: flex;\n	}\n  .box {\n    height: 200px;\n    width: 200px;\n    background-color: black;\n    justify-content: center;\n    margin: auto 0;\n  }\n```\n\n```html\n  <div class=\"box\"></div>\n```\n\n- element-ui源码中发现的，父盒子使用`text-align:center`让子盒子水平居中，子盒子使用`vertical-align: middle`垂直居中，vertical-align这个属性，这个属性虽然是垂直置中，不过却是指在元素内的所有元素垂直位置互相置中，并不是相对于外框的高度垂直居中。所以需要设其中一个子盒子高度100%，这样其中所有元素都相对于这个元素做到真正居中。\n\n```css\n	.box {\n    height: 500px;\n    width: 500px;\n    background-color: black;\n    text-align: center;\n  }\n  .child-box {\n    display: inline-block;\n    vertical-align: middle;\n    height: 200px;\n    width: 200px;\n    background-color: #ffffff;\n  }\n  .box::after {\n    content: \'\';\n    height: 100%;\n    vertical-align: middle;\n    display: inline-block;\n  }\n```\n\n```html\n		<div class=\"box\">\n      <div class=\"child-box\"></div>\n    </div>\n```\n\n- `display:table-cell`让标签元素以表格单元格的形式呈现，类似于`td`标签,设置了`display:table-cell`的元素对宽度高度敏感，对`margin`值无反应，响应`padding`属性，父盒子使用该属性后设置`vertical-align: middle;`可使子盒子垂直居中，使用`text-align: center;`可使子盒子水平居中。对于`table-cell`的具体应用，参考[网址](https://www.zhangxinxu.com/wordpress/2010/10/%E6%88%91%E6%89%80%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E7%A7%8Ddisplaytable-cell%E7%9A%84%E5%BA%94%E7%94%A8/)\n\n```css\n	.container {\n    display: table-cell;\n    width: 1000px;\n    height: 500px;\n    background-color: #beceeb;\n    font-size: 144px;\n    text-align: center;\n    vertical-align: middle;\n  }\n  .container .children {\n    display: inline-block;\n    width: 500px;\n    height: 250px;\n    background-color: #fff;\n    vertical-align: middle;\n  }\n```\n\n```html\n <div class=\"container\">\n      <div class=\"children\"></div>\n    </div>\n```\n\n','2022-05-10 14:27:41','2022-11-03 07:30:19',1,'> 介绍以下几种盒子居中方法，在已知或者未知盒子宽高时可选用不同方法',0,NULL,0),(63,'v-if&&v-show原理解析以及最小模型实现',1,'\n## 前期准备\n视图层准备了四个盒子，相同宽高，并且给他们各自不同的颜色以区分，并且全部设置为左浮动，这样能观察到`v-if`显隐的排序问题。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      .box1 {\n        float: left;\n        width: 100px;\n        height: 120px;\n        background-color: red;\n      }\n      .box2 {\n        float: left;\n        width: 100px;\n        height: 120px;\n        background-color: green;\n      }\n      .box3 {\n        float: left;\n        width: 100px;\n        height: 120px;\n        background-color: blue;\n      }\n      .box4 {\n        float: left;\n        width: 100px;\n        height: 120px;\n        background-color: gray;\n      }\n      .box-container {\n        overflow: hidden;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"wrapper\">\n      <div class=\"box-container\">\n        <div class=\"box1\" v-if=\"boxView1\">box1</div>\n        <div class=\"box2\" v-show=\"boxView2\">box2</div>\n        <div class=\"box3\" v-show=\"boxView3\">box3</div>\n        <div class=\"box4\" v-if=\"boxView4\">box4</div>\n      </div>\n      <div class=\"control\">\n        <button @click=\"changeView1\">change view 1</button>\n        <button @click=\"changeView2\">change view 2</button>\n        <button @click=\"changeView3\">change view 3</button>\n        <button @click=\"changeView4\">change view 4</button>\n      </div>\n    </div>\n    <script src=\"./index.js\"></script>\n    <script>\n      const app = new HyVue({\n        el: \'.wrapper\',\n        data: {\n          boxView1: false,\n          boxView2: false,\n          boxView3: false,\n          boxView4: false,\n        },\n        methods: {\n          changeView1() {\n            this.boxView1 = !this.boxView1;\n            console.log(\'changeView1\');\n          },\n          changeView2() {\n            this.boxView2 = !this.boxView2;\n            console.log(\'changeView2\');\n          },\n          changeView3() {\n            this.boxView3 = !this.boxView3;\n            console.log(\'changeView3\');\n          },\n          changeView4() {\n            this.boxView4 = !this.boxView4;\n            console.log(\'changeView4\');\n          },\n        },\n      });\n    </script>\n  </body>\n</html>\n\n```\n## js部分\n### class初始化\njs部分定义了一个类，在new该类时初始化，将传入的options解构出挂载元素`el`,数据层`data`,事件层`methods`\n```javascript\nclass HyVue {\n  constructor(options) {\n    const { el, data, methods } = options;\n    this.el = document.querySelector(el);\n    this.data = data;\n    this.methods = methods;\n  }\n}\n\n```\n### 创建视图和数据的关联\n视图要进行变化，必须拿到相关的元素做处理，而且元素和数据肯定要关联起来，这样在找到元素时也能找到数据，同时找到数据也能找到元素。此时可使用Map来做映射处理，所以我们定义一个showPool为视图池，eventPool为事件池。将data和对应的dom元素关联并添加到showPool;将event和对应的dom元素关联并添加到eventPool。\n```javascript\nclass HyVue {\n  constructor(options) {\n    const { el, data, methods } = options;\n    this.el = document.querySelector(el);\n    this.data = data;\n    this.methods = methods;\n    this.showPool = new Map();\n    this.eventPool = new Map();\n  }\n```\n### 初始化数据（将data中的数据代理到实例的this）\n这个步骤将用defineProperty将数据代理到this，这样在绑定的方法中用this访问时可以直接访问到data而不用再进到data对象去访问。在vue2中我们可以使用this直接访问到data的数据也是这个原理。\n```javascript\nclass HyVue {\n  constructor(options) {\n    const { el, data, methods } = options;\n    this.el = document.querySelector(el);\n    this.data = data;\n    this.methods = methods;\n    this.showPool = new Map();\n    this.eventPool = new Map();\n    this.init();\n  }\n  init() {\n    //初始化数据，将data中的数据代理到this中\n    this.initData();\n  }\n  initData() {\n    const dataKey = Object.keys(this.data);\n    for (const key of dataKey) {\n      Object.defineProperty(this, key, {\n        get: function () {\n          return this.data[key];\n        },\n        set: function (newValue) {\n          this.data[key] = newValue;\n        },\n      });\n    }\n  }\n```\n### 初始化dom\n这一步为关键步骤，我们需要在视图池和事件池中添加关联，以在后续可以找到某个绑定的dom元素所对应的data或方法。\n```javascript\nclass HyVue {\n  constructor(options) {\n    const { el, data, methods } = options;\n    this.el = document.querySelector(el);\n    this.data = data;\n    this.methods = methods;\n    this.showPool = new Map();\n    this.eventPool = new Map();\n    this.init();\n  }\n  init() {\n    //初始化数据，将data中的数据代理到this中\n    this.initData();\n    //初始化dom 往视图池和事件池中添加关联\n    this.initDom();\n    //初始化视图，根据视图池中的关联，决定元素的显隐，\n    this.initView(this.showPool);\n    //初始化方法，为事件池中关联元素绑定事件\n    this.initMethods();\n  }\n  initData() {\n    const dataKey = Object.keys(this.data);\n    for (const key of dataKey) {\n      Object.defineProperty(this, key, {\n        get: function () {\n          return this.data[key];\n        },\n        set: function (newValue) {\n          this.data[key] = newValue;\n        },\n      });\n    }\n  }\n  initDom() {\n    const traverseNode = (node) => {\n      if (!node.childNodes.length) return;\n      const nodes = node.childNodes;\n      for (const dom of nodes) {\n				//此时nodeType===1为元素节点\n        if (dom.nodeType === 1) {\n					//找到有以下属性的dom元素\n          const v_if = dom.getAttribute(\'v-if\');\n          const v_show = dom.getAttribute(\'v-show\');\n          const v_event = dom.getAttribute(\'@click\');\n          if (v_if) {\n						//创建v_if关联\n            this.showPool.set(dom, {\n              type: \'v-if\',\n              show: this[v_if],\n              dataName: v_if,\n            });\n          } else if (v_show) {\n						//创建v_show关联\n            this.showPool.set(dom, {\n              type: \'v-show\',\n              show: this[v_show],\n              dataName: v_show,\n            });\n          }\n          if (v_event) {\n						//创建事件关联\n            this.eventPool.set(dom, {\n              method: this.methods[v_event],\n              dataName: v_event,\n              event: \'click\',\n            });\n          }\n					//递归查询\n          traverseNode(dom);\n        }\n      }\n    };\n    traverseNode(this.el);\n  }\n\n```\n## 初始化视图\n此时视图层和数据层的关联已经创建完了，下一步是不是应该将视图和数据联系起来了？如果dom元素属性为v-if,那么其绑定的data为false时，将不对其进行渲染，重点来了**我们应该如何隐藏该元素？** 第一种办法直截了当，把该元素删掉，后续显示的时候再创建。哈哈，很明显这种办法行不通，因为你不知道创建该元素后应该放在那个位置，appendChild？那么创建的元素会在所有子元素的尾部，这样dom结构就乱了；insertChild？此时的位置是未知的，如果要知道在哪个元素的前面，这样需要重复做复杂的记录操作。所以有一个解决办法，vue也是使用了这个办法，使用注释来替换该元素，然后记录该注释，之后如果要显示该元素，那么就用该dom节点来替换注释。\n```javascript\nclass HyVue {\n  constructor(options) {\n    const { el, data, methods } = options;\n    this.el = document.querySelector(el);\n    this.data = data;\n    this.methods = methods;\n    this.showPool = new Map();\n    this.eventPool = new Map();\n    this.init();\n  }\n  init() {\n    //初始化数据，将data中的数据代理到this中\n    this.initData();\n    //初始化dom 往视图池和事件池中添加关联\n    this.initDom();\n    //初始化视图，根据视图池中的关联，决定元素的显隐，\n    this.initView(this.showPool);\n    //初始化方法，为事件池中关联元素绑定事件\n    this.initMethods();\n  }\n  initData() {\n    const dataKey = Object.keys(this.data);\n    for (const key of dataKey) {\n      Object.defineProperty(this, key, {\n        get: function () {\n          return this.data[key];\n        },\n        set: function (newValue) {\n          this.data[key] = newValue;\n          this.domChange(\n            {\n              key,\n              newValue,\n            },\n            this.showPool\n          );\n        },\n      });\n    }\n  }\n  initDom() {\n    const traverseNode = (node) => {\n      if (!node.childNodes.length) return;\n      const nodes = node.childNodes;\n      for (const dom of nodes) {\n        if (dom.nodeType === 1) {\n          const v_if = dom.getAttribute(\'v-if\');\n          const v_show = dom.getAttribute(\'v-show\');\n          const v_event = dom.getAttribute(\'@click\');\n          if (v_if) {\n            this.showPool.set(dom, {\n              type: \'v-if\',\n              show: this[v_if],\n              dataName: v_if,\n            });\n          } else if (v_show) {\n            this.showPool.set(dom, {\n              type: \'v-show\',\n              show: this[v_show],\n              dataName: v_show,\n            });\n          }\n          if (v_event) {\n            this.eventPool.set(dom, {\n              method: this.methods[v_event],\n              dataName: v_event,\n              event: \'click\',\n            });\n          }\n          traverseNode(dom);\n        }\n      }\n    };\n    traverseNode(this.el);\n  }\n  initView(data, showPool) {\n    //同时负责视图层的更新\n    this.domChange(null, this.showPool);\n  }\n  domChange(data, showPool) {\n    if (!data) {\n			//初始化\n      showPool.forEach((view, dom) => {\n        switch (view.type) {\n          case \'v-if\':\n            view.comment = document.createComment(view.dataName || \'unknown\');\n            view.show ? \'\' : dom.parentNode.replaceChild(view.comment, dom);\n            break;\n          case \'v-show\':\n            view.show\n              ? (dom.style.display = \'block\')\n              : (dom.style.display = \'none\');\n            break;\n        }\n      });\n    }\n  }\n```\n### 初始化方法\n这个没什么好说的，把事件池eventPool遍历一遍，使用dom.addEventListener绑定事件，但是有一点要注意，此时所绑定的事件的this是指向该元素的，所以需要用`Func.bind(this)`显式绑定this到实例，这样才能访问实例里的data。\n```javascript\nclass HyVue {\n  constructor(options) {\n    const { el, data, methods } = options;\n    this.el = document.querySelector(el);\n    this.data = data;\n    this.methods = methods;\n    this.showPool = new Map();\n    this.eventPool = new Map();\n    this.init();\n  }\n  init() {\n    //初始化数据，将data中的数据代理到this中\n    this.initData();\n    //初始化dom 往视图池和事件池中添加关联\n    this.initDom();\n    //初始化视图，根据视图池中的关联，决定元素的显隐，\n    this.initView(this.showPool);\n    //初始化方法，为事件池中关联元素绑定事件\n    this.initMethods();\n  }\n  initData() {\n    const dataKey = Object.keys(this.data);\n    for (const key of dataKey) {\n      Object.defineProperty(this, key, {\n        get: function () {\n          return this.data[key];\n        },\n        set: function (newValue) {\n          this.data[key] = newValue;\n          this.domChange(\n            {\n              key,\n              newValue,\n            },\n            this.showPool\n          );\n        },\n      });\n    }\n  }\n  initDom() {\n    const traverseNode = (node) => {\n      if (!node.childNodes.length) return;\n      const nodes = node.childNodes;\n      for (const dom of nodes) {\n        if (dom.nodeType === 1) {\n          const v_if = dom.getAttribute(\'v-if\');\n          const v_show = dom.getAttribute(\'v-show\');\n          const v_event = dom.getAttribute(\'@click\');\n          if (v_if) {\n            this.showPool.set(dom, {\n              type: \'v-if\',\n              show: this[v_if],\n              dataName: v_if,\n            });\n          } else if (v_show) {\n            this.showPool.set(dom, {\n              type: \'v-show\',\n              show: this[v_show],\n              dataName: v_show,\n            });\n          }\n          if (v_event) {\n            this.eventPool.set(dom, {\n              method: this.methods[v_event],\n              dataName: v_event,\n              event: \'click\',\n            });\n          }\n          traverseNode(dom);\n        }\n      }\n    };\n    traverseNode(this.el);\n  }\n  initView(data, showPool) {\n    //同时负责视图层的更新\n    this.domChange(this.showPool);\n  }\n  domChange(showPool) {\n    if (!data) {\n      showPool.forEach((view, dom) => {\n        switch (view.type) {\n          case \'v-if\':\n            view.comment = document.createComment(view.dataName || \'unknown\');\n            view.show ? \'\' : dom.parentNode.replaceChild(view.comment, dom);\n            break;\n          case \'v-show\':\n            view.show\n              ? (dom.style.display = \'block\')\n              : (dom.style.display = \'none\');\n            break;\n        }\n      });\n    }\n  }\n  initMethods() {\n    this.eventPool.forEach((data, dom) => {\n      dom.addEventListener(data.event, data.method.bind(this));\n    });\n  }\n}\n```\n### 执行方法，触发视图变化\n执行方法后，我们需要知道此时哪个数据变化了，而且要把变化的值给到对应的dom处理逻辑去处理。此时defineProperty的set方法就派上用场了，set方法可以监听到数据变化，我们可以在此方法中去触发视图的更新。又因为初始化视图和更新视图的逻辑差不多，就在domChange方法中处理了，通过data来判断此时是初始化还是更新操作。遍历视图池，找到该变量key值相等的dom元素进行处理。  \n完整代码： \n```javascript\nclass HyVue {\n  constructor(options) {\n    const { el, data, methods } = options;\n    this.el = document.querySelector(el);\n    this.data = data;\n    this.methods = methods;\n    this.showPool = new Map();\n    this.eventPool = new Map();\n    this.init();\n  }\n  init() {\n    //初始化数据，将data中的数据代理到this中\n    this.initData();\n    //初始化dom 往视图池和事件池中添加关联\n    this.initDom();\n    //初始化视图，根据视图池中的关联，决定元素的显隐，\n    this.initView(this.showPool);\n    //初始化方法，为事件池中关联元素绑定事件\n    this.initMethods();\n  }\n  initData() {\n    const dataKey = Object.keys(this.data);\n    for (const key of dataKey) {\n      Object.defineProperty(this, key, {\n        get: function () {\n          return this.data[key];\n        },\n        set: function (newValue) {\n          this.data[key] = newValue;\n          this.domChange(\n            {\n              key,\n              newValue,\n            },\n            this.showPool\n          );\n        },\n      });\n    }\n  }\n  initDom() {\n    const traverseNode = (node) => {\n      if (!node.childNodes.length) return;\n      const nodes = node.childNodes;\n      for (const dom of nodes) {\n        if (dom.nodeType === 1) {\n          const v_if = dom.getAttribute(\'v-if\');\n          const v_show = dom.getAttribute(\'v-show\');\n          const v_event = dom.getAttribute(\'@click\');\n          if (v_if) {\n            this.showPool.set(dom, {\n              type: \'v-if\',\n              show: this[v_if],\n              dataName: v_if,\n            });\n          } else if (v_show) {\n            this.showPool.set(dom, {\n              type: \'v-show\',\n              show: this[v_show],\n              dataName: v_show,\n            });\n          }\n          if (v_event) {\n            this.eventPool.set(dom, {\n              method: this.methods[v_event],\n              dataName: v_event,\n              event: \'click\',\n            });\n          }\n          traverseNode(dom);\n        }\n      }\n    };\n    traverseNode(this.el);\n  }\n  initView(data, showPool) {\n    //同时负责视图层的更新\n    this.domChange(null, this.showPool);\n  }\n  domChange(data, showPool) {\n    if (!data) {\n      showPool.forEach((view, dom) => {\n        switch (view.type) {\n          case \'v-if\':\n            view.comment = document.createComment(view.dataName || \'unknown\');\n            view.show ? \'\' : dom.parentNode.replaceChild(view.comment, dom);\n            break;\n          case \'v-show\':\n            view.show\n              ? (dom.style.display = \'block\')\n              : (dom.style.display = \'none\');\n            break;\n        }\n      });\n    } else {\n      showPool.forEach((view, dom) => {\n        if (view.dataName === data.key) {\n          switch (view.type) {\n            case \'v-if\':\n              data.newValue\n                ? view.comment.parentNode.replaceChild(dom, view.comment)\n                : dom.parentNode.replaceChild(view.comment, dom);\n              break;\n            case \'v-show\':\n              data.newValue\n                ? (dom.style.display = \'block\')\n                : (dom.style.display = \'none\');\n              break;\n          }\n          view.show = data.newValue;\n        }\n      });\n    }\n  }\n  initMethods() {\n    this.eventPool.forEach((data, dom) => {\n      dom.addEventListener(data.event, data.method.bind(this));\n    });\n  }\n}\n```\n','2022-07-11 18:00:31','2022-08-12 02:02:40',1,'talk is cheap\nshow me the code',0,NULL,0),(64,'JavaScript面向对象之组合-寄生式继承实现',1,'# 前言\n\n组合-寄生式继承是javascript对象继承中比较好的方案，它是在一系列继承方案改进的结果\n\n## 原型链继承\n\n```javascript\n// 父类: 公共属性和方法\nfunction Person() {\n  this.name = \"kun\"\n  this.friends = []\n}\n\nPerson.prototype.eating = function() {\n  console.log(this.name + \" eating\")\n}\n\n// 子类: 特有属性和方法\nfunction Student() {\n  this.sno = 111\n}\n\n//继承Student原型\nStudent.prototype = new Person()\n\n//在student原型上，也就是Person构造函数new出的对象上添加studying方法\nStudent.prototype.studying = function() {\n  console.log(this.name + \" studying\")\n}\n\nvar stu = new Student()\nobj.keys(stu) //无法遍历name\nstu.name //kun\nstu.studying() //kun studying\nstu.eating() // kun eating\n```\n\n该方案实现了原型继承，但也有以下弊端  \n\n1. `stu`对象无法遍历原型上的属性`name`\n2. 多个由`Student`创建的对象将共享`name`\n3. `Student`构造函数无法传递参数给`name`\n\n## 借用构造函数继承(组合继承)\n\n```javascript\n// 父类: 公共属性和方法\nfunction Person(name, age, friends) {\n  this.name = name\n  this.age = age\n  this.friends = friends\n}\n\n\nPerson.prototype.eating = function() {\n  console.log(this.name + \" eating\")\n}\n\n// 子类: 特有属性和方法\nfunction Student(name, age, friends, sno) {\n  //call将this传入Person构造函数中并调用，在Student构造函数存入父类属性\n  Person.call(this, name, age, friends)\n  //Student特有的属性\n  this.sno = 111\n}\n//继承Student原型,但此时会将无用属性name\\age\\friends赋给Student原型\nStudent.prototype = new Person()\n\n//在Student原型上，也就是Person构造函数new出的对象上添加studying方法\nStudent.prototype.studying = function() {\n  console.log(this.name + \" studying\")\n}\n\n```\n\n**借用构造函数继承**的方案解决了**原型链继承**中的诸多缺陷，比如借用构造函数继承中继承的属性可以遍历，创建多个子类 属性不共享，可以传递参数等。  \n该方案解决了原型继承的一些弊端，但也有以下缺陷  \n\n1. 此时会将父类中**无用属性**（name\\age\\friends）赋给子类原型\n2. 父类至少要调用两次\n\n## 寄生式继承\n\n```javascript\nvar personObj = {\n  running: function() {\n    console.log(\"running\")\n  }\n}\n\n//工厂函数\nfunction createStudent(name) {\n  //stu将其原型寄生在了personObj上 以此来实现继承\n  var stu = Object.create(personObj)\n  stu.name = name\n  stu.studying = function() {\n    console.log(\"studying~\")\n  }\n  return stu\n}\n```\n\n## 组合-寄生式继承\n\n```javascript\n//Object.create()的 polyfill\nfunction createObject(o) {\n  function Fn() {}\n  Fn.prototype = o\n  return new Fn()\n}\n//原型继承方法\nfunction inheritPrototype(SubType, SuperType) {\n  //创建一个proto指向父类原型的对象赋给子类原型\n  SubType.prototype = Object.create(SuperType.prototype)\n  //将子类原型的原本指向父类的constructor指向自己\n  Object.defineProperty(SubType.prototype, \"constructor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: SubType\n  })\n}\n//父类构造函数\nfunction Person(name, age, friends) {\n  this.name = name\n  this.age = age\n  this.friends = friends\n}\n\nPerson.prototype.eating = function() {\n  console.log(this.name + \" eating\")\n}\n\n//子类构造函数\nfunction Student(name, age, friends, sno, score) {\n  Person.call(this, name, age, friends)\n  this.sno = sno\n  this.score = score\n}\n//原型继承\ninheritPrototype(Student, Person)\n\nStudent.prototype.studying = function() {\n  console.log(\"studying\")\n}\nvar stu = new Student(\"kunkun\", 18, [\"kobe\"], 111, 55)\n\nstu.studying()\nstu.eating()\nconsole.log(stu.constructor.name)\n\n```\n\n该方案关键使用了`Object.create()`方法，传入父类原型后返回一个proto指向该原型的对象作为子类的原型，在创建子类对象时，执行`Person.call()`，将父类构造函数的属性也传入了子类。\n','2022-07-21 16:46:50','2022-08-24 01:47:14',1,'>组合-寄生式继承是javascript对象继承中比较好的方案，它是在一系列继承方案改进的结果',0,NULL,0),(65,'接下来要学的东西',1,'1. 升级https ✔\n2. 算法\n3. 小程序(简历里可以多搞一个项目)\n4. vue3+typescript项目\n5. 学习http\n6. 学习浏览器运行原理 ✔\n7. 阅读一系列源码\n8. 看rui-ui打包方式学习组件库的开发\n9. 看管理系统动态换肤技巧（懒加载）\n10. 学习vue源码组件是如何实现更新操作的\n11. 使用vue3+typescript搭建ssr','2022-07-27 15:27:51','2022-10-08 02:44:57',0,'1. 升级https\n2. 算法\n3. 小程序(简历里可以多搞一个项目)\n4. vue3+typescript项目\n5. 学习http\n6. 学习浏览器运行原理\n7. 阅读一系列源码',0,NULL,1),(66,'JavaScript中new的实现',1,'## 过程\n1. 首先创建了一个新的空对象\n2. 设置原型，将对象的原型设置为函数的 prototype 对象。\n3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\n## 代码实现\n```js\n    function newPolyfill () {\n			//创建新对象\n      let newObject = null,flag\n			//拿到构造函数\n      const constructor = Array.prototype.shift.call(arguments)\n      if(typeof constructor !== \'function\') {\n        console.err(\'error\')\n        return\n      }\n			//把对象的原型设置为函数的prototype对象\n      newObject = Object.create(constructor.prototype)\n			//把this指向新的对象，执行函数\n      const result = constructor.apply(newObject, arguments)\n			//判断构造函数是否返回引用对象，有则返回这个对象，没有则返回新的对象\n      flag = result&&(typeof result === \'function\' || typeof result === \'object\')\n      return flag ? result : newObject\n    }\n    function Foo(name) {\n      this.name = name\n    }\n    Foo.prototype.play = function() {\n      console.log(this.name + \'playing\');\n    }\n    const obj = newPolyfill(Foo,\'小明\')\n    obj.play()\n```\n运行效果  \n<img src=\"https://docs.hgyn23.cn/static/8d2b40f1f1710247be69765cd71adc4d\" width=\"600px\" height=\"auto\" alt=\"8d2b40f1f1710247be69765cd71adc4d\">','2022-08-09 10:09:10','2022-08-09 05:38:24',1,'1. 首先创建了一个新的空对象\n2. 设置原型，将对象的原型设置为函数的 prototype 对象。\n3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。',0,NULL,0),(67,'Vue2.x双向绑定模型实现',1,'### 响应性原理\nVue 利用的 Object.defineProperty()方法进行的数据劫持，利用 set、get 来检测数据的读写。MVVM 框架主要包含两个方面，数据变化更新视图，视图变化更新数据。\n每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。\n<img src=\"https://docs.hgyn23.cn/static/8d11592e24978f47bf42de6439c80230\" width=\"600px\" height=\"auto\" alt=\"8d11592e24978f47bf42de6439c80230\">\n### 代码实现\nhtml部分\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Document</title>\n</head>\n<body>\n  <div id=\"app\"></div>\n  <button id=\"btn\">click</button>\n  <script src=\"./index.js\">\n  </script>\n  <script>\n    const app = new Vue({\n      el: \'#app\',\n      data() {\n        return {\n          message: \'hello world\',\n          girlfriend: {\n            iKun: \'kunkun\'\n          }\n        }\n      },\n      methods: {\n        changeMessage() {\n          this.message = this.message ===  \'hello world\' ? \'你好 世界\' : \'hello world\'\n        }\n      }\n    })\n   let btn = document.querySelector(\'#btn\')\n    btn.addEventListener(\'click\',() => {\n    app.methods.changeMessage.call(app)\n   })\n  </script>\n</body>\n</html>\n```\njs部分\n```js\n//依赖收集器\nclass Dep {\n  constructor() {\n    this.deps = new Set();\n  }\n  addDep(dep) {\n    this.deps.add(dep);\n  }\n  notify() {\n    this.deps.forEach(dep => {\n      dep.update()\n    })\n  }\n}\n//监听器\nclass Observer {\n  constructor(data) {\n    this.data = data;\n    //递归添加响应性\n    this.walk(data);\n  }\n  walk(obj) {\n    //先不处理数组\n    if (Array.isArray(obj)) return;\n    Object.keys(obj).forEach((key) => {\n      this.defineReactive(key, obj[key], obj);\n    });\n  }\n  defineReactive(key, value, obj) {\n    if (typeof value === \'object\') observer(value);\n    const dep = new Dep();\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get() {\n        if (Dep.target) {\n          dep.addDep(Dep.target);\n          Object.defineProperty(obj, \'_Observer\', {\n            enumerable: false,\n            configurable: true,\n            writable: true,\n            value: dep,\n          });\n        }\n        return value;\n      },\n      set(newValue) {\n        if (value === newValue) return;\n        value = newValue;\n        dep.notify();\n      },\n    });\n  }\n}\n//订阅器\nclass Watcher {\n  constructor(vm, exp, cb) {\n    this.vm = vm;\n    this.exp = exp;\n    this.cb = cb;\n    this.get();\n  }\n  get() {\n    Dep.target = this;\n    this.vm.patch();\n    Dep.target = null;\n  }\n  update(dep) {\n    this.cb.call(this.vm);\n  }\n}\nfunction observer(value) {\n  if (typeof value !== \'object\') return;\n  new Observer(value);\n}\n//Vue类\nclass Vue {\n  constructor(options) {\n    this.el = document.querySelector(options.el);\n    this._data =\n      typeof options.data !== \'function\' ? options.data : options.data();\n    this.proxyToThis(this._data);\n    observer(this._data);\n    new Watcher(this, \'\', this.patch);\n    this.methods = options.methods;\n    console.log(this._data);\n  }\n  //模拟patch\n  patch() {\n    this.el.innerHTML = this.message;\n  }\n  proxyToThis(data) {\n    if (typeof data !== \'object\') return;\n    Object.keys(data).forEach((key) => {\n      Object.defineProperty(this, key, {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return data[key];\n        },\n        set(newValue) {\n          if (data[key] === newValue) return;\n          data[key] = newValue;\n        },\n      });\n    });\n  }\n}\n\n```','2022-08-10 11:41:03','2022-08-10 03:41:03',1,'> Vue 是利用的 Object.defineProperty()方法进行的数据劫持，利用 set、get 来检测数据的读写。MVVM 框架主要包含两个方面，数据变化更新视图，视图变化更新数据。',0,NULL,0),(68,'Vue2.6.10源码调试方法',1,'1. 克隆以下仓库\n\n```\ngit@github.com:vuejs/vue.git\n```\n\n2. 修改package.json\n\n```js\n{\n  \"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev --sourcemap\"\n}\n```\n\n完整流程\n\n```\ngit clone https://github.com/vuejs/vue.git\ncd vue\nnpm i\n# 在 dist/vue.js 最后一行追加一行 //# sourceMappingURL=vue.js.map\nnpm run dev\n# 新终端窗口\n# 根目录下 全局安装http-server(一行命令启动服务的工具)\nnpm i -g http-server\nhs -p 8100\n\n# 在examples 文件夹中把引用的vuejs的index.html 文件 vue.min.js 改为 vue.js\n# 或者把dist文件夹的 vue.min.js ，替换成npm run dev编译后的dist/vue.js \n\n# 浏览器打开 open http://localhost:8100/examples/\n\n# 打开控制面板 source 在左侧找到  src 目录 即vue.js源码文件 根据自己需求断点调试即可。\n\n```\n\n文章参考\n- [若川](https://lxchuan12.gitee.io/#%E8%8B%A5%E5%B7%9D%E8%AF%9A%E9%82%80%E4%BD%A0%E5%8A%A0%E5%89%8D%E7%AB%AF%E6%BA%90%E7%A0%81%E5%85%B1%E8%AF%BB%E7%BE%A4-%E9%95%BF%E6%9C%9F%E4%BA%A4%E6%B5%81%E5%AD%A6%E4%B9%A0)\n- [vue技术内幕](http://caibaojian.com/vue-design/art/)','2022-08-12 10:01:56','2022-08-26 00:43:55',1,'> 源码调试方法',0,NULL,0),(69,'> 面试问答汇总',1,'1. 你先坐下自我介绍吧\n面试官你好，我叫xxx，2021年毕业，接触前端已经有一年半的时间，目前以vue为主要技术栈。\n2. 你在上家公司主要负责哪块\n目前公司以vue为技术栈开发设备端webapp和后台管理系统，我主要负责后台管理系统的页面开发和组件封装，负责设备端模板切图以及webapp的开发和维护\n3. 公司项目遇到最困难的问题\n设备端主页模板的解析器开发，需要针对传来的JSON-token进行解析出不同的标签，并且为每个标签帮绑定不同的属性，且还要对指定标签进行事件绑定，还要做适配。和后台管理系统一些复杂需求的实现，比如对值班医生的排班情况我一次性要渲染最多30\\*10个级联选择器，这会导致页面极度卡顿，后通过小组评审将级联选择器更换为select，页面流畅度提高50%','2022-08-14 18:47:19','2022-08-14 10:47:19',0,'>',0,NULL,1),(70,'element源码解析之Container',1,'# index.js\n\n该文件夹定义了`install`方法，方法内部定义了`Container`全局组件，在Vue项目中使用`Vue.use(Container)`可单独安装，\n\n```js\nimport Container from \'./src/main\';\n\n/* istanbul ignore next */\nContainer.install = function(Vue) {\n  Vue.component(Container.name, Container);\n};\n\nexport default Container;\n\n```\n\n# Container组件\n\n组件整体比较简单，快速过一下\n\n```html\n<template>\n  <section class=\"el-container\" :class=\"{ \'is-vertical\': isVertical }\">\n    <slot></slot>\n  </section>\n</template>\n\n<script>\n  export default {\n    name: \'ElContainer\',\n\n    componentName: \'ElContainer\',\n\n    props: {\n      direction: String\n    },\n\n    computed: {\n      isVertical() {\n        if (this.direction === \'vertical\') {\n          return true;\n        } else if (this.direction === \'horizontal\') {\n          return false;\n        }\n        return this.$slots && this.$slots.default\n          ? this.$slots.default.some(vnode => {\n            const tag = vnode.componentOptions && vnode.componentOptions.tag;\n            return tag === \'el-header\' || tag === \'el-footer\';\n          })\n          : false;\n      }\n    }\n  };\n</script>\n```\n\n1. 使用了语义化标签`section`，开发中也要多使用语义化\n2. 接受插槽\n3. 可接受一个prop `direction`\n\n```js\nisVertical() {\n  if (this.direction === \'vertical\') {\n    return true;\n  } else if (this.direction === \'horizontal\') {\n    return false;\n  }\n  return this.$slots && this.$slots.default\n    ? this.$slots.default.some(vnode => {\n      const tag = vnode.componentOptions && vnode.componentOptions.tag;\n      return tag === \'el-header\' || tag === \'el-footer\';\n    })\n    : false;\n}\n```\n\n判断传入的值确定是否是`vertical`，值为空那就看有没有`el-header`或者`el-footer`来替换插槽，有的话就是true，没有就是false。`vertical`情况下内部会使用`flex-direction: column;`，否则使用`flex-direction: row;`\n','2022-08-18 18:58:51','2022-08-19 02:31:38',0,'>外层容器。当子元素中包含 <el-header> 或 <el-footer> 时，全部子元素会垂直上下排列，否则会水平左右排列。',0,NULL,0),(71,'Element组件源码解析之容器组件Aside',1,'# index.js\n\n该文件夹定义了`install`方法，方法内部定义了`Aside`全局组件，在Vue项目中使用`Vue.use(Aside)`可单独安装，\n\n```js\nimport Aside from \'./src/main\';\n\n/* istanbul ignore next */\nAside.install = function(Vue) {\n  Vue.component(Aside.name, Aside);\n};\n\nexport default Aside;\n\n```\n\n# Aside组件\n\n组件比较简单\n\n```html\n<template>\n  <aside class=\"el-aside\" :style=\"{ width }\">\n    <slot></slot>\n  </aside>\n</template>\n\n<script>\n  export default {\n    name: \'ElAside\',\n\n    componentName: \'ElAside\',\n\n    props: {\n      width: {\n        type: String,\n        default: \'300px\'\n      }\n    }\n  };\n</script>\n```\n\n1. 使用了语义化标签`aside`\n2. 如果父亲未传宽度，则使用组件默认宽度（300px）\n','2022-08-18 19:00:17','2022-08-20 19:22:28',0,'*侧边栏容器,用于布局*',0,NULL,0),(72,'element源码解析之容器组件Footer',1,'# index.js\n\n该文件夹定义了`install`方法，方法内部定义了`Header`全局组件，在Vue项目中使用`Vue.use(Header)`可单独安装，\n\n```js\nimport Footer from \'./src/main\';\n\n/* istanbul ignore next */\nFooter.install = function(Vue) {\n  Vue.component(Footer.name, Footer);\n};\n\nexport default Footer;\n\n```\n\n# 容器Footer组件\n\n组件比较简单\n\n```html\n<template>\n  <footer class=\"el-footer\" :style=\"{ height }\">\n    <slot></slot>\n  </footer>\n</template>\n\n<script>\n  export default {\n    name: \'ElFooter\',\n\n    componentName: \'ElFooter\',\n\n    props: {\n      height: {\n        type: String,\n        default: \'60px\'\n      }\n    }\n  };\n</script>\n\n```\n\n1. 使用了语义化标签`footer`\n2. 如果父亲未传高度，则使用组件默认高度（60px）\n','2022-08-18 19:00:48','2022-08-19 02:31:36',0,'>底栏容器。',0,NULL,0),(73,'element源码解析之容器组件Main',1,'# index.js\n\n该文件夹定义了`install`方法，方法内部定义了`Main`全局组件，在Vue项目中使用`Vue.use(Main)`可单独安装，\n\n```js\nimport Main from \'./src/main\';\n\n/* istanbul ignore next */\nMain.install = function(Vue) {\n  Vue.component(Main.name, Main);\n};\n\nexport default Main;\n\n```\n\n# 容器Main组件\n\n组件比较简单，没什么好说的\n\n```html\n<template>\n  <main class=\"el-main\">\n    <slot></slot>\n  </main>\n</template>\n\n<script>\n  export default {\n    name: \'ElMain\',\n    componentName: \'ElMain\'\n  };\n</script>\n\n```\n','2022-08-18 19:01:38','2022-08-19 02:31:28',0,'>主要区域容器。',0,NULL,0),(74,'element源码解析之容器组件Header',1,'# index.js\n\n该文件夹定义了`install`方法，方法内部定义了`Header`全局组件，在Vue项目中使用`Vue.use(Header)`可单独安装，\n\n```js\nimport Header from \'./src/main\';\n\n/* istanbul ignore next */\nHeader.install = function(Vue) {\n  Vue.component(Header.name, Header);\n};\n\nexport default Header;\n\n```\n\n# Header组件\n\n组件比较简单\n\n```html\n<template>\n  <header class=\"el-header\" :style=\"{ height }\">\n    <slot></slot>\n  </header>\n</template>\n\n<script>\n  export default {\n    name: \'ElHeader\',\n\n    componentName: \'ElHeader\',\n\n    props: {\n      height: {\n        type: String,\n        default: \'60px\'\n      }\n    }\n  };\n</script>\n```\n\n1. 使用了语义化标签`header`\n2. 如果父亲未传高度，则使用组件默认高度（60px）\n','2022-08-18 19:03:29','2022-08-19 02:31:36',0,'>顶栏容器。',0,NULL,0),(75,'Element组件源码解析之Alert',1,'# 安装方法\n\n该文件夹定义了`install`方法，方法内部定义了`Alert`全局组件，在Vue项目中使用`Vue.use(Alert)`可单独安装，\n\n```js\nimport Alert from \'./src/main\';\n\n/* istanbul ignore next */\nAlert.install = function(Vue) {\n  Vue.component(Alert.name, Alert);\n};\n\nexport default Alert;\n```\n\n# Alert组件\n\nAlert组件没有特别复杂的逻辑,大部分都是在样式上下的功夫\n\n1. 传入的`slot`有值的情况下优先显示`slot`中的title\n\n```html\n<span\n    class=\"el-alert__title\"\n    :class=\"[ isBoldTitle ]\"\n    v-if=\"title || $slots.title\"\n    ><slot name=\"title\"\n    >{{ title }}</slot>\n</span>\n\n```\n\n2. 下面这一段定义了插槽的使用方式，可以看出父亲没有传入默认的`slot`且`description`有值或者传入了默认的`slot`且`description`没有值时才会展示描述，其他情况不会展示。\n\n```html\n<p class=\"el-alert__description\" v-if=\"$slots.default && !description\">\n  <slot><slot>\n</p>\n<p class=\"el-alert__description\" v-if=\"description && !$slots.default\">\n  {{ description }}\n</p>\n\n```\n\n3. 对于一些字段的映射map可以放在script标签里，不要放在data中，避免被转成响应式消耗性能\n\n```html\n<script type=\"text/babel\">\n  const TYPE_CLASSES_MAP = {\n    \'success\': \'el-icon-success\',\n    \'warning\': \'el-icon-warning\',\n    \'error\': \'el-icon-error\'\n  };\n  export default {\n    name: \'ElAlert\',\n\n    data() {\n      return {\n        visible: true\n      };\n    },\n    //...省略代码\n    computed: {\n      iconClass() {\n        return TYPE_CLASSES_MAP[this.type] || \'el-icon-info\';\n      },\n    }\n  };\n</script>\n```\n\n4. Alert组件使用`v-show`控制元素显隐\n','2022-08-18 19:04:20','2022-08-20 20:22:48',1,'*用于页面中展示重要的提示信息。该文件夹定义了`install`方法，方法内部定义了`Alert`全局组件，在Vue项目中使用`Vue.use(Alert)`可单独安装，*',0,NULL,0),(76,'Element组件源码解析之Button',1,'# 安装方法\n\n该文件夹定义了`install`方法，方法内部定义了`ElButton`全局组件，在Vue项目中使用`Vue.use(ElButton)`可单独安装，\n\n```js\nimport ElButton from \'./src/button\';\n\n/* istanbul ignore next */\nElButton.install = function(Vue) {\n  Vue.component(ElButton.name, ElButton);\n};\n\nexport default ElButton;\n\n```\n\n# button-group按钮组\n\n按钮组 组件，用于嵌套按钮\n\n```html\n<template>\n  <div class=\"el-button-group\">\n    <slot></slot>\n  </div>\n</template>\n<script>\n  export default {\n    name: \'ElButtonGroup\'\n  };\n</script>\n\n```\n\n定义了一个插槽用于替换  \n外部的`el-button-group`多了两行样式,用于横向对齐\n\n```scss\n.el-button-group {\n    display: inline-block;\n    vertical-align: middle;\n}\n```\n\n# 按钮组件\n\n1.先来看点击事件\n\n```html\n<template>\n  <button\n    class=\"el-button\"\n    @click=\"handleClick\"\n  >\n  </button>\n</template>\n<script>\n  export default {\n    name: \'ElButton\',\n    methods: {\n      handleClick(evt) {\n        this.$emit(\'click\', evt);\n      }\n    }\n  };\n</script>\n\n\n```\n\n没什么特别的，就是原生`button`元素的点击事件，只是把`event`传出了\n\n2. 看下禁用逻辑\n\n```html\n<template>\n  <button\n    class=\"el-button\"\n    :disabled=\"buttonDisabled || loading\"\n    :class=\"[\n      type ? \'el-button--\' + type : \'\',\n      buttonSize ? \'el-button--\' + buttonSize : \'\',\n      {\n        \'is-disabled\': buttonDisabled,\n        \'is-loading\': loading,\n        \'is-plain\': plain,\n        \'is-round\': round,\n        \'is-circle\': circle\n      }\n    ]\"\n  >\n  </button>\n</template>\n<script>\n  export default {\n    name: \'ElButton\',\n    props: {\n      disabled: Boolean,\n    },\n    computed: {\n      buttonDisabled() {\n        return this.$options.propsData.hasOwnProperty(\'disabled\') ? this.disabled : (this.elForm || {}).disabled;\n      }\n    },\n  };\n</script>\n\n```\n\n`computed`选项中有这么一段逻辑，它判断是否禁用的逻辑很奇怪是不是？`this.$options.propsData.hasOwnProperty(\'disabled\')`这行代码的意思是判断`disabled`属性是否出现在`propsData`对象中，那这个`propsData`是什么呢？他是记录组件标签上显式使用的属性。换句话说，这段代码其实是判断用户是否主动传入了`disabled`属性，否则使用`elForm`实例的`disabled`属性，这段代码是在`2.15.7`版本被修复的。\n\n```js\nbuttonDisabled() {\n        return this.$options.propsData.hasOwnProperty(\'disabled\') ? this.disabled : (this.elForm || {}).disabled;\n      }\n```\n\n在`2.15.6`版本，`elbutton`实例的`disabled`靠`props`确定也就是这段代码\n\n```js\nbuttonDisabled() {\n        return this.disabled || (this.elForm || {}).disabled;\n      }\n```\n\n这种情况下如果通过`props`传入的`disabled`为`false`，那么会使用`elform`实例上的`disabled`，这样的话，`button`按钮就被`elform`控制了，与开发者预期的情况不符（奇怪的设计）。\n\n3. 看下样式部分\n\n```html\n<template>\n  <button\n    class=\"el-button\"\n    :type=\"nativeType\"\n    :class=\"[\n      type ? \'el-button--\' + type : \'\',\n      buttonSize ? \'el-button--\' + buttonSize : \'\',\n      {\n        \'is-disabled\': buttonDisabled,\n        \'is-loading\': loading,\n        \'is-plain\': plain,\n        \'is-round\': round,\n        \'is-circle\': circle\n      }\n    ]\"\n  >\n  </button>\n</template>\n<script>\n  export default {\n    name: \'ElButton\',\n\n    inject: {\n      elForm: {\n        default: \'\'\n      },\n      elFormItem: {\n        default: \'\'\n      }\n    },\n\n    props: {\n      type: {\n        type: String,\n        default: \'default\'\n      },\n      size: String,\n      icon: {\n        type: String,\n        default: \'\'\n      },\n      nativeType: {\n        type: String,\n        default: \'button\'\n      },\n      loading: Boolean,\n      disabled: Boolean,\n      plain: Boolean,\n      autofocus: Boolean,\n      round: Boolean,\n      circle: Boolean\n    },\n\n    computed: {\n      _elFormItemSize() {\n        return (this.elFormItem || {}).elFormItemSize;\n      },\n      buttonSize() {\n        return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;\n      },\n    },\n  };\n</script>\n\n```\n\n现在看下计算`size`的逻辑，先判断通过`props`传入的`size`，如果没有传就用`el-form-item`的`size`,最后使用全局`$ELEMENT`的`size`\n\n```js\n buttonSize() {\n        return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;\n      },\n```\n\n同时组件支持使用`nativeType`指定button按钮原生的`type`  \n它也使用了大量动态样式，通过`props`自定义传入\n`el-button`的默认样式如下\n\n```scss\n.el-button {\n    display: inline-block;\n    line-height: 1;\n    white-space: nowrap;\n    cursor: pointer;\n    background: #fff;\n    border: 1px solid #dcdfe6;\n    color: #606266;\n    -webkit-appearance: none;\n    text-align: center;\n    box-sizing: border-box;\n    outline: none;\n    margin: 0;\n    transition: .1s;\n    font-weight: 500;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    padding: 12px 20px;\n    font-size: 14px;\n    border-radius: 4px;\n}\n```\n\n4. 看下插槽部分\n\n```html\n    <span v-if=\"$slots.default\"><slot></slot></span>\n```\n\n使用了默认插槽，其中的内容可以自定义\n','2022-08-18 19:05:11','2022-08-20 20:22:02',1,'*常用的操作按钮。该文件夹定义了`install`方法，方法内部定义了`ElButton`全局组件，在Vue项目中使用`Vue.use(ElButton)`可单独安装，*',0,NULL,0),(77,'Element源码解析之Icon',1,'# 安装方法\n\n该文件夹定义了`install`方法，方法内部定义了`ElIcon`全局组件，在Vue项目中使用`Vue.use(ElIcon)`可单独安装，\n\n```js\nimport ElIcon from \'./src/icon.vue\';\n\n/* istanbul ignore next */\nElIcon.install = function(Vue) {\n  Vue.component(ElIcon.name, ElIcon);\n};\n\nexport default ElIcon;\n\n\n```\n\n# Icon组件\n\n组件比较简单\n\n```html\n<template>\n  <i :class=\"\'el-icon-\' + name\"></i>\n</template>\n\n<script>\n  export default {\n    name: \'ElIcon\',\n\n    props: {\n      name: String\n    }\n  };\n</script>\n```\n\n主要是这一句\n\n```html\n<i :class=\"\'el-icon-\' + name\"></i>\n```\n\n一般使用字体图标都会先引入`font-class`，然后再写`font-class-name`的名称，也就是要写两个类，写多了还是很烦的。\n为什么在element里只要传入一个icon图标名就能切换不同的字体图标呢？这个是怎么实现的？  \n答案就在这里\n\n```scss\n[class^=\"el-icon-\"], [class*=\" el-icon-\"] {\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: \'element-icons\' !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n  vertical-align: baseline;\n  display: inline-block;\n\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n```\n\nelement使用了scss匹配所有包含`el-icon-`的类名，匹配到的类名都将作用这块css\n','2022-08-18 19:06:25','2022-08-20 20:20:51',1,'*提供了一套常用的图标集合。该文件夹定义了`install`方法，方法内部定义了`ElIcon`全局组件，在Vue项目中使用`Vue.use(ElIcon)`可单独安装，*',0,NULL,0),(78,'Element组件源码解析之Input',1,'# 安装方法\n\n该文件夹定义了`install`方法，方法内部定义了`ElInput`全局组件，在Vue项目中使用`Vue.use(ElInput)`可单独安装，\n\n```js\nimport ElInput from \'./src/input\';\n\n/* istanbul ignore next */\nElInput.install = function(Vue) {\n  Vue.component(ElInput.name, ElInput);\n};\n\nexport default ElInput;\n\n\n```\n\n# Input组件\n\n先看下简化后的html结构\n\n```html\n<template>\n  <div>\n    <!-- type不等于文本域的情况下 -->\n    <template v-if=\"type !== \'textarea\'\">\n      <!-- 前置元素 一般用来写一些按钮或者标签-->\n      <div class=\"el-input-group__prepend\" v-if=\"$slots.prepend\">\n        <slot name=\"prepend\"></slot>\n      </div>\n      <input\n        v-if=\"type !== \'textarea\'\"\n      >\n      <!-- 前置内容 用来增加头部图标 -->\n      <span class=\"el-input__prefix\" v-if=\"$slots.prefix || prefixIcon\">\n        <slot name=\"prefix\"></slot>\n        <i class=\"el-input__icon\" v-if=\"prefixIcon\"\">\n        </i>\n      </span>\n      <!-- 后置内容 -->\n      <span\n        class=\"el-input__suffix\"\n        v-if=\"getSuffixVisible()\">\n        <span class=\"el-input__suffix-inner\">\n          <!-- 后置内容，用于增加尾部图标 -->\n          <template v-if=\"!showClear || !showPwdVisible || !isWordLimitVisible\">\n            <slot name=\"suffix\"></slot>\n            <i class=\"el-input__icon\" v-if=\"suffixIcon\"></i>\n          </template>\n          <i v-if=\"showClear\"\n            class=\"el-input__icon el-icon-circle-close el-input__clear\"></i>\n          <i v-if=\"showPwdVisible\"\n            class=\"el-input__icon el-icon-view el-input__clear\"></i>\n          <span v-if=\"isWordLimitVisible\" class=\"el-input__count\">\n            <span class=\"el-input__count-inner\">\n              {{ textLength }}/{{ upperLimit }}\n            </span>\n          </span>\n        </span>\n        <i class=\"el-input__icon\" v-if=\"validateState\">\n        </i>\n      </span>\n      <!-- 后置元素 一般用来写一些按钮或者标签 -->\n      <div class=\"el-input-group__append\" v-if=\"$slots.append\">\n        <slot name=\"append\"></slot>\n      </div>\n    </template>\n    <textarea v-else>\n    </textarea>\n    <span v-if=\"isWordLimitVisible && type === \'textarea\'\" class=\"el-input__count\">{{ textLength }}/{{ upperLimit }}</span>\n  </div>\n</template>\n```\n\n整体结构分为**前置元素 -> 前置内容 -> 主要内容 -> 后置内容 -> 后置元素**,也就是**标签-图标-内容-图标-标签**的结构,使用这个结构的前提是类型不为文本域。\n\n完整模板代码\n\n```html\n<template>\n  <div :class=\"[\n    type === \'textarea\' ? \'el-textarea\' : \'el-input\',\n    inputSize ? \'el-input--\' + inputSize : \'\',\n    {\n      \'is-disabled\': inputDisabled,\n      \'is-exceed\': inputExceed,\n      \'el-input-group\': $slots.prepend || $slots.append,\n      \'el-input-group--append\': $slots.append,\n      \'el-input-group--prepend\': $slots.prepend,\n      \'el-input--prefix\': $slots.prefix || prefixIcon,\n      \'el-input--suffix\': $slots.suffix || suffixIcon || clearable || showPassword\n    }\n    ]\"\n    @mouseenter=\"hovering = true\"\n    @mouseleave=\"hovering = false\"\n  >\n    <template v-if=\"type !== \'textarea\'\">\n      <!-- 前置元素 -->\n      <div class=\"el-input-group__prepend\" v-if=\"$slots.prepend\">\n        <slot name=\"prepend\"></slot>\n      </div>\n      <input\n        :tabindex=\"tabindex\"\n        v-if=\"type !== \'textarea\'\"\n        class=\"el-input__inner\"\n        v-bind=\"$attrs\"\n        :type=\"showPassword ? (passwordVisible ? \'text\': \'password\') : type\"\n        :disabled=\"inputDisabled\"\n        :readonly=\"readonly\"\n        :autocomplete=\"autoComplete || autocomplete\"\n        ref=\"input\"\n        @compositionstart=\"handleCompositionStart\"\n        @compositionupdate=\"handleCompositionUpdate\"\n        @compositionend=\"handleCompositionEnd\"\n        @input=\"handleInput\"\n        @focus=\"handleFocus\"\n        @blur=\"handleBlur\"\n        @change=\"handleChange\"\n        :aria-label=\"label\"\n      >\n      <!-- 前置内容 -->\n      <span class=\"el-input__prefix\" v-if=\"$slots.prefix || prefixIcon\">\n        <slot name=\"prefix\"></slot>\n        <i class=\"el-input__icon\"\n           v-if=\"prefixIcon\"\n           :class=\"prefixIcon\">\n        </i>\n      </span>\n      <!-- 后置内容 -->\n      <span\n        class=\"el-input__suffix\"\n        v-if=\"getSuffixVisible()\">\n        <span class=\"el-input__suffix-inner\">\n          <template v-if=\"!showClear || !showPwdVisible || !isWordLimitVisible\">\n            <slot name=\"suffix\"></slot>\n            <i class=\"el-input__icon\"\n              v-if=\"suffixIcon\"\n              :class=\"suffixIcon\">\n            </i>\n          </template>\n          <i v-if=\"showClear\"\n            class=\"el-input__icon el-icon-circle-close el-input__clear\"\n            @mousedown.prevent\n            @click=\"clear\"\n          ></i>\n          <i v-if=\"showPwdVisible\"\n            class=\"el-input__icon el-icon-view el-input__clear\"\n            @click=\"handlePasswordVisible\"\n          ></i>\n          <span v-if=\"isWordLimitVisible\" class=\"el-input__count\">\n            <span class=\"el-input__count-inner\">\n              {{ textLength }}/{{ upperLimit }}\n            </span>\n          </span>\n        </span>\n        <i class=\"el-input__icon\"\n          v-if=\"validateState\"\n          :class=\"[\'el-input__validateIcon\', validateIcon]\">\n        </i>\n      </span>\n      <!-- 后置元素 -->\n      <div class=\"el-input-group__append\" v-if=\"$slots.append\">\n        <slot name=\"append\"></slot>\n      </div>\n    </template>\n    <textarea\n      v-else\n      :tabindex=\"tabindex\"\n      class=\"el-textarea__inner\"\n      @compositionstart=\"handleCompositionStart\"\n      @compositionupdate=\"handleCompositionUpdate\"\n      @compositionend=\"handleCompositionEnd\"\n      @input=\"handleInput\"\n      ref=\"textarea\"\n      v-bind=\"$attrs\"\n      :disabled=\"inputDisabled\"\n      :readonly=\"readonly\"\n      :autocomplete=\"autoComplete || autocomplete\"\n      :style=\"textareaStyle\"\n      @focus=\"handleFocus\"\n      @blur=\"handleBlur\"\n      @change=\"handleChange\"\n      :aria-label=\"label\"\n    >\n    </textarea>\n    <span v-if=\"isWordLimitVisible && type === \'textarea\'\" class=\"el-input__count\">{{ textLength }}/{{ upperLimit }}</span>\n  </div>\n</template>\n```\n\n## 基本用法\n\n```html\n<el-input v-model=\"input\" placeholder=\"请输入内容\"></el-input>\n\n<script>\nexport default {\n  data() {\n    return {\n      input: \'\'\n    }\n  }\n}\n</script>\n```\n\n使用v-model绑定元素，他是如何设置值的呢？\n\n```html\n<template>\n  <div>\n      <input\n        ref=\"input\"\n        @change=\"handleChange\"\n        @input=\"handleInput\"\n      >\n  </div>\n</template>\n<script>\n  import emitter from \'element-ui/src/mixins/emitter\';\n  import Migrating from \'element-ui/src/mixins/migrating\';\n  import calcTextareaHeight from \'./calcTextareaHeight\';\n  import merge from \'element-ui/src/utils/merge\';\n  import {isKorean} from \'element-ui/src/utils/shared\';\n\n  export default {\n    name: \'ElInput\',\n\n    componentName: \'ElInput\',\n\n    mixins: [emitter, Migrating],\n    inheritAttrs: false,\n    props: {\n      value: [String, Number],\n    },\n    computed: {\n     nativeInputValue() {\n        return this.value === null || this.value === undefined ? \'\' : String(this.value);\n      },\n    },\n    watch: {\n      value(val) {\n        this.$nextTick(this.resizeTextarea);\n        if (this.validateEvent) {\n          this.dispatch(\'ElFormItem\', \'el.form.change\', [val]);\n        }\n      },\n      // native input value is set explicitly\n      // do not use v-model / :value in template\n      // see: https://github.com/ElemeFE/element/issues/14521\n      nativeInputValue() {\n        this.setNativeInputValue();\n      },\n    },\n\n    methods: {\n      setNativeInputValue() {\n        //拿到input的dom元素\n        const input = this.getInput();\n        if (!input) return;\n        if (input.value === this.nativeInputValue) return;\n        //设置值\n        input.value = this.nativeInputValue;\n      },\n      //用户输入时触发\n      handleInput(event) {\n\n        //isComposing为真时 input处于拼音合成阶段，此时不应该有任何操作\n        if (this.isComposing) return;\n\n        if (event.target.value === this.nativeInputValue) return;\n        //发射input事件\n        this.$emit(\'input\', event.target.value);\n\n        // ensure native input value is controlled\n        // see: https://github.com/ElemeFE/element/issues/12850\n        this.$nextTick(this.setNativeInputValue);\n      },\n      //input失去焦点时或者用户按下回车时触发\n      handleChange(event) {\n        this.$emit(\'change\', event.target.value);\n      },\n      getInput() {\n        return this.$refs.input || this.$refs.textarea;\n      },\n    },\n\n    created() {\n      this.$on(\'inputSelect\', this.select);\n    },\n\n    mounted() {\n      //该方法用于设置input的值\n      this.setNativeInputValue();\n    },\n\n    updated() {\n      this.$nextTick(this.updateIconOffset);\n    }\n  };\n</script>\n\n```\n\n首先要知道，使用v-model绑定一个组件时，组件要想更新值，就得使用`$emit(\'input\',val)`通过input事件携带最新的参数传出去。下面开始组件基本输入输出流程  \n\n  1. 组件挂载后，调用`setNativeInputValue`方法设置最新的值，也就是计算属性中的  `nativeInputValue`，该值会判断是否为`null`或者`undefined`,所以如果初始值是这两种值传入也是  没问题的。\n  2. 用户输入时，触发`handleInput`事件，将最新的值以`input`事件的方式吧最新的值传出，接着父组件绑定值更新，触发子组件对`value`的`watch`方法，执行内部逻辑。\n\n## 输入字数限制\n\n来看下代码结构\n\n```html\n<template>\n  <div>\n    <template v-if=\"type !== \'textarea\'\">\n      <!-- 前置元素 -->\n      <div class=\"el-input-group__prepend\" v-if=\"$slots.prepend\">\n        <slot name=\"prepend\"></slot>\n      </div>\n      <input v-if=\"type !== \'textarea\'\" class=\"el-input__inner\">\n      <!-- 前置内容 -->\n      <span class=\"el-input__prefix\" v-if=\"$slots.prefix || prefixIcon\">\n        <slot name=\"prefix\"></slot>\n        <i class=\"el-input__icon\"\n           v-if=\"prefixIcon\"\n           :class=\"prefixIcon\">\n        </i>\n      </span>\n      <!-- 后置内容 -->\n      <span\n        class=\"el-input__suffix\"\n        v-if=\"getSuffixVisible()\">\n        <span class=\"el-input__suffix-inner\">\n          <!-- 后置内容没有眼睛 字数限制 重置图标的情况下才显示后置内容，也就是图标 -->\n          <template v-if=\"!showClear || !showPwdVisible || !isWordLimitVisible\">\n            <slot name=\"suffix\"></slot>\n            <i class=\"el-input__icon\" v-if=\"suffixIcon\">\n            </i>\n          </template>\n          <i v-if=\"showClear\"\n            class=\"el-input__icon el-icon-circle-close el-input__clear\"></i>\n          <i v-if=\"showPwdVisible\"\n            class=\"el-input__icon el-icon-view el-input__clear\"\n            @click=\"handlePasswordVisible\"\n          ></i>\n        <!-- 显示字数限制 -->\n          <span v-if=\"isWordLimitVisible\" class=\"el-input__count\">\n            <span class=\"el-input__count-inner\">\n              {{ textLength }}/{{ upperLimit }}\n            </span>\n          </span>\n        </span>\n        <i class=\"el-input__icon\"\n          v-if=\"validateState\"\n          :class=\"[\'el-input__validateIcon\', validateIcon]\">\n        </i>\n      </span>\n      <!-- 后置元素 -->\n      <div class=\"el-input-group__append\" v-if=\"$slots.append\">\n        <slot name=\"append\"></slot>\n      </div>\n    </template>\n    <textarea\n      v-else\n      class=\"el-textarea__inner\"\n    >\n    </textarea>\n    <!-- 文本域也可以显示字数限制，只能限制这个 -->\n    <span v-if=\"isWordLimitVisible && type === \'textarea\'\" class=\"el-input__count\">{{ textLength }}/{{ upperLimit }}</span>\n  </div>\n</template>\n<script>\n  export default {\n    name: \'ElInput\',\n\n    componentName: \'ElInput\',\n    data() {\n      return {\n        textareaCalcStyle: {},\n        hovering: false,\n        focused: false,\n        isComposing: false,\n        passwordVisible: false\n      };\n    },\n\n    props: {\n      readonly: Boolean,\n      type: {\n        type: String,\n        default: \'text\'\n      },\n      showPassword: {\n        type: Boolean,\n        default: false\n      },\n      showWordLimit: {\n        type: Boolean,\n        default: false\n      },\n    },\n\n    computed: {\n      inputDisabled() {\n        return this.disabled || (this.elForm || {}).disabled;\n      },\n      isWordLimitVisible() {\n        //字数限制显隐\n        return this.showWordLimit &&\n        //传入最大值才有效\n          this.$attrs.maxlength &&\n          //只在 type = \"text\" 或 type = \"textarea\" 时有效\n          (this.type === \'text\' || this.type === \'textarea\') &&\n          //非禁用状态\n          !this.inputDisabled &&\n          //非只读\n          !this.readonly &&\n          //非showpassword\n          !this.showPassword;\n      },\n      upperLimit() {\n        return this.$attrs.maxlength;\n      },\n      textLength() {\n        //如果输入是数字，转成字符串统计个数\n        if (typeof this.value === \'number\') {\n          return String(this.value).length;\n        }\n        //有值取值 没值取0\n        return (this.value || \'\').length;\n      },\n      inputExceed() {\n        // show exceed style if length of initial value greater then maxlength\n        return this.isWordLimitVisible &&\n          (this.textLength > this.upperLimit);\n      }\n    },\n    methods: {\n      getSuffixVisible() {\n        return this.$slots.suffix ||\n          this.suffixIcon ||\n          this.showClear ||\n          this.showPassword ||\n          this.isWordLimitVisible ||\n          (this.validateState && this.needStatusIcon);\n      }\n    },\n  };\n</script>\n\n```\n\nelinput的输入字数显示是使用原生maxlength和minlength决定的，使用`v-bind:$attrs`就可以取到未在props定义的属性对象其中包含用户自定义的`maxlength`和`minlength`。\n\n## 拼音合成逻辑\n\n是否注意到这一段代码\n\n```html\n<template>\n  <div>\n    <template v-if=\"type !== \'textarea\'\">\n      <!-- 前置元素 -->\n      <div class=\"el-input-group__prepend\" v-if=\"$slots.prepend\">\n        <slot name=\"prepend\"></slot>\n      </div>\n      <input\n        v-if=\"type !== \'textarea\'\"\n        @compositionstart=\"handleCompositionStart\"\n        @compositionupdate=\"handleCompositionUpdate\"\n        @compositionend=\"handleCompositionEnd\"\n      >\n    </template>\n    <textarea\n      v-else\n      @compositionstart=\"handleCompositionStart\"\n      @compositionupdate=\"handleCompositionUpdate\"\n      @compositionend=\"handleCompositionEnd\"\n    >\n    </textarea>\n  </div>\n</template>\n<script>\n  export default {\n    methods: {\n      handleCompositionStart(event) {\n        this.$emit(\'compositionstart\', event);\n        this.isComposing = true;\n      },\n      handleCompositionUpdate(event) {\n        this.$emit(\'compositionupdate\', event);\n        const text = event.target.value;\n        const lastCharacter = text[text.length - 1] || \'\';\n        this.isComposing = !isKorean(lastCharacter);\n      },\n      handleCompositionEnd(event) {\n        this.$emit(\'compositionend\', event);\n        if (this.isComposing) {\n          this.isComposing = false;\n          this.handleInput(event);\n        }\n      },\n      handleInput(event) {\n        // should not emit input during composition\n        // see: https://github.com/ElemeFE/element/issues/10516\n        if (this.isComposing) return;\n\n        // hack for https://github.com/ElemeFE/element/issues/8548\n        // should remove the following line when we don\'t support IE\n        if (event.target.value === this.nativeInputValue) return;\n\n        this.$emit(\'input\', event.target.value);\n\n        // ensure native input value is controlled\n        // see: https://github.com/ElemeFE/element/issues/12850\n        this.$nextTick(this.setNativeInputValue);\n      },\n    },\n  };\n</script>\n\n```\n\n>DOM 接口 CompositionEvent 表示用户间接输入文本（如使用输入法）时发生的事件。此接口的常用事件有compositionstart, compositionupdate 和 compositionend ——[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/CompositionEvent)\n\n- `compositionstart`，当用户使用拼音输入法开始输入汉字时，这个事件就会被触发\n- `compositionupdate`，当用户使用拼音输入法键入字母时，这个事件就会被触发\n- `compositionend`，当用户使用拼音输入法组成完成时，这个事件就会被触发\n\nelement对拼音输入事件做出了处理，这样做的目的是为了防止拼音输入过程中不断触发`value`更新，但是这些更新是不必要的更新。\n','2022-08-18 19:07:26','2022-08-20 20:21:08',1,'*通过鼠标或键盘输入字符,该文件夹定义了`install`方法，方法内部定义了`ElInput`全局组件，在Vue项目中使用`Vue.use(ElInput)`可单独安装，*',0,NULL,0),(79,'Element组件源码解析之Link',1,'# 安装方法\n\n该文件夹定义了`install`方法，方法内部定义了`Link`全局组件，在Vue项目中使用`Vue.use(Link)`可单独安装，\n\n```js\nimport Link from \'./src/main\';\n\n/* istanbul ignore next */\nLink.install = function(Vue) {\n  Vue.component(Link.name, Link);\n};\n\nexport default Link;\n\n```\n\n# Link组件\n\n先来看整体代码\n\n```html\n<template>\n  <a\n    :class=\"[\n      \'el-link\',\n      type ? `el-link--${type}` : \'\',\n      disabled && \'is-disabled\',\n      underline && !disabled && \'is-underline\'\n    ]\"\n    :href=\"disabled ? null : href\"\n    v-bind=\"$attrs\"\n    @click=\"handleClick\"\n  >\n\n    <i :class=\"icon\" v-if=\"icon\"></i>\n\n    <span v-if=\"$slots.default\" class=\"el-link--inner\">\n      <slot></slot>\n    </span>\n\n    <template v-if=\"$slots.icon\"><slot v-if=\"$slots.icon\" name=\"icon\"></slot></template>\n  </a>\n</template>\n\n<script>\n\nexport default {\n  name: \'ElLink\',\n\n  props: {\n    type: {\n      type: String,\n      default: \'default\'\n    },\n    underline: {\n      type: Boolean,\n      default: true\n    },\n    disabled: Boolean,\n    href: String,\n    icon: String\n  },\n\n  methods: {\n    handleClick(event) {\n      if (!this.disabled) {\n        if (!this.href) {\n          this.$emit(\'click\', event);\n        }\n      }\n    }\n  }\n};\n</script>\n\n```\n\n整体代码并不复杂，就是a标签上下文章，分点看\n\n1. 先看a标签上干了什么\n\n```html\n<template>\n  <a\n    :class=\"[\n      \'el-link\',\n      type ? `el-link--${type}` : \'\',\n      disabled && \'is-disabled\',\n      underline && !disabled && \'is-underline\'\n    ]\"\n    :href=\"disabled ? null : href\"\n    v-bind=\"$attrs\"\n    @click=\"handleClick\"\n  >\n  </a>\n</template>\n\n<script>\n\nexport default {\n  name: \'ElLink\',\n\n  props: {\n    type: {\n      type: String,\n      default: \'default\'\n    },\n    underline: {\n      type: Boolean,\n      default: true\n    },\n    disabled: Boolean,\n    href: String,\n    icon: String\n  },\n\n  methods: {\n    handleClick(event) {\n      if (!this.disabled) {\n        if (!this.href) {\n          this.$emit(\'click\', event);\n        }\n      }\n    }\n  }\n};\n</script>\n```\n\n支持点击事件\n\n```js\nhandleClick(event) {\n      if (!this.disabled) {\n        if (!this.href) {\n          this.$emit(\'click\', event);\n        }\n      }\n    }\n```\n\n所以两个点，如果要保证点击事件有效，那么一是确定其不在禁用状态，二是确定传入的href存在。\n\n支持动态样式\n\n```html\n  <a\n    :class=\"[\n      \'el-link\',\n      type ? `el-link--${type}` : \'\',\n      disabled && \'is-disabled\',\n      underline && !disabled && \'is-underline\'\n    ]\"\n    :href=\"disabled ? null : href\"\n    v-bind=\"$attrs\"\n    @click=\"handleClick\"\n  >\n  </a>\n```\n\n这里有个知识点，在封装高级组件的时候，可以使用`v-bind=\"$attrs\"`将父组件的非 props 属性传递给子组件 input。\n\n2. 看下其余的模板\n\n```html\n\n    <i :class=\"icon\" v-if=\"icon\"></i>\n\n    <span v-if=\"$slots.default\" class=\"el-link--inner\">\n      <slot></slot>\n    </span>\n\n    <template v-if=\"$slots.icon\"><slot v-if=\"$slots.icon\" name=\"icon\"></slot></template>\n```\n\n定义了一个默认插槽用于填写自定义内容，同时也定义了一个具名插槽`$slots.icon`用于指定`icon`\n所以可以这么用  \n\n```html\n    <el-link icon=\"el-icon-edit\"><i slot=\"icon\" class=\"el-icon-view\"></i>链接</el-link>\n```\n','2022-08-18 19:09:00','2022-08-20 20:21:26',1,'*文字超链接,该文件夹定义了`install`方法，方法内部定义了`Link`全局组件，在Vue项目中使用`Vue.use(Link)`可单独安装*',0,NULL,0),(80,'Element组件源码解析之Radio',1,'# 安装方法\n\n该文件夹定义了`install`方法，方法内部定义了`Radio`全局组件，在Vue项目中使用`Vue.use(Radio)`可单独安装，这里提供了`RadioButton`和`RadioGroup`组件单独导出的方法，其实他们都生在一个文件夹。\n\n```js\nimport Radio from \'./src/radio\';\n\n/* istanbul ignore next */\nRadio.install = function(Vue) {\n  Vue.component(Radio.name, Radio);\n};\n\nexport default Radio;\n\n\n```\n\n# 单选框组件radio\n\n先来看整体代码\n\n```html\n<template>\n  <label\n    class=\"el-radio\"\n    :class=\"[\n      border && radioSize ? \'el-radio--\' + radioSize : \'\',\n      { \'is-disabled\': isDisabled },\n      { \'is-focus\': focus },\n      { \'is-bordered\': border },\n      { \'is-checked\': model === label }\n    ]\"\n    role=\"radio\"\n    :aria-checked=\"model === label\"\n    :aria-disabled=\"isDisabled\"\n    :tabindex=\"tabIndex\"\n    @keydown.space.stop.prevent=\"model = isDisabled ? model : label\"\n  >\n    <span class=\"el-radio__input\"\n      :class=\"{\n        \'is-disabled\': isDisabled,\n        \'is-checked\': model === label\n      }\"\n    >\n      <span class=\"el-radio__inner\"></span>\n      <input\n        ref=\"radio\"\n        class=\"el-radio__original\"\n        :value=\"label\"\n        type=\"radio\"\n        aria-hidden=\"true\"\n        v-model=\"model\"\n        @focus=\"focus = true\"\n        @blur=\"focus = false\"\n        @change=\"handleChange\"\n        :name=\"name\"\n        :disabled=\"isDisabled\"\n        tabindex=\"-1\"\n        autocomplete=\"off\"\n      >\n    </span>\n    <span class=\"el-radio__label\" @keydown.stop>\n      <slot></slot>\n      <template v-if=\"!$slots.default\">{{label}}</template>\n    </span>\n  </label>\n</template>\n<script>\n  import Emitter from \'element-ui/src/mixins/emitter\';\n\n  export default {\n    name: \'ElRadio\',\n\n    mixins: [Emitter],\n\n    inject: {\n      elForm: {\n        default: \'\'\n      },\n\n      elFormItem: {\n        default: \'\'\n      }\n    },\n\n    componentName: \'ElRadio\',\n\n    props: {\n      value: {},\n      label: {},\n      disabled: Boolean,\n      name: String,\n      border: Boolean,\n      size: String\n    },\n\n    data() {\n      return {\n        focus: false\n      };\n    },\n    computed: {\n      isGroup() {\n        let parent = this.$parent;\n        while (parent) {\n          if (parent.$options.componentName !== \'ElRadioGroup\') {\n            parent = parent.$parent;\n          } else {\n            this._radioGroup = parent;\n            return true;\n          }\n        }\n        return false;\n      },\n      model: {\n        get() {\n          return this.isGroup ? this._radioGroup.value : this.value;\n        },\n        set(val) {\n          if (this.isGroup) {\n            this.dispatch(\'ElRadioGroup\', \'input\', [val]);\n          } else {\n            this.$emit(\'input\', val);\n          }\n          this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);\n        }\n      },\n      _elFormItemSize() {\n        return (this.elFormItem || {}).elFormItemSize;\n      },\n      radioSize() {\n        const temRadioSize = this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;\n        return this.isGroup\n          ? this._radioGroup.radioGroupSize || temRadioSize\n          : temRadioSize;\n      },\n      isDisabled() {\n        return this.isGroup\n          ? this._radioGroup.disabled || this.disabled || (this.elForm || {}).disabled\n          : this.disabled || (this.elForm || {}).disabled;\n      },\n      tabIndex() {\n        return (this.isDisabled || (this.isGroup && this.model !== this.label)) ? -1 : 0;\n      }\n    },\n\n    methods: {\n      handleChange() {\n        this.$nextTick(() => {\n          this.$emit(\'change\', this.model);\n          this.isGroup && this.dispatch(\'ElRadioGroup\', \'handleChange\', this.model);\n        });\n      }\n    }\n  };\n</script>\n\n```\n\n模板基本结构\n\n```html\n<template>\n  <label\n    class=\"el-radio\"\n  >\n    <span class=\"el-radio__input\"\n    >\n      <span class=\"el-radio__inner\"></span>\n      <input\n        ref=\"radio\"\n        class=\"el-radio__original\"\n        type=\"radio\"\n        aria-hidden=\"true\"\n        tabindex=\"-1\"\n        autocomplete=\"off\"\n      >\n    </span>\n    <span class=\"el-radio__label\">\n      <slot></slot>\n      <template v-if=\"!$slots.default\">{{label}}</template>\n    </span>\n  </label>\n</template>\n```\n\n组件模板中使用`label`标签包含了`input`标签，其将自动建立起关联，也就是点击`label`标签，会自动聚焦(`focus`)到相关联的`input`元素,这样做为用户提供了便捷，而不是只能点击小圆圈。  \n`label`标签内分了两块，`class=\"el-radio__input\"`是前面的小圆圈部分，`class=\"el-radio__label\"`是后面跟的文本，文本可选择传入**自定义元素**，它将优先展示，否则使用传入的`label`作为文本。  \n\n重点看下`input`元素\n\n```html\n      <span class=\"el-radio__input\"\n      :class=\"{\n        \'is-disabled\': isDisabled,\n        \'is-checked\': model === label\n      }\"\n    >\n      <span class=\"el-radio__inner\"></span>\n      <input\n        ref=\"radio\"\n        class=\"el-radio__original\"\n        :value=\"label\"\n        type=\"radio\"\n        aria-hidden=\"true\"\n        v-model=\"model\"\n        @focus=\"focus = true\"\n        @blur=\"focus = false\"\n        @change=\"handleChange\"\n        :name=\"name\"\n        :disabled=\"isDisabled\"\n        tabindex=\"-1\"\n        autocomplete=\"off\"\n      >\n    </span>\n```\n\n介绍一下里面属性的作用  \n\n- `class=\"el-radio__original\"`\n\n  ```scss\n  .el-radio__original {\n      opacity: 0;\n      outline: none;\n      position: absolute;\n      z-index: -1;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n      margin: 0;\n  }\n  ```\n\n  该class将透明度设为0且脱离了文档流，其选中状态将由它前面的span决定,当绑定值和传入的label值相等时切换为选中样式。\n\n  ```html\n  <span class=\"el-radio__input\"\n        :class=\"{\n          \'is-disabled\': isDisabled,\n          \'is-checked\': model === label\n        }\"\n      >\n        <span class=\"el-radio__inner\"></span>\n      </span>\n  ```\n\n  >这里有个知识点，如果想让子元素类展示不同的样式，那么可以将它的父元素设置不同的类，通过多级类选择器达到目的。\n\n- `tabindex`表示使用tab键切换聚焦的顺序，有三个值\n  - -1，表示用tab键不能聚焦，但是能用js获取\n  - 0，表示可以用tab获取焦点\n  - 正值，表示可以使用tab获取焦点，切换的顺序是按tabIndex从小到大排序，如果多个元素相同，则通过DOM中出现的顺序决定\n- `:value`，把父组件传递过来的 label 给原生value属性\n- `:name`，把父组件传递过来的 name 给原生name属性\n- `@focus\\@blur`，监听input聚焦和失焦事件，用于提醒`label`元素更新样式\n\n重点在`v-model=\"model\"`是什么个意思呢，先了解基本使用方法\n\n```html\n<template>\n  <el-radio v-model=\"radio\" label=\"1\">备选项</el-radio>\n  <el-radio v-model=\"radio\" label=\"2\">备选项</el-radio>\n</template>\n\n<script>\n  export default {\n    data () {\n      return {\n        radio: \'1\'\n      };\n    }\n  }\n</script>\n```\n\n子组件上使用`v-model`对同一个值`radio`进行双向绑定，我们在选中某个`elradio`时，`radio`的值会切换为当前元素`label`值。  \n我们都知道，`v-model`其实是`@input`和`v-bind=\"value\"`的语法糖，子组件接收到父组件的`props.value`后，如果直接通过`v-model`绑定`value`,在子组件内就直接操作了父组件的value。这违反了`vue`单向数据流的原则，所以这里使用`v-model`绑定了计算属性`model`，做了一层中间处理。\n\n```js\nmodel: {\n  get() {\n    return this.isGroup ? this._radioGroup.value : this.value;\n  },\n  set(val) {\n    if (this.isGroup) {\n      this.dispatch(\'ElRadioGroup\', \'input\', [val]);\n    } else {\n      this.$emit(\'input\', val);\n    }\n    this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);\n  }\n},\n```\n\n当`v-model`访问计算属性`model`时触发`get`将`value`值返回，设置属性时将新的值（当前`radio`组件绑定的`label`值）以`input`事件发出。这样父组件的`v-model=\"radio\"`的值绑定就与子组件内部的`v-model=\"model\"`绑定同步。\n\n# 单选框组 radio-group\n\n源码结构如下\n\n```html\n<template>\n  <component\n    :is=\"_elTag\"\n    class=\"el-radio-group\"\n    role=\"radiogroup\"\n    @keydown=\"handleKeydown\"\n  >\n    <slot></slot>\n  </component>\n</template>\n<script>\n  import Emitter from \'element-ui/src/mixins/emitter\';\n\n  const keyCode = Object.freeze({\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40\n  });\n  export default {\n    name: \'ElRadioGroup\',\n\n    componentName: \'ElRadioGroup\',\n\n    inject: {\n      elFormItem: {\n        default: \'\'\n      }\n    },\n\n    mixins: [Emitter],\n\n    props: {\n      value: {},\n      size: String,\n      fill: String,\n      textColor: String,\n      disabled: Boolean\n    },\n\n    computed: {\n      _elFormItemSize() {\n        return (this.elFormItem || {}).elFormItemSize;\n      },\n      _elTag() {\n        let tag = (this.$vnode.data || {}).tag;\n        if (!tag || tag === \'component\') tag = \'div\';\n        return tag;\n      },\n      radioGroupSize() {\n        return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;\n      }\n    },\n\n    created() {\n      this.$on(\'handleChange\', value => {\n        this.$emit(\'change\', value);\n      });\n    },\n    mounted() {\n      // 当radioGroup没有默认选项时，第一个可以选中Tab导航\n      const radios = this.$el.querySelectorAll(\'[type=radio]\');\n      const firstLabel = this.$el.querySelectorAll(\'[role=radio]\')[0];\n      if (![].some.call(radios, radio => radio.checked) && firstLabel) {\n        firstLabel.tabIndex = 0;\n      }\n    },\n    methods: {\n      handleKeydown(e) { // 左右上下按键 可以在radio组内切换不同选项\n        const target = e.target;\n        const className = target.nodeName === \'INPUT\' ? \'[type=radio]\' : \'[role=radio]\';\n        const radios = this.$el.querySelectorAll(className);\n        const length = radios.length;\n        const index = [].indexOf.call(radios, target);\n        const roleRadios = this.$el.querySelectorAll(\'[role=radio]\');\n        switch (e.keyCode) {\n          case keyCode.LEFT:\n          case keyCode.UP:\n            e.stopPropagation();\n            e.preventDefault();\n            if (index === 0) {\n              roleRadios[length - 1].click();\n              roleRadios[length - 1].focus();\n            } else {\n              roleRadios[index - 1].click();\n              roleRadios[index - 1].focus();\n            }\n            break;\n          case keyCode.RIGHT:\n          case keyCode.DOWN:\n            if (index === (length - 1)) {\n              e.stopPropagation();\n              e.preventDefault();\n              roleRadios[0].click();\n              roleRadios[0].focus();\n            } else {\n              roleRadios[index + 1].click();\n              roleRadios[index + 1].focus();\n            }\n            break;\n          default:\n            break;\n        }\n      }\n    },\n    watch: {\n      value(value) {\n        this.dispatch(\'ElFormItem\', \'el.form.change\', [this.value]);\n      }\n    }\n  };\n</script>\n\n\n```\n\n>结合el-radio-group元素和子元素el-radio可以实现单选组，在el-radio-group中绑定v-model，在el-radio中设置好label即可\n\n1. html结构\n\n```html\n <template>\n  <component\n    :is=\"_elTag\"\n    class=\"el-radio-group\"\n    role=\"radiogroup\"\n    @keydown=\"handleKeydown\"\n  >\n    <slot></slot>\n  </component>\n</template>\n```\n\n插槽外部包裹了一个动态组件，这个组件的`is`属性绑定了一个计算属性\n\n```js\n   computed: {\n      _elTag() {\n        let tag = (this.$vnode.data || {}).tag;\n        if (!tag || tag === \'component\') tag = \'div\';\n        return tag;\n      },\n    },\n```\n\n这里返回的是虚拟Node的tag标签，默认是\'div\'。\n\n`@keydown=\"handleKeydown\"`绑定了一个键盘事件\n\n```js\n//冻结对象，使其不被配置\nconst keyCode = Object.freeze({\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40\n  });\nhandleKeydown(e) {\n  // 左右上下按键 可以在radio组内切换不同选项\n  //记录活跃事件目标，其实就是input\n  const target = e.target;\n  const className = target.nodeName === \'INPUT\' ? \'[type=radio]\' : \'[role=radio]\';\n  //选中所有属性含有\'[type=radio]\'的元素也就是所有的radios\n  const radios = this.$el.querySelectorAll(className);\n  const length = radios.length;\n  //调用数组原型方法查找当前活跃的radio元素\n  const index = [].indexOf.call(radios, target);\n  //查找所有属性含有[role=radio]的对象\n  const roleRadios = this.$el.querySelectorAll(\'[role=radio]\');\n  //判断按下的键keycode\n  switch (e.keyCode) {\n    //左和上是一样的\n    case keyCode.LEFT:\n    case keyCode.UP:\n      //阻止冒泡\n      e.stopPropagation();\n      //阻止默认事件\n      e.preventDefault();\n      //如果当前索引是第一个\n      if (index === 0) {\n        //那就选中最后一个\n        roleRadios[length - 1].click();\n        //聚焦\n        roleRadios[length - 1].focus();\n      } else {\n        //否则选中上一个\n        roleRadios[index - 1].click();\n        //聚焦\n        roleRadios[index - 1].focus();\n      }\n      break;\n    case keyCode.RIGHT:\n    case keyCode.DOWN:\n      if (index === (length - 1)) {\n        e.stopPropagation();\n        e.preventDefault();\n        roleRadios[0].click();\n        roleRadios[0].focus();\n      } else {\n        roleRadios[index + 1].click();\n        roleRadios[index + 1].focus();\n      }\n      break;\n    default:\n      break;\n  }\n}\n```\n\n该方法绑定了键盘事件，通过事件委托，先拿出当前活跃的元素判断是否是input单选框，并选中所有属性含有\'[type=radio]\'的元素也就是radios，然后找到当前活跃radios的索引，再找到所有的label，并判断键盘方向，触发前一个或者后一个label的点击事件来达到切换目的。\n\n2. 监听`v-model`事件\n\n我们先研究下这个导入的`Emitter`是什么东东\n\n```js\nfunction broadcast(componentName, eventName, params) {\n  this.$children.forEach(child => {\n    var name = child.$options.componentName;\n\n  //取到所有的子组件，如果是指定子组件，使用该子组件发射事件，事件名为传入eventName，参数为params\n    if (name === componentName) {\n      child.$emit.apply(child, [eventName].concat(params));\n    } else {\n      //否则递归查找\n      broadcast.apply(child, [componentName, eventName].concat([params]));\n    }\n  });\n}\nexport default {\n  methods: {\n    //导出dispatch方法，该方法支持传入三个参数，组件名，事件名，参数\n    dispatch(componentName, eventName, params) {\n      //拿到父组件，如果没有取根组件\n      var parent = this.$parent || this.$root;\n      //拿到父组件的组件名\n      var name = parent.$options.componentName;\n      //判断条件，父组件不存在且name不存在或者存在但不是传入的组件名\n      while (parent && (!name || name !== componentName)) {\n        //取父亲的父亲\n        parent = parent.$parent;\n\n        if (parent) {\n          name = parent.$options.componentName;\n        }\n      }\n      //如果没有父组件 或者找到和传入的组件名相同的组件 那么走到这里\n      if (parent) {\n        //判断父组件是否存在，那么就以父组件为上下文发射事件，事件名为传入eventName，参数为params\n        parent.$emit.apply(parent, [eventName].concat(params));\n      }\n    },\n    //下发事件方法\n    broadcast(componentName, eventName, params) {\n      broadcast.call(this, componentName, eventName, params);\n    }\n  }\n};\n\n```\n\n这个`mixin`导出两个方法，`dispatch`是针对调用者父组件派发事件，`broadcast`是针对调用者子组件播送事件。\n\n`radio-group`组件中采用`$on`监听`radio`组件的`handleChanges`事件来发射`change`事件,\n\n```js\n//radio-group\nprops: {\n  //这个值会被radios取到取到\n      value: {},\n    },\ncreated() {\n      this.$on(\'handleChange\', value => {\n        this.$emit(\'change\', value);\n      });\n    },\n```\n\n`radio`组件中采用`dispatch`派发`handleChange`事件，参数为最新选中的值。\n\n```js\n//radio\ncomputed: {\n  model: {\n        get() {\n          //如果是单选框组，取父组件的value值\n          return this.isGroup ? this._radioGroup.value : this.value;\n        },\n        set(val) {\n          if (this.isGroup) {\n            //派发至父组件 并调用父组件的$emit(\'input\')事件，将最新选中的值传出\n            this.dispatch(\'ElRadioGroup\', \'input\', [val]);\n          } else {\n            this.$emit(\'input\', val);\n          }\n          this.$refs.radio && (this.$refs.radio.checked = this.model === this.label);\n        }\n      },\n},\nmethods: {\n      handleChange() {\n        this.$nextTick(() => {\n          this.$emit(\'change\', this.model);\n          this.isGroup && this.dispatch(\'ElRadioGroup\', \'handleChange\', this.model);\n        });\n      }\n    }\n```\n\n# 按钮样式radio-button\n\n其实和`radios`组件差不多，只是更换了`span`元素的样式 让它看起来像按钮，这里不多说了。\n\n# 总结\n\n总的来说如果使用了radio-group组件，那么无论是radio-button和radio组件都会受到父组件radio-group的影响。每个radio之间的选中逻辑是对v-model传入的值与他们所绑定的label值相比较。每个组件都有其尺寸适配逻辑，都遵从`component-> elFormItem -> $ELEMENT`的顺序取存在的值\n','2022-08-18 19:09:36','2022-08-20 20:22:33',1,'*在一组备选项中进行单选,该文件夹定义了`install`方法，方法内部定义了`Radio`全局组件，在Vue项目中使用`Vue.use(Radio)`可单独安装，这里提供了`RadioButton`和`RadioGroup`组件单独导出的方法，其实他们都生在一个文件夹。*',0,NULL,0),(81,'Element组件源码解析之Switch',1,'# Switch 开关组件\n\n## 安装方式\n\n```js\nimport Switch from \'./src/component\';\n\n/* istanbul ignore next */\nSwitch.install = function(Vue) {\n  Vue.component(Switch.name, Switch);\n};\n\nexport default Switch;\n```\n\n可单独安装,亦可全局安装\n\n## 代码解析\n\n- main.js\n\n将模板中涉及vue交互逻辑的vue代码,保留html结构。\n\n```html\n<template>\n  <div\n    class=\"el-switch\"\n  >\n    <input\n      class=\"el-switch__input\"\n      type=\"checkbox\"\n      ref=\"input\"\n    >\n    <span>\n      <i v-if=\"inactiveIconClass\"></i>\n      <span v-if=\"!inactiveIconClass && inactiveText\">{{ inactiveText }}</span>\n    </span>\n    <span class=\"el-switch__core\" ref=\"core\"\">\n    </span>\n    <span\n      :class=\"[\'el-switch__label\', \'el-switch__label--right\', checked ? \'is-active\' : \'\']\"\n      v-if=\"activeIconClass || activeText\">\n      <i v-if=\"activeIconClass\"></i>\n      <span v-if=\"!activeIconClass && activeText\" >{{ activeText }}</span>\n    </span>\n  </div>\n</template>\n```\n\n先看下最外层div的样式\n\n```scss\n//el-switch\n.el-switch {\n    display: inline-flex;\n    align-items: center;\n    position: relative;\n    font-size: 14px;\n    line-height: 20px;\n    height: 20px;\n    vertical-align: middle;\n}\n```\n\n1. 最外层盒子使用了`inline-flex`布局，那么为什么不直接用`flex`布局呢，这就要看下`inline-flex``和flex布局的区别了`\n\n> - flex: 将对象作为弹性伸缩盒子展示\n> - inline-flex: 将对象作为内联块级弹性伸缩盒子展示\n\n也就是说如果一个盒子没有指定宽度且`display:flex`的盒子，其宽度将占满父元素；如果没有指定宽度且为`display：inline-flex`的盒子，其宽度默认会根据子元素的宽高去自适应。\n所以此时`el-switch`组件可作为**行内块元素**且内部为`flex`布局\n\n2. 使用`vertical-align: middle;`实现行内元素的垂直居中，其要点在[实现盒子居中的若干方法](https://docs.hgyn23.cn/main/post/62)。\n\n接着看下内部的`input`元素样式  \n\n```scss\n.el-switch__input {\n    position: absolute;\n    width: 0;\n    height: 0;\n    opacity: 0;\n    margin: 0;\n}\n```\n\n样式作用是**隐藏**该元素，并且将其**脱离文档流**。但凡是由两种状态的组件都可以用这种方式来进行开发。组件选中状态最终作用于`input`元素。所以组件中我们可以通过\"代理\"的方式，把check `input`的逻辑迁移到其他元素上，通过绑定其他元素事件来自定义一些交互逻辑，将最终的结果给到`input`元素。\n\nelement实现:  \nhtml\n\n```html\n<div\n    class=\"el-switch\"\n    :class=\"{ \'is-checked\': checked }\"\n    @click.prevent=\"switchValue\"\n  >\n<!-- 代理元素 容器 -->\n<span class=\"el-switch__core\" ref=\"core\" :style=\"{ \'width\': coreWidth + \'px\' }\">\n    </span>\n    <!-- 代理元素的伪元素，作为switch的圆球 -->\n    ::after\n  </div>\n\n```\n\ncss\n\n```scss\n.el-switch__core {\n    margin: 0;\n    display: inline-block;\n    position: relative;\n    width: 40px;\n    height: 20px;\n    border: 1px solid #dcdfe6;\n    outline: none;\n    border-radius: 10px;\n    box-sizing: border-box;\n    background: #dcdfe6;\n    cursor: pointer;\n    transition: border-color .3s,background-color .3s;\n    vertical-align: middle;\n}\n.el-switch__core:after {\n    content: \"\";\n    position: absolute;\n    top: 1px;\n    left: 1px;\n    border-radius: 100%;\n    transition: all .3s;\n    width: 16px;\n    height: 16px;\n    background-color: #fff;\n}\n//细节在此 当外部元素同时拥有.el-switch和.is-checked，此样式将被匹配\n.el-switch.is-checked .el-switch__core:after {\n    left: 100%;\n    margin-left: -17px;\n}\n```\n\njs\n\n```js\ncomputed: {\n      checked() {\n        return this.value === this.activeValue;\n      },\n      switchDisabled() {\n        return this.disabled || (this.elForm || {}).disabled;\n      }\n    },\n    watch: {\n      checked() {\n        this.$refs.input.checked = this.checked;\n        if (this.activeColor || this.inactiveColor) {\n          this.setBackgroundColor();\n        }\n        if (this.validateEvent) {\n          this.dispatch(\'ElFormItem\', \'el.form.change\', [this.value]);\n        }\n      }\n    },\nmethods: {\n  handleChange(event) {\n  //状态反转\n  const val = this.checked ? this.inactiveValue : this.activeValue;\n  this.$emit(\'input\', val);\n  this.$emit(\'change\', val);\n  this.$nextTick(() => {\n    // set input\'s checked property\n    // in case parent refuses to change component\'s value\n    if (this.$refs.input) {\n      //dom更新后赋值\n      this.$refs.input.checked = this.checked;\n    }\n  });\n},\nsetBackgroundColor() {\n  let newColor = this.checked ? this.activeColor : this.inactiveColor;\n  //通过$refs.core取到元素引用设置背景色\n  this.$refs.core.style.borderColor = newColor;\n  this.$refs.core.style.backgroundColor = newColor;\n},\n}\n```\n\n点击外部元素触发回调后最终会调用`handleChange`方法，通过`$emit`方法反转选中状态。通过computed检测到value变化，最终通知到watch调用设置背景色方法。\n','2022-08-21 03:16:27','2022-08-20 20:22:18',1,'*表示两种相互对立的状态间的切换，多用于触发「开/关」*',0,NULL,0),(82,'Promise(期约)基本实现',1,'该Promise类实现遵循[Promises/A+](https://promisesaplus.com/)规范，实现了`then`、`catch`的链式调用。\n\n## 实现\n```js\nconst PROMISE_STATUS_PENDING = \'pending\';\nconst PROMISE_STATUS_FULFILLED = \'fulfilled\';\nconst PROMISE_STATUS_REJECTED = \'rejected\';\nlet id = 0;\nclass PromisePolyfill {\n  constructor(executor) {\n    this.promiseId = ++id;\n    this.status = PROMISE_STATUS_PENDING;\n    this.value = null;\n    this.reason = null;\n    //该队列用于处理当状态为pending的时候多次调用then传入的回调函数\n    this.onFulfilledFuncs = [];\n    this.onRejectedFuncs = [];\n    const resolve = (value) => {\n      if (this.status === PROMISE_STATUS_PENDING) {\n        //将当前then(同步执行的)出来的回调方法推进微任务队列\n        queueMicrotask(() => {\n          if (this.status !== PROMISE_STATUS_PENDING) return;\n          this.status = PROMISE_STATUS_FULFILLED;\n          this.value = value;\n          while (this.onFulfilledFuncs.length) {\n            this.onFulfilledFuncs.shift()(value);\n          }\n        });\n      }\n    };\n    const reject = (reason) => {\n      if (this.status === PROMISE_STATUS_PENDING) {\n        queueMicrotask(() => {\n          if (this.status !== PROMISE_STATUS_PENDING) return;\n          this.status = PROMISE_STATUS_REJECTED;\n          this.reason = reason;\n          //将resolve内的参数作为then的第二个函数的入参\n          while (this.onRejectedFuncs.length) {\n            this.onRejectedFuncs.shift()(reason);\n          }\n        });\n      }\n    };\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n    // console.log(this);\n  }\n  //该函数一旦执行，将内部的这两个回调函数赋值\n  then(onFulfilled, onRejected) {\n    //如果then函数没有传reject函数，就使用默认函数\n    const defaultReject = (err) => {\n      throw err;\n    };\n    onRejected = onRejected || defaultReject;\n    //如果then函数没有传reject函数，就使用默认函数\n    const defaultOnFulfilled = (value) => {\n      return value;\n    };\n    onFulfilled = onFulfilled || defaultOnFulfilled;\n    if (\n      (onFulfilled && typeof onFulfilled !== \'function\') ||\n      (onRejected && typeof onRejected !== \'function\')\n    ) {\n      throw new Error(\'callback function must be a function\');\n    }\n    return new PromisePolyfill((resolve, reject) => {\n      if (this.status === PROMISE_STATUS_FULFILLED && onFulfilled) {\n        //用户定义的函数有多种不确定性，因而要使用try catch包裹\n        try {\n          resolve(onFulfilled(this.value));\n        } catch (err) {\n          reject(err);\n        }\n      }\n      if (this.status === PROMISE_STATUS_REJECTED && onRejected) {\n        try {\n          resolve(onRejected(this.reason));\n        } catch (err) {\n          reject(err);\n        }\n      }\n      if (this.status === PROMISE_STATUS_PENDING) {\n        onFulfilled &&\n          //接收一个参数 value 该参数为上一个promise resolve出来的结果\n          this.onFulfilledFuncs.push((value) => {\n            try {\n              resolve(onFulfilled(value));\n            } catch (err) {\n              reject(err);\n            }\n          });\n        onRejected &&\n          this.onRejectedFuncs.push((reason) => {\n            try {\n              resolve(onRejected(reason));\n            } catch (err) {\n              reject(err);\n            }\n          });\n      }\n    });\n  }\n  //注意这个catch捕获的是最后一个reject\n  catch(onRejected) {\n    return this.then(undefined, onRejected);\n  }\n	finally(onFinally) {\n		//无返回值 为promise链的结束\n    this.then(() => {\n      onFinally()\n    }, () => {\n      onFinally()\n    })\n  }\n}\n```\n## 测试代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src=\"./index.js\"></script>\n    <script>\n      //pending promise0\n     const promise = new PromisePolyfill((resolve, reject) => {\n      //步骤1 执行reject函数 将清空函数队列的任务排入微任务队列，返回了pending状态的promise\n        resolve(\'resolve\');\n        reject(\'reject\');\n      })\n      //步骤2 执行同步代码then1 将回调函数排入promise函数数组，返回pending状态的promise1\n      //pending promise1\n      promise.then(\n        (res) => {\n          //步骤6 同步代码执行完毕 开始执行promise回调函数，因为此时为reject，所以该函数不会执行,\n          //又因为没有传onRejected函数所以执行onReject函数时，会直接抛出错误，然后被reject掉，理由会传到下一个then的第二个函数的参数\n          console.log(\'onFulfilled被调用\',res);\n          return \'aaa\'\n        }\n      //步骤3 执行同步代码then2 将回调函数排入promise1函数数组，返回pending状态的promise2\n      //pending promise2\n      ).then(res => {\n          //步骤7，同样的，又因为没有传onRejected函数所以执行onReject函数时，会直接抛出错误，然后被reject掉，理由会传到下一个then的第二个函数的参数\n        console.log(\'onFulfilled被调用1\',res);\n        return \'bbb\'\n      //步骤4 执行同步代码catch2 将回调函数排入promise2函数数组，返回pending状态的promise3\n      //pending promise3\n      }).catch(err => {\n          //步骤8，其实这个catch也是调用then，但是这个then把onRejected函数传入了，所以catch会再次捕获到上面传的错误\n        console.log(\'catch\',err);\n        return \'bbb\'\n      //步骤5 执行同步代码then3 将回调函数排入promise3函数数组，返回pending状态的promise4\n      //pending promise4\n      }).then(res => {\n        console.log(\'catch后面的then,\'+res);\n      });\n      setTimeout(() => {\n      console.log(promise);\n        promise.then(res => {\n          console.log(\'setTimeout里面的then\',res);\n        }).catch(err => {\n          console.log(\'setTimeout里面的catch\',err);\n        })\n      },1000)\n      PromisePolyfill.resolve(\'PromisePolyfill.resolve\').then(res => {\n        console.log(res);\n      })\n      PromisePolyfill.reject(\'PromisePolyfill.reject\').then(res => {\n        console.log(res);\n      }).catch(err => {\n        console.log(err);\n      })\n      //当同步任务(宏任务)都执行完 微任务队列将开始执行\n    </script>\n  </body>\n</html>\n\n```','2022-08-22 16:37:17','2022-08-22 09:12:25',1,'*该Promise类实现遵循[Promises/A+](https://promisesaplus.com/)规范，实现了`then`、`catch`的链式调用。*',0,NULL,0),(83,'Promise(期约)扩展方法实现',1,'## 代码实现\n[前面的章节](https://docs.hgyn23.cn/main/post/82)中我们的`PromisePolyfill`类实现了`Promise(期约)`的基本模型，下面介绍一下其静态扩展方法`resolve`、`reject`、`all`、`allSettle`、`race`、`any`的实现。\n\n```js\nclass PromisePolyfill {\n  constructor(executor) {\n    //...\n  }\n  //该函数一旦执行，将内部的这两个回调函数赋值\n  then(onFulfilled, onRejected) {\n		//...\n  }\n  //注意这个catch捕获的是最后一个reject\n  catch(onRejected) {\n    //...\n  }\n  static resolve(res) {\n    return new PromisePolyfill((resolve, reject) => {\n      resolve(res);\n    });\n  }\n  static reject(reason) {\n    return new PromisePolyfill((resolve, reject) => {\n      reject(reason);\n    });\n  }\n  static all(promiseArray) {\n    return new PromisePolyfill((resolve, reject) => {\n      const values = [];\n      promiseArray.forEach((promise) => {\n        promise\n          .then((res) => {\n            values.push(res);\n            if (values.length === promiseArray.length) resolve(values);\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      });\n    });\n  }\n  static allSettle(promiseArray) {\n    return new PromisePolyfill((resolve, reject) => {\n      const results = [];\n      promiseArray.forEach((promise) => {\n        promise\n          .then((res) => {\n            results.push({ status: PROMISE_STATUS_FULFILLED, result: res });\n            if (results.length === promiseArray.length) resolve(results);\n          })\n          .catch((err) => {\n            results.push({ status: PROMISE_STATUS_REJECTED, result: err });\n            if (results.length === promiseArray.length) resolve(results);\n          });\n      });\n    });\n  }\n  static race(promiseArray) {\n    return new PromisePolyfill((resolve, reject) => {\n      promiseArray.forEach((promise) => {\n        promise.then(resolve, reject);\n      });\n    });\n  }\n  static any(promiseArray) {\n    // 要执行resolve必须等到有一个成功的结果\n    // 要执行reject所有的都失败才执行reject\n    return new PromisePolyfill((resolve, reject) => {\n      let rejectArr = [];\n      promiseArray.forEach((promise) => {\n        promise.then(resolve, (err) => {\n          rejectArr.push(err);\n          if (rejectArr.length === promiseArray.length) {\n            reject(new Error(\'all promises reject\'));\n          }\n        });\n      });\n    });\n  }\n}\n```\n## 测试\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src=\"./index.js\"></script>\n    <script>\n      PromisePolyfill.resolve(\'PromisePolyfill.resolve\').then(res => {\n        console.log(res);\n      })\n      PromisePolyfill.reject(\'PromisePolyfill.reject\').then(res => {\n        console.log(res);\n      }).catch(err => {\n        console.log(err);\n      })\n      PromisePolyfill.all([new PromisePolyfill((resolve,reject) => {\n        resolve(123)\n      }),new PromisePolyfill((resolve,reject) => {\n        resolve(456)\n      }) ]).then(res => {\n        // console.log(res);\n      })\n      PromisePolyfill.allSettle([new PromisePolyfill((resolve,reject) => {\n        resolve(123)\n      }),new PromisePolyfill((resolve,reject) => {\n        reject(456)\n      })]).then(res => {\n        // console.log(res);\n      })\n      PromisePolyfill.race([new PromisePolyfill((resolve,reject) => {\n        resolve(456)\n      }),new PromisePolyfill((resolve,reject) => {\n        resolve(123)\n      })]).then(res => {\n        // console.log(res);\n      })\n      PromisePolyfill.any([new PromisePolyfill((resolve,reject) => {\n        reject(456)\n      }),new PromisePolyfill((resolve,reject) => {\n        reject(123)\n      })]).then(res => {\n        console.log(res);\n      }).catch(err => {\n        console.log(err);\n      })\n    </script>\n  </body>\n</html>\n\n```','2022-08-22 16:47:30','2022-08-22 09:10:31',1,'*该篇介绍Prmise(期约)的`resolve`、`reject`、`all`、`allSettle`、`race`、`any`静态方法的实现*',0,NULL,0),(84,'Javascript 相关高级API的Polyfill实现',1,'### Object.is()\n\n> Object.is() 方法判断两个值是否为同一个值。 ——[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is)\n\n该方法主要是为了解决某些情况下两个操作数不等的问题，其他的和` === `没什么区别 如下面的例子：\n```js\nNaN === NaN // false\n+0 === -0 // true\nObject.is(NaN,NaN) // true\nObject.is(+0,-0) // false\n```\n\npolyfill：\n```js\nif (!Object.is) {\n  Object.is = function(x, y) {\n    if (x === y) { // Steps 1-5, 7-10\n      // 针对 +0不等于-0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // 针对 NaN等于NaN\n      return x !== x && y !== y;\n    }\n  };\n}\n```','2022-08-24 16:42:41','2022-08-24 08:47:26',1,'javascript在es5之后新增了不少API，实现的方法不方便统一归类，总是在用与不用之间徘徊，下面介绍一些常用API的polyfill实现，便于理解其中原理。',0,NULL,0),(85,'Element组件工具方法解析',1,'# 前言\n\n在解析element-ui各个组件源码之前，我们需要做一些前期准备工作，这里介绍element-ui的各个工具类方法，路径在`element\\src\\utils`中，用于在之后组件解析过程中参照使用。\n解析进度\n1. menu\n2. popup\n3. after-leave\n4. aria-dialog\n5. aria-utils\n6. clickoutside\n7. date-util\n8. date\n9. dom\n10. merge ✔\n11. popper\n12. resize-event\n13. scroll-into-view ✔\n14. scrollbar-width ✔\n15. shared\n16. types ✔\n17. util ✔\n18. vdom\n19. vue-popper\n\n\n## Types.js\n\n开头先导入了Vue，因为在该模块中需要通过Vue来判断一些状态\n\n```js\nimport Vue from \'vue\';\n```\n\n这里定义了一些类型检测的方法，让我们先一起看看\n\n### 判断是否是字符串\n\n```js\nexport function isString(obj) {\n  return Object.prototype.toString.call(obj) === \'[object String]\';\n}\n```\n\n### 判断参数是否是对象\n\n```js\nexport function isObject(obj) {\n  return Object.prototype.toString.call(obj) === \'[object Object]\';\n}\n```\n\n### 判断参数是否是元素节点\n\n```js\nexport function isHtmlElement(node) {\n  //nodeType为元素节点时值为1\n  return node && node.nodeType === Node.ELEMENT_NODE;\n}\n```\n\n### 判断参数是否是函数\n\n```js\nlet isFunction = (functionToCheck) => {\n  var getType = {};\n  //此处定义了一个空对象，利用原型链查找\n  return functionToCheck && getType.toString.call(functionToCheck) === \'[object Function]\';\n};\nif (typeof /./ !== \'function\' && typeof Int8Array !== \'object\' && (Vue.prototype.$isServer || typeof document.childNodes !== \'function\')) {\n  isFunction = function(obj) {\n    return typeof obj === \'function\' || false;\n  };\n}\n```\n\n该检测方法参考[underscore](https://github.com/jashkenas/underscore/blob/master/modules/isFunction.js)，用于兼容一些老的v8，IE11，Safari 8，PhantomJS 中`typeof`方法的bug。\n\n### 检查参数是否是undefined\n\n```js\nexport const isUndefined = (val)=> {\n  return val === void 0;\n};\n```\n\n使用`void 0`来替代`undefined`，用于避免`undefined`被赋值导致的错误。\n\n### 检查参数是否定义\n\n```js\nexport const isDefined = (val) => {\n  return val !== undefined && val !== null;\n};\n\n```\n\n## utils.js\n\n该模块定义了一些实用的工具函数，让我们来看看。\n\n```js\nimport Vue from \'vue\';\nimport { isString, isObject } from \'element-ui/src/utils/types\';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n```\n\n开头引入了Vue构造函数和`isString`、`isObject`类型检测方法，并且将`hasOwnProperty`缓存，这在频繁用到该方法时减少对象查找时间。\n\n### 空函数\n\n```js\nexport function noop() {};\n```\n\n空函数在一些判断逻辑中会用到，比如检测是否是服务端渲染，用于避免一些在服务端不必要的操作。\n\n### 检查是否是自身属性\n\n```js\nexport function hasOwn(obj, key) {\n  //传入对象obj，键key，检测key是否只在自身属性中，避免查找原型链\n  return hasOwnProperty.call(obj, key);\n};\n```\n\n### 对象混入(内部方法)\n\n```js\nfunction extend(to, _from) {\n  for (let key in _from) {\n    //_from对象中的所有键值对都会覆盖到to，包括原型链\n    to[key] = _from[key];\n  }\n  return to;\n};\n```\n\n### flat对象数组\n\n```js\nexport function toObject(arr) {\n  //只允许传对象数组\n  var res = {};\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      //使用了上述对象混入方法，\n      extend(res, arr[i]);\n    }\n  }\n  return res;\n};\n```\n\n### 根据对象路径获取对象值\n\n```js\nexport const getValueByPath = function(object, prop) {\n  //格式化\n  prop = prop || \'\';\n  //分割成数组\n  const paths = prop.split(\'.\');\n  //缓存当前访问深度\n  let current = object;\n  let result = null;\n  for (let i = 0, j = paths.length; i < j; i++) {\n    const path = paths[i];\n    if (!current) break;\n    //如果是最后一个路径\n    if (i === j - 1) {\n    //获取到最终值\n      result = current[path];\n      break;\n    }\n    //缓存当前访问深度\n    current = current[path];\n  }\n  return result;\n};\n```\n\n### 根据对象和对象路径获取最终的key，value和存储该键值对的对象\n\n```js\nexport function getPropByPath(obj, path, strict) {\n  let tempObj = obj;\n  // 该正则用于替换`a[b]`这样的动态路径转成`a.b`形式\n  path = path.replace(/\\[(\\w+)\\]/g, \'.$1\');\n  // 该正则用于去掉开头的`.`\n  path = path.replace(/^\\./, \'\');\n  //分割字符串\n  let keyArr = path.split(\'.\');\n  //这里将i定义在外部用于返回值\n  let i = 0;\n  // 迭代器迭代至数组倒数第二个值且 此时i为倒数第一个值\n  for (let len = keyArr.length; i < len - 1; ++i) {\n    //strict为false直接跳出\n    if (!tempObj && !strict) break;\n    let key = keyArr[i];\n    if (key in tempObj) {\n      //层层递进\n      tempObj = tempObj[key];\n    } else {\n      //如果没有找到该key对应的值且为严格模式就报错\n      if (strict) {\n        throw new Error(\'please transfer a valid prop path to form item!\');\n      }\n      break;\n    }\n  }\n  return {\n    o: tempObj,\n    k: keyArr[i],\n    v: tempObj ? tempObj[keyArr[i]] : null\n  };\n};\n```\n\n### 生成随机id\n\n```js\nexport const generateId = function() {\n  //生成0-10000随机值\n  return Math.floor(Math.random() * 10000);\n};\n```\n\n### 判断值是否相等(数组大致相等)\n\n```js\n\nexport const valueEquals = (a, b) => {\n  // 值相等\n  if (a === b) return true;\n  // 实例不是数组 不相等\n  if (!(a instanceof Array)) return false;\n  // 实例不是数组 不相等\n  if (!(b instanceof Array)) return false;\n  // 长度是否相等\n  if (a.length !== b.length) return false;\n  for (let i = 0; i !== a.length; ++i) {\n    //检查数组是否每一项都相等，否则为false\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n};\n\n```\n\n### 转义正则表达式字符串\n\n```js\nexport const escapeRegexpString = (value = \'\') => String(value).replace(/[|\\\\{}()[\\]^$+*?.]/g, \'\\\\$&\');\n```\n\n### 寻找数组中符合要求的值的索引\n\n```js\n//传入pred回调函数，pred对数组中每一项进行检查，直到碰见第一个符合要求的值\nexport const arrayFindIndex = function(arr, pred) {\n  for (let i = 0; i !== arr.length; ++i) {\n    if (pred(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n};\n```\n\n### 寻找符合要求的值\n\n```js\nexport const arrayFind = function(arr, pred) {\n  const idx = arrayFindIndex(arr, pred);\n  return idx !== -1 ? arr[idx] : undefined;\n};\n```\n\n### 将传入参数作为数组返回\n\n```js\nexport const coerceTruthyValueToArray = function(val) {\n  //如果参数本身为数组，返回本身\n  if (Array.isArray(val)) {\n    return val;\n  } else if (val) {\n  //否则如果值为truthy，使用数组包裹返回\n    return [val];\n  } else {\n    return [];\n  }\n};\n```\n\n### 检查是否是IE环境\n\n```js\nexport const isIE = function() {\n  return !Vue.prototype.$isServer && !isNaN(Number(document.documentMode));\n};\n```\n\n关键在后半段`document.documentMode`，在IE环境下其值为 IE版本号，其为IE特有的属性，为`Number`类型。非IE环境Number(undefined)值为NaN，所以可以以此来判断。\n\n### 检查是否是Edge环境\n\n```js\nexport const isEdge = function() {\n  return !Vue.prototype.$isServer && navigator.userAgent.indexOf(\'Edge\') > -1;\n};\n```\n\n### 检查是否是fireFox环境\n\n```js\nexport const isFirefox = function() {\n  return !Vue.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);\n};\n```\n\n### 对transform，transition，animation附加样式前缀\n\n```js\nexport const autoprefixer = function(style) {\n  if (typeof style !== \'object\') return style;\n  const rules = [\'transform\', \'transition\', \'animation\'];\n  const prefixes = [\'ms-\', \'webkit-\'];\n  rules.forEach(rule => {\n    const value = style[rule];\n    if (rule && value) {\n      prefixes.forEach(prefix => {\n        //包括了已有的值\n        style[prefix + rule] = value;\n      });\n    }\n  });\n  return style;\n};\n```\n\n### 分割驼峰命名并以\"-\"链接\n\n```js\nexport const kebabCase = function(str) {\n  //匹配前面为非短横杠的A-Z的字母\n  const hyphenateRE = /([^-])([A-Z])/g;\n  return str\n    .replace(hyphenateRE, \'$1-$2\')\n    .replace(hyphenateRE, \'$1-$2\')\n    .toLowerCase();\n};\n```\n\n### 将字符串首字母大写\n\n```js\nexport const capitalize = function(str) {\n  if (!isString(str)) return str;\n  //取首字母大写并拼接\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n```\n\n### 判断对象是否大致相等（不比较地址）\n\n```js\nexport const looseEqual = function(a, b) {\n  const isObjectA = isObject(a);\n  const isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    //如果都是对象 则使用JSON.stringify转成字符串比较\n    return JSON.stringify(a) === JSON.stringify(b);\n  } else if (!isObjectA && !isObjectB) {\n    //否则转成普通字符串比较\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n};\n```\n\n### 判断数组是否大致相等（不比较地址）\n\n```js\nexport const arrayEquals = function(arrayA, arrayB) {\n  arrayA = arrayA || [];\n  arrayB = arrayB || [];\n\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n\n  for (let i = 0; i < arrayA.length; i++) {\n    if (!looseEqual(arrayA[i], arrayB[i])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n```\n\n### 判断两个参数是否大致相等\n\n```js\nexport const isEqual = function(value1, value2) {\n  if (Array.isArray(value1) && Array.isArray(value2)) {\n    //如果是数组 比较数组\n    return arrayEquals(value1, value2);\n  }\n    //否则比较值\n  return looseEqual(value1, value2);\n};\n```\n\n### 判断一个值是否为”空“\n\n```js\nexport const isEmpty = function(val) {\n  // null or undefined\n  // 如果是null或者是undefined\n  if (val == null) return true;\n  //如果是布尔值 不为空\n  if (typeof val === \'boolean\') return false;\n  //如果是数字类型除了0 都为空\n  if (typeof val === \'number\') return !val;\n  // 如果是Error的实例，则message为空的情况下为空\n  if (val instanceof Error) return val.message === \'\';\n\n  switch (Object.prototype.toString.call(val)) {\n    // String or Array\n    //数组或是字符串情况下判断长度\n    case \'[object String]\':\n    case \'[object Array]\':\n      return !val.length;\n\n    // Map or Set or File\n    // File、Map、Set情况下判断size\n    case \'[object File]\':\n    case \'[object Map]\':\n    case \'[object Set]\': {\n      return !val.size;\n    }\n    // Plain Object\n    // 对象判断\n    case \'[object Object]\': {\n      return !Object.keys(val).length;\n    }\n  }\n\n  return false;\n};\n```\n\n### 节流函数，每帧执行一次函数\n\n```js\nexport function rafThrottle(fn) {\n  let locked = false;\n  return function(...args) {\n    if (locked) return;\n    locked = true;\n    //下次重绘前调用一次Fn\n    window.requestAnimationFrame(_ => {\n      fn.apply(this, args);\n      locked = false;\n    });\n  };\n}\n```\n\n### 将对象转化成数组对象\n\n```js\nexport function objToArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  return isEmpty(obj) ? [] : [obj];\n}\n\n```\n\n## scrollbar-width.js\n\n该模块导出了一个函数，这个函数的作用顾名思义，就是获取当前页面滚动条的宽度。\n\n```js\nimport Vue from \'vue\';\n\nlet scrollBarWidth;\n```\n\n开头引入了Vue构造函数用于判断是否是服务端渲染，并使用一个变量来缓存滚动条宽度，所以获取到宽度之后都是使用这个变量来返回。\n\n```js\n\n\nexport default function() {\n  //服务端渲染宽度为0\n  if (Vue.prototype.$isServer) return 0;\n  //获取上一次缓存\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n\n  //创建一个外部div\n  const outer = document.createElement(\'div\');\n  //定义类名\n  outer.className = \'el-scrollbar__wrap\';\n  //隐藏该元素\n  outer.style.visibility = \'hidden\';\n  //宽度为100px\n  outer.style.width = \'100px\';\n  //脱离文档流\n  outer.style.position = \'absolute\';\n  //不妨碍点击事件\n  outer.style.top = \'-9999px\';\n  document.body.appendChild(outer);\n  //计算此时元素布局宽度（包含滚动条）\n  const widthNoScroll = outer.offsetWidth;\n  //允许滚动\n  outer.style.overflow = \'scroll\';\n  //创建内部元素\n  const inner = document.createElement(\'div\');\n  //为父亲宽度（不包含滚动条）\n  inner.style.width = \'100%\';\n  outer.appendChild(inner);\n  //计算内部布局宽度\n  const widthWithScroll = inner.offsetWidth;\n  //移除outer\n  outer.parentNode.removeChild(outer);\n  //计算滚动条宽度\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n\n  return scrollBarWidth;\n};\n\n```\n\n>offsetWidth 是测量包含元素的边框 (border)、水平线上的内边距 (padding)、竖直方向滚动条 (scrollbar)（如果存在的话）、以及 CSS 设置的宽度 (width) 的值。\n\n## merge.js\n\n该模块导出了一个函数，这个函数的作用顾名思义，就是合并对象，该对象第一个参数为合并目标，其余参数为合并源\n\n```js\nexport default function(target) {\n  for (let i = 1, j = arguments.length; i < j; i++) {\n    let source = arguments[i] || {};\n    for (let prop in source) {\n      if (source.hasOwnProperty(prop)) {\n      //排除原型属性\n        let value = source[prop];\n        if (value !== undefined) {\n          target[prop] = value;\n        }\n      }\n    }\n  }\n  return target;\n};\n\n```\n\n## scroll-into-view.js\n\n该模块导出了一个函数，这个函数的作用顾名思义，就是合并对象，该对象第一个参数为合并目标，其余参数为合并源\n\n```js\nexport default function scrollIntoView(container, selected) {\n  if (!selected) {\n    container.scrollTop = 0;\n    return;\n  }\n\n  const offsetParents = [];\n  //取到包裹这个元素的最近定位元素\n  let pointer = selected.offsetParent;\n  //当这个元素存在但不是container元素且container底下含有这个元素\n  while (pointer && container !== pointer && container.contains(pointer)) {\n    //把这个定位元素推入数组\n    offsetParents.push(pointer);\n    //再往上取\n    pointer = pointer.offsetParent;\n  }\n  //直到container === pointer\n  //取到selected相对于其 offsetParent 元素的顶部的距离+offsetParents数组每个元素相对于其 offsetParent 元素的顶部的距离\n  const top = selected.offsetTop + offsetParents.reduce((prev, cur) => (prev + cur.offsetTop), 0);\n  //总的顶部距离+该元素的布局高度\n  const bottom = top + selected.offsetHeight;\n  //计算容器当前滚动高度\n  const viewRectTop = container.scrollTop;\n  //计算容器当前滚动高度+容器内容高度\n  const viewRectBottom = viewRectTop + container.clientHeight;\n  if (top < viewRectTop) {\n  //selected到顶部的距离比容器滚动的高度小，换句话说就是滚掉了\n  //滚回到select元素处\n    container.scrollTop = top;\n  } else if (bottom > viewRectBottom) {\n  //selected到顶部加自身的距离比容器滚动的高度+自身距离大，换句话说就是没滚到那\n    container.scrollTop = bottom - container.clientHeight;\n  }\n}\n\n```\n','2022-08-29 17:59:20','2022-09-01 06:22:56',1,'> 在解析element-ui各个组件源码之前，我们需要做一些前期准备工作，这里特别介绍element-ui的各个工具类方法，路径在`element\\src\\utils`中，用于在之后组件解析过程中参照使用。',0,NULL,0),(86,'清除浮动的hack方法',1,'## 代码实现\n```scss\n//css\n<style>\n  .parent {\n    background-color: gray;\n  }\n  .parent::before {\n    display: table;\n    content: \' \';\n  }\n  .parent::after {\n    display: table;\n    content: \' \';\n    clear: both;\n  }\n  .parent .children {\n    float: left;\n    margin-top: 100px;\n    width: 500px;\n    height: 250px;\n    background-color: lightblue;\n  }\n</style>\n```\n```html\n//html\n<div class=\"parent\">\n   <div class=\"children\"></div>\n</div>\n```\n效果预览：\n\n<img src=\"https://docs.hgyn23.cn/static/58dc7914438a7f5db67bdfbb904df8bb\" width=\"600px\" height=\"auto\" alt=\"58dc7914438a7f5db67bdfbb904df8bb\">\n\n## 原理解析：\n在parent类上使用`::before` `::after` 生成伪元素并将它们的display设置为table. 这会创建一个匿名表格单元格和一个新的块格式化上下文，这意味着`:before`伪元素可以防止上边距折叠。`:after`伪元素用于清除浮动。创建块级格式上下文可参考[该篇](https://docs.hgyn23.cn/main/post/60)\n\n\n\n','2022-09-01 15:28:29','2022-09-01 07:31:31',1,'```css\ndiv:before{display:table; content:\"\"}\ndiv:after{display:table; content:\"\";clear:both}\n```\n这两行简短代码可以轻松实现元素**1.防止内边距塌陷 2.清除浮动**的功能，也有很多主流网站采用了该方法',0,NULL,0),(87,'JS小技巧系列',1,'## 在输入框中如何判断网址是否正确\n```js\nfunction isUrl(url) {\n    try {\n        new URL(url);\n        return true;\n    } catch(err){\n    	 return false;\n		}\n}\n```','2022-09-05 18:28:47','2022-11-15 07:24:33',0,'> show me the code baby',0,NULL,1),(88,'测试',1,'测试','2022-10-09 17:01:47','2022-11-12 20:07:38',0,'测试',1,NULL,0),(89,'解决git 不同branch 下node_moudes不同步的问题',1,'做`nodejs`开发，或者`vue` `react`等开发的同学，在使用`git` 做版本管理的时候肯定碰到过这个问题。\n按常规做法`node_modules` 肯定是被添加到`.gitignore`中不需要被提交的\n\n但是在**分支切换**的时候就会遇到问题 ，经如你在`dev`分支下就是升级了某个依赖到最新和版本，这时`node_modules`下所有的文件被更新，这时你如果切回到`master`分支，修改一个小错误 ，就会发现，由于`node_modules` 下的依赖已经是新版本，但是`master`中还是用的老版本，代码运行就不正常了，所以你不得不`npm install`一下，记所有依赖回到原来的版本，`master`正常了，再切回`dev`,依赖又不对了，又要`npm install` 一次，很是麻烦。\n\n特别最遇到某个依赖重大更新，可能要修改很多代码的时候，你希望在彻底升级成功之前，不搞乱`node_modules`目录。这时候就要祭出`git worktree`这个命令了\n```shell\ngit worktree add -b upslider ../upslider dev\nPreparing ../upslider (identifier upslider)\nHEAD is now at 44f4bee fix some bug\n```\n上面代码，可以建立一个完全干净的全新工作目录`upslider`，来自于`dev`分支，你可以`cd ../upslider` 进入新的工作目录，在这个工作目录下，`npm install` 以后，你想怎么升级`node_modules`，都不会影响到原来工作目录下的`node_modules` 。\n\n在新的工作目录下，你完成所有的升级工作，测试一切无误以后，就可以`commit`了，这样生成一个新的`branch`，而且这个用于测试升级新工作目录也可以彻底删除，不用担心，代码已经全部进了`branch`。\n\n回到原来的工作目录，你可以用`git merge upslider` 把修改的代码全部合并到当前工作目录。\n\n这样利用全新目录来升级测试`node_modules`下的新依赖，完全不打扰到正常工作目录。','2022-11-10 19:07:11','2022-11-12 19:50:25',1,'做nodejs开发，或者vue react等开发的同学，在使用git 做版本管理的时候肯定碰到过这个问题。\n按常规做法node_modules 肯定是被添加到.gitignore中不需要被提交的',0,NULL,0),(90,'测试文章',1,'123','2022-11-13 04:05:46','2022-11-12 20:08:19',1,'123',1,NULL,0),(91,'测试',1,'啊实打实的','2022-11-13 04:07:54','2022-11-12 20:09:33',0,'啊实打实的',1,NULL,1);
/*!40000 ALTER TABLE `t_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_img`
--

DROP TABLE IF EXISTS `t_img`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_img` (
  `img_id` int unsigned NOT NULL AUTO_INCREMENT,
  `uid` int NOT NULL COMMENT 'uid',
  `name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '图片名称',
  `img_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '图片url',
  `create_time` datetime NOT NULL COMMENT '注册时间',
  `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `is_delete` tinyint(1) DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`img_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_img`
--

LOCK TABLES `t_img` WRITE;
/*!40000 ALTER TABLE `t_img` DISABLE KEYS */;
INSERT INTO `t_img` VALUES (1,1,'swiper1.jpeg','http://127.0.0.1:3000/static/0d4c377fd0f7a06b77cab10624638da4','2021-10-12 23:14:57','2021-10-12 15:14:57',0);
/*!40000 ALTER TABLE `t_img` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_note`
--

DROP TABLE IF EXISTS `t_note`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_note` (
  `note_id` int NOT NULL AUTO_INCREMENT,
  `content` text,
  `create_time` datetime DEFAULT NULL,
  `is_delete` varchar(255) DEFAULT NULL,
  `publish` varchar(255) DEFAULT NULL,
  `uid` int DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`note_id`)
) ENGINE=InnoDB AUTO_INCREMENT=74 DEFAULT CHARSET=utf8mb3;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_note`
--

LOCK TABLES `t_note` WRITE;
/*!40000 ALTER TABLE `t_note` DISABLE KEYS */;
INSERT INTO `t_note` VALUES (1,'初始化内容','2022-03-22 17:04:39','0','1',1,'2022-03-25 08:44:06'),(2,'api调用测试','2022-03-22 18:02:35','1','1',1,'2022-03-25 08:44:09'),(3,'api调用测试1','2022-03-22 18:02:46','1','1',1,'2022-03-25 08:44:11'),(4,'123','2022-03-27 04:19:09','1','0',1,NULL),(5,'123123','2022-03-27 04:19:15','1','1',1,NULL),(6,'在数组遍历中如果要改变数组长度，比如增删等等，为了防止数组长度改变后索引异常的问题，可以采取倒序遍历的方法','2022-03-27 04:48:03','0','1',1,NULL),(7,'l123123','2022-03-27 05:30:44','1','1',1,NULL),(8,'测试中测试中','2022-03-27 05:45:48','1','1',1,NULL),(9,'this绑定规则和函数的定义位置没有关系，决定this的是函数的调用位置','2022-04-05 16:27:30','1','1',1,NULL),(10,'this绑定优先级：new>显式绑定>隐式绑定','2022-04-05 17:24:29','0','1',1,NULL),(11,'this绑定规则和函数的定义位置没有关系，决定this的是函数的调用位置,也就是调用者','2022-04-08 08:54:51','0','1',1,NULL),(12,'纯函数，①对于每一个输入都有确定的输出结果②无副作用','2022-04-08 15:03:55','1','1',1,NULL),(13,'纯函数，①对于每一个输入都有确定的输出结果②无副作用（不影响外部变量，不输出一些无关的变量）','2022-04-08 15:05:12','0','1',1,NULL),(14,'调用new操作符会发生的事：①在内存中创建一个新的对象②这个对象内部的[[prototype]]属性会指向该构造函数的prototype属性③构造函数内部的this会指向创建出来的新对象④执行函数内部的代码（函数体代码）⑤如果构造函数没有显式返回非空对象，则返回创建出来的对象（this）','2022-04-08 16:11:55','0','1',1,NULL),(15,'113123123','2022-04-08 16:12:15','1','1',1,NULL),(16,'123123123123','2022-04-08 16:12:17','1','1',1,NULL),(17,'123123123123','2022-04-08 16:12:19','1','1',1,NULL),(18,'2131231123','2022-04-08 16:12:23','1','1',1,NULL),(19,'123123123','2022-04-08 16:12:26','1','1',1,NULL),(20,'123123123','2022-04-08 16:12:29','1','1',1,NULL),(21,'123123123','2022-04-08 16:12:31','1','1',1,NULL),(22,'123123123','2022-04-08 16:12:32','1','1',1,NULL),(23,'1 推荐在循环对象属性的时候，使用for...in,在遍历数组的时候的时候使用for...of。\n\n2 for...in循环出的是key，for...of循环出的是value\n\n3 注意，for...of是ES6新引入的特性。修复了ES5引入的for...in的不足\n\n4 for...of不能循环普通的对象，需要通过和Object.keys()搭配使用','2022-04-11 15:13:48','0','1',1,NULL),(24,'每天进步一点点','2022-04-12 16:56:56','0','1',1,NULL),(25,'async、await语法是generator生成器函数调promise函数的语法糖','2022-04-13 08:45:09','1','1',1,NULL),(26,'进程和线程都是操作系统的概念①进程：计算机已经运行的程序，是操作系统管理程序的一种方式②线程：操作系统能进行运算调度的最小单位，通常情况下他被包含在进程中','2022-04-13 09:20:40','0','1',1,NULL),(27,'js是单线程的，为什么他和其他多线程的语言如java相比是单线程的呢？因为js是跑在客户端的，做的内容相对较少，而且如果js是多线程可能会出现资源抢占的问题，比如对dom的更新，如果多个线程同时进行dom更新的话，浏览器就不知道怎么运行了','2022-04-13 09:31:47','0','1',1,NULL),(28,'浏览器事件循环宏任务微任务队列执行原则：再执行任何宏任务之前都要保证微任务队列已经被清空','2022-04-13 10:02:30','1','1',1,NULL),(29,'浏览器事件循环宏任务微任务队列执行原则：在执行任何宏任务之前都要保证微任务队列已经被清空','2022-04-13 10:02:41','0','1',1,NULL),(30,'async、await语法是generator生成器函数调promise函数的语法糖 async函数执行中遇到await关键字会等待promise.then回调，之后执行的代码都相当于在then中执行的，也就是说会添加到微任务队列中','2022-04-13 10:20:43','0','1',1,NULL),(31,'直接通过默认浏览器打开html文件不能正常加载js模块文件，因为出于安全性考虑，file://前缀不支持加载js文件，所以要正常加载js文件，需要起一个服务。以http://或https://的前缀获取','2022-04-13 15:17:13','0','1',1,NULL),(32,'npm的版本规范中^x.y.z:表示x是保持不变的，y和z永远用最新的版本。~x.y.z:表示x、y是保持不变的，z永远保持最新的版本','2022-04-13 16:43:35','0','1',1,NULL),(33,'浏览器一个标签页就代表一个会话，localStorage能够持久性存储，只要是相同的域就都能访问到，sessionStorage临时会话存储，只有在当前会话中才能访问','2022-04-14 11:24:55','0','1',1,NULL),(34,'cookie的大小限制是4kb','2022-04-14 15:42:37','0','1',1,NULL),(35,'不要线性学习，要去从整体的角度去考虑问题','2022-04-14 15:46:03','0','1',1,NULL),(36,'学习要高屋建瓴','2022-04-14 15:47:17','0','1',1,NULL),(37,'函数再有默认值的情况下，会多形成一层作用域','2022-04-14 16:22:28','1','1',1,NULL),(38,'函数在有默认值的情况下，会多形成一层作用域','2022-04-14 16:22:39','0','1',1,NULL),(39,'Proxy 的 get trap 中的 receiver 是什么？\n\n在 Reflect.get 的场景下，receiver 可以改变计算属性中 this 的指向。在 Proxy trap 的场景下，这个 receiver 永远指向 Proxy 本身或者继承它的对象。','2022-04-18 16:53:23','0','1',1,NULL),(40,'头痛，多休息，少看电脑','2022-06-27 18:46:57','0','1',1,NULL),(41,'今天是2022年6月27日星期一 18.49，终于有时间学习react了，把coderwhy的网易云音乐看到了编写播放器一节，并且完成了基本的播放功能。dnk网关联调，被安排任务：安卓签到机特殊设置。七点整回家。','2022-06-27 18:50:13','0','1',1,NULL),(42,'制作一款面试网站，他可根据用户选择的标签动态生成合适的面试题，用户对面试题进行回答，系统通过收录语音，或者文字，并且生成当前题目最优的答案，当用户答完相关题目之后，将之前的所有答题汇总成一个报告。用户可参考报告最优的答案和自己的答案进行比较，从而让面试者得到一个加深印象的效果。','2022-07-06 15:51:44','0','1',1,NULL),(43,'js作用域在创建的时候就已经确定了（不是动态的）','2022-07-09 22:47:09','0','1',1,NULL),(44,'复习js在百度云里有coderwhy的js高级 课程还有课件','2022-07-10 00:42:14','0','1',1,NULL),(45,'test1','2022-07-11 00:03:56','1','1',1,NULL),(46,'this绑定优先级：new>显示绑定>隐式绑定>默认绑定','2022-07-12 17:15:57','0','1',1,NULL),(47,'for...of本质上是调用目标对象上的迭代器','2022-07-24 15:24:09','0','1',1,NULL),(48,'async函数中如果await遇到了reject，那么它后面的代码都不会执行，整个函数返回reject的值，外部可用catch捕获到该值。','2022-07-24 17:48:50','0','1',1,NULL),(49,'(n & 1)可判断n的奇偶性','2022-07-25 09:45:06','0','1',1,NULL),(50,'CommonJS实现的模块导入导出其指向的是同一个对象，对这个对象进行更改会影响这个对象。','2022-07-25 14:09:38','0','1',1,NULL),(51,'exports=module.exports','2022-07-25 14:12:25','0','1',1,NULL),(52,'ESModule 在运行时导出者可以改变导出的值，而导入者不能改变。','2022-07-25 14:27:07','0','1',1,NULL),(53,'非对称加密过程简单来说就是①客户端发起请求②服务端把自己的公钥和证书发给客户端③客户端验证证书是否有效④客户端生成密钥并用公钥加密⑤客户端发送公钥加密后的密钥⑥客户端收到密钥后用私钥解密⑦后续使用该密钥进行通信','2022-08-05 17:29:41','0','1',1,NULL),(54,'使用了绝对定位的元素可以参照此时绝对定位“确定的坐标轴”（重点要考：如果设置了top，left那么就以定位后的top和left为坐标轴计算margin，也就是说margin-top,margin-left可以改变元素）使用margin去移动元素','2022-08-08 15:11:41','0','1',1,NULL),(55,'设置了transform属性的元素会形成一个新的包含块，在此元素中有position:fixed属性的元素会以该元素为参考对象','2022-08-08 17:57:44','0','1',1,NULL),(56,'元素的 margin 和 padding 设置为百分比时，基准为包含块的 width（易错）','2022-08-08 17:58:27','0','1',1,NULL),(57,'弱引用即垃圾回收器不考虑该段引用','2022-08-09 15:06:14','0','1',1,NULL),(58,'周末试着过一下面试题','2022-08-09 15:42:50','0','1',1,NULL),(59,'我为什么选择前端？1.首先是因为受专业影响，我原先是对硬件感兴趣，在大学暑假期间有自己学过一点点硬件相关的知识，那个时候每天都对着手机看他们对电路的分析，当时确实是对硬件感兴趣，觉得自己做出来东西非常有成就感，但是我也从外部打听到硬件非常消耗财力，如果没有想去钻研的决心干下去是挺困难的一件事，确实，我在暑假期间自己买硬件也花了不少钱吧，但是在现实生活之中接触到电路给我带来的魅力，我就乐此不疲，仿佛掌握了天地一样。我的毕设也是做的和硬件相关的，在此之前我在宿舍见到我舍友已经去实习了，而且是找的前端这份工作，就受到他的引导去试着学了以下，仿佛刷新了我的世界观，原来一个网页是这样子搭建的，同时到了大四也快找实习了，我就暂时想着先做一段时间前端，后面的路一步一步走吧，事实说明做什么事情都不能走一步看一步，要先提前规划好自己未来的道路，人家都已经去字节了，我还在迷茫着受到他人的引导去学一些东西，所以这个坚定了我学好前端的决心，并且前端这个行业其实就业的前景也还不错。','2022-08-12 11:44:11','0','1',1,NULL),(60,'我就想在这个行业干下去，因为临近毕业了，其他东西都不会，硬件知识都忘得差不多了，我拿什么和别人竞争。既然选择了前端这条道路，那就一路走下去。林超也相当于是我的贵人吧，但是他的思维方式和我不一样，我就是一个想让自己不普通的普通人，而他从小锻炼的思维方式和培养的兴趣都是在我上大学之前遇到的人里面所没有的，所以如果没有接触到这样的人，我可能只能不甘平庸的浑浑噩噩的度过这一生吧。得找个机会多和她接触，但首要的前提就是我能在前端这个领域稍微有点成就，这样才有资格去和一个聪明人沟通','2022-08-12 11:49:19','0','1',1,NULL),(61,'vue源码的实现方式：当我们打包vue项目时，webpack的vue-loader将sfc文件解析成render函数，这样我们在创建项目的时候就可以直接选择vue的runtime版本，此时vue打包后会拥有更小的体积。打包完成的项目会生成一个index.html，我们使用浏览器打开该文件后，浏览器会开始解析其中的script代码，并且会将主文件下载下来，这个文件就包含了vue的一系列相关文件，接着开始执行代码，vue进行初始化，在钩子beforecreate和create之间，初始化render，lifecycle，state，对data中的数据进行响应式绑定，在created钩子调用后，数据初始化完成，可以访问相关数据，之后调用$mount，如果是编译加运行时版本，那么会对模板进行编译，如果只是运行时版本，直接调用beforemounte钩子，接下来创建渲染watcher，创建时会把当前的watcher压入全局，接着运行更新dom的方法，运行render函数，此时会进行依赖收集，将当前全局渲染watcher与data中属性的闭包dep绑定关联关系。之后将虚拟dom转换成真实dom，并将dom挂载。挂载完成调用beforemounted','2022-08-24 16:27:59','0','1',1,NULL),(62,'你是因为什么契机选择做前端?在毕设选题时舍友在学习前端，后来使用前端做了一个app，该app用于防盗报警发送通知和控制开关，后来就对前端感兴趣了','2022-08-24 17:20:52','0','1',1,NULL),(63,'一行meta标签将http转为http请求<meta http-equiv =\"Content-Security-Policy\" content=\"upgrade-insecure-requests\">','2022-08-25 15:32:31','0','1',1,NULL),(64,'css选择器权重important(无限大)>内联样式(1000)>id选择器(0100)>class选择器、伪类、属性选择器(0010)>标签选择器、伪元素选择器(0001)>通配符*(0)','2022-08-26 15:38:13','0','1',1,NULL),(65,'vue2中computed有传入一个参数，该参数为当前组件实例','2022-08-30 10:17:26','0','1',1,NULL),(66,'遍历对象顺序：\n首先遍历所有数值键，按照数值升序排列。\n其次遍历所有字符串键，按照加入时间升序排列。\n最后遍历所有 Symbol 键，按照加入时间升序排列。','2022-09-05 18:23:34','0','1',1,NULL),(67,'优化简历hybirdAPP','2022-09-07 14:11:28','1','1',1,NULL),(68,'优化简历HybridAPP','2022-09-07 14:12:00','0','1',1,NULL),(69,'z-index不仅仅是针对固定定位和绝对定位有效，还对相对定位有效。而且z-index作用的盒子内部元素如果设定了z-index，则z-index只能在内部比较，且父盒子相对于子盒子的z-index为0','2022-09-26 11:21:38','0','1',1,NULL),(70,'以后webpack报错说找不到getOptions原因是loader-utils版本过高了','2022-09-28 17:08:33','0','1',1,NULL),(71,'测试测试测试测试',NULL,'0','1',1,NULL),(72,'测试测试测试',NULL,'0','1',1,NULL),(73,'测试测试测试测试aaa',NULL,'0','1',1,NULL);
/*!40000 ALTER TABLE `t_note` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_tag`
--

DROP TABLE IF EXISTS `t_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_tag` (
  `tag_id` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标签名',
  `uid` int NOT NULL COMMENT 'uid',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `is_delete` tinyint(1) DEFAULT '0',
  `blog_id` int DEFAULT NULL COMMENT '博客id',
  `publish` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`tag_id`) USING BTREE,
  UNIQUE KEY `name` (`name`,`blog_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=776 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_tag`
--

LOCK TABLES `t_tag` WRITE;
/*!40000 ALTER TABLE `t_tag` DISABLE KEYS */;
INSERT INTO `t_tag` VALUES (142,'模板引擎',1,'2021-11-05 15:52:17','2021-11-05 08:05:33',1,17,'1'),(145,'后台管理',1,'2021-11-05 16:09:59','2021-12-06 03:39:51',1,19,'1'),(146,'Nodejs',1,'2021-11-05 16:12:53','2021-11-05 08:24:51',0,20,'1'),(147,'爬虫',1,'2021-11-05 16:12:53','2021-11-05 08:24:51',0,20,'1'),(151,'后台管理',1,'2021-11-05 16:21:32','2021-12-06 03:40:08',1,24,'1'),(154,'vue',1,'2021-11-11 16:18:30','2021-11-11 08:41:07',1,25,'0'),(156,'Vuejs',1,'2021-11-11 16:20:59','2021-11-11 08:41:07',0,25,'0'),(159,'Vuejs',1,'2021-11-11 16:41:03','2022-04-25 09:52:03',0,26,'0'),(173,'webpack',1,'2021-11-24 20:17:29','2021-11-24 12:17:29',0,29,'0'),(177,'流程',1,'2021-12-03 16:27:02','2021-12-03 08:27:38',1,30,'1'),(182,'Vuejs',1,'2021-12-03 16:29:16','2021-12-03 08:29:16',0,28,'1'),(183,'SSR',1,'2021-12-03 16:29:16','2021-12-03 08:29:16',0,28,'1'),(184,'Vuejs',1,'2021-12-06 11:39:51','2022-04-13 08:20:37',1,19,'1'),(185,'平台',1,'2021-12-06 11:39:51','2022-04-13 08:20:37',1,19,'1'),(186,'Vuejs',1,'2021-12-06 11:40:08','2021-12-06 03:40:08',0,24,'1'),(187,'平台',1,'2021-12-06 11:40:08','2021-12-06 03:40:08',0,24,'1'),(190,'服务器',1,'2021-12-13 11:00:39','2021-12-24 09:50:01',0,32,'1'),(225,'Vuejs',1,'2021-12-24 17:46:04','2021-12-24 09:50:15',0,27,'1'),(226,'SSR',1,'2021-12-24 17:46:04','2021-12-24 09:50:15',0,27,'1'),(228,'Vuejs',1,'2021-12-24 17:47:35','2021-12-24 09:47:35',0,21,'1'),(229,'Vuejs',1,'2021-12-24 17:48:49','2021-12-24 09:48:49',0,35,'1'),(241,'服务器',1,'2022-03-01 18:55:25','2022-03-01 11:02:44',0,40,'1'),(266,'构建相关',1,'2022-03-07 16:27:21','2022-03-09 01:10:06',0,39,'0'),(312,'Javascript',1,'2022-04-08 08:58:18','2022-04-08 00:58:18',0,47,'0'),(313,'手写系列',1,'2022-04-08 08:58:18','2022-04-08 00:58:18',0,47,'0'),(318,'Javascript',1,'2022-04-08 09:01:13','2022-08-22 09:13:44',0,22,'0'),(319,'手写系列',1,'2022-04-08 09:01:13','2022-08-22 09:13:44',0,22,'0'),(322,'手写系列',1,'2022-04-08 09:01:57','2022-04-08 01:02:42',1,44,'1'),(345,'Javascript',1,'2022-04-09 20:21:54','2022-04-09 12:35:52',1,50,'0'),(351,'Javascript',1,'2022-04-11 16:10:33','2022-04-11 08:10:33',0,51,'1'),(401,'Vuejs',1,'2022-04-18 16:41:29','2022-04-18 08:41:29',0,52,'1'),(402,'Javascript',1,'2022-04-18 16:41:29','2022-04-18 08:41:29',0,52,'1'),(403,'Javascript',1,'2022-04-18 16:42:25','2022-04-18 08:42:27',0,58,'1'),(404,'Vuejs',1,'2022-04-18 16:42:25','2022-04-18 08:42:27',0,58,'1'),(411,'HTML',1,'2022-04-23 21:04:48','2022-04-23 13:04:48',0,60,'1'),(412,'CSS',1,'2022-04-23 21:04:48','2022-04-23 13:04:48',0,60,'1'),(419,'学而思',1,'2022-04-26 10:13:50','2022-04-26 02:13:58',1,61,'0'),(453,'服务器',1,'2022-07-05 09:21:00','2022-07-05 01:21:00',0,30,'1'),(485,'Vuejs',1,'2022-07-24 11:34:13','2022-07-24 03:34:13',0,59,'1'),(486,'Javascript',1,'2022-07-24 11:34:13','2022-07-24 03:34:13',0,59,'1'),(489,'Javascript',1,'2022-07-24 16:50:49','2022-07-24 08:50:49',0,53,'0'),(490,'手写系列',1,'2022-07-24 16:50:49','2022-07-24 08:50:49',0,53,'0'),(492,'Javascript',1,'2022-07-25 13:33:31','2022-07-25 05:33:31',0,55,'1'),(499,'手写系列',1,'2022-08-02 11:09:09','2022-08-02 03:09:09',0,45,'1'),(500,'Javascript',1,'2022-08-02 11:09:09','2022-08-02 03:09:09',0,45,'1'),(501,'手写系列',1,'2022-08-02 11:10:03','2022-08-02 03:10:03',0,57,'1'),(502,'Javascript',1,'2022-08-02 11:10:03','2022-08-02 03:10:03',0,57,'1'),(503,'Javascript',1,'2022-08-02 11:10:42','2022-08-02 03:10:42',0,41,'1'),(504,'学而思',1,'2022-08-02 11:10:42','2022-08-02 03:10:42',0,41,'1'),(506,'Javascript',1,'2022-08-02 11:11:49','2022-08-02 03:11:49',0,46,'1'),(507,'手写系列',1,'2022-08-02 11:11:49','2022-08-02 03:11:49',0,46,'1'),(508,'网络',1,'2022-08-02 11:12:16','2022-08-02 03:12:16',0,23,'1'),(509,'服务器',1,'2022-08-02 11:12:16','2022-08-02 03:12:16',0,23,'1'),(513,'Javascript',1,'2022-08-02 11:13:18','2022-08-02 03:13:18',0,42,'1'),(514,'Javascript',1,'2022-08-02 11:13:56','2022-08-02 03:13:56',0,34,'1'),(515,'Vuejs',1,'2022-08-02 11:14:08','2022-08-02 03:14:08',0,38,'1'),(516,'网络',1,'2022-08-02 11:14:39','2022-08-02 03:14:39',0,36,'1'),(517,'模板引擎',1,'2022-08-02 11:15:56','2022-08-02 03:15:56',0,18,'1'),(532,'Javascript',1,'2022-08-09 13:38:24','2022-08-09 05:38:24',0,66,'1'),(533,'手写系列',1,'2022-08-09 13:38:24','2022-08-09 05:38:24',0,66,'1'),(543,'Vuejs',1,'2022-08-10 11:41:03','2022-08-10 03:41:03',0,67,'1'),(546,'手写系列',1,'2022-08-12 10:02:40','2022-08-12 02:02:40',0,63,'1'),(547,'Vuejs',1,'2022-08-12 10:02:40','2022-08-12 02:02:40',0,63,'1'),(548,'Javascript',1,'2022-08-12 10:02:40','2022-08-12 02:02:40',0,63,'1'),(551,'面试',1,'2022-08-12 11:26:59','2022-08-31 02:09:15',0,37,'0'),(552,'Javascript',1,'2022-08-14 02:24:24','2022-08-13 18:24:24',0,48,'1'),(553,'手写系列',1,'2022-08-14 02:24:24','2022-08-13 18:24:24',0,48,'1'),(554,'手写系列',1,'2022-08-14 02:24:45','2022-08-13 18:24:45',0,43,'1'),(555,'Javascript',1,'2022-08-14 02:24:45','2022-08-13 18:24:45',0,43,'1'),(557,'面试',1,'2022-08-14 18:47:19','2022-08-14 10:47:19',0,69,'0'),(612,'Vuejs',1,'2022-08-19 08:49:25','2022-08-19 02:31:36',0,74,'0'),(613,'组件',1,'2022-08-19 08:49:25','2022-08-19 02:31:36',0,74,'0'),(614,'组件',1,'2022-08-19 08:49:43','2022-08-19 02:31:28',0,73,'0'),(615,'Vuejs',1,'2022-08-19 08:49:43','2022-08-19 02:31:28',0,73,'0'),(616,'Vuejs',1,'2022-08-19 08:50:02','2022-08-19 02:31:36',0,72,'0'),(617,'组件',1,'2022-08-19 08:50:02','2022-08-19 02:31:36',0,72,'0'),(618,'Vuejs',1,'2022-08-19 08:50:16','2022-08-19 02:31:38',0,70,'0'),(619,'组件',1,'2022-08-19 08:50:16','2022-08-19 02:31:38',0,70,'0'),(654,'组件',1,'2022-08-21 03:22:28','2022-08-20 19:22:28',0,71,'0'),(655,'Vuejs',1,'2022-08-21 03:22:28','2022-08-20 19:22:28',0,71,'0'),(656,'组件',1,'2022-08-21 04:20:51','2022-08-20 20:20:51',0,77,'1'),(657,'Vuejs',1,'2022-08-21 04:20:51','2022-08-20 20:20:51',0,77,'1'),(658,'Vuejs',1,'2022-08-21 04:21:08','2022-08-20 20:21:08',0,78,'1'),(659,'组件',1,'2022-08-21 04:21:08','2022-08-20 20:21:08',0,78,'1'),(660,'组件',1,'2022-08-21 04:21:26','2022-08-20 20:21:26',0,79,'1'),(661,'Vuejs',1,'2022-08-21 04:21:26','2022-08-20 20:21:26',0,79,'1'),(662,'Vuejs',1,'2022-08-21 04:22:02','2022-08-20 20:22:02',0,76,'1'),(663,'组件',1,'2022-08-21 04:22:02','2022-08-20 20:22:02',0,76,'1'),(664,'Vuejs',1,'2022-08-21 04:22:18','2022-08-20 20:22:18',0,81,'1'),(665,'组件',1,'2022-08-21 04:22:18','2022-08-20 20:22:18',0,81,'1'),(666,'Vuejs',1,'2022-08-21 04:22:33','2022-08-20 20:22:33',0,80,'1'),(667,'组件',1,'2022-08-21 04:22:33','2022-08-20 20:22:33',0,80,'1'),(668,'组件',1,'2022-08-21 04:22:48','2022-08-20 20:22:48',0,75,'1'),(669,'Vuejs',1,'2022-08-21 04:22:48','2022-08-20 20:22:48',0,75,'1'),(680,'Javascript',1,'2022-08-22 17:10:31','2022-08-22 09:10:31',0,83,'1'),(681,'手写系列',1,'2022-08-22 17:10:31','2022-08-22 09:10:31',0,83,'1'),(684,'手写系列',1,'2022-08-22 17:12:25','2022-08-22 09:12:25',0,82,'1'),(685,'Javascript',1,'2022-08-22 17:12:25','2022-08-22 09:12:25',0,82,'1'),(686,'Javascript',1,'2022-08-23 17:24:45','2022-08-23 09:24:45',0,49,'1'),(687,'Javascript',1,'2022-08-24 09:47:14','2022-08-24 01:47:14',0,64,'1'),(695,'Javascript',1,'2022-08-24 16:47:26','2022-08-24 08:47:26',0,84,'1'),(696,'手写系列',1,'2022-08-24 16:47:26','2022-08-24 08:47:26',0,84,'1'),(700,'Vuejs',1,'2022-08-26 08:43:55','2022-08-26 00:43:55',0,68,'1'),(701,'学而思',1,'2022-08-26 16:31:32','2022-08-26 08:31:32',0,56,'0'),(712,'组件',1,'2022-09-01 14:22:56','2022-09-01 06:22:56',0,85,'1'),(713,'Javascript',1,'2022-09-01 14:22:56','2022-09-01 06:22:56',0,85,'1'),(720,'HTML',1,'2022-09-01 15:31:31','2022-09-01 07:31:31',0,86,'1'),(721,'CSS',1,'2022-09-01 15:31:31','2022-09-01 07:31:31',0,86,'1'),(741,'Javascript',1,'2022-09-02 17:53:00','2022-09-02 09:53:00',0,54,'1'),(745,'网络',1,'2022-09-11 01:11:29','2022-09-10 17:11:29',0,33,'1'),(746,'服务器',1,'2022-09-11 01:11:29','2022-09-10 17:11:29',0,33,'1'),(747,'Browser',1,'2022-09-11 01:11:29','2022-09-10 17:11:29',0,33,'1'),(755,'学而思',1,'2022-10-08 10:44:57','2022-10-08 02:44:57',0,65,'0'),(758,'学而思',1,'2022-10-27 11:49:12','2022-10-27 03:49:12',0,31,'0'),(759,'CSS',1,'2022-11-03 15:30:19','2022-11-03 07:30:19',0,62,'1'),(760,'HTML',1,'2022-11-03 15:30:19','2022-11-03 07:30:19',0,62,'1'),(764,'HTML',1,'2022-11-13 03:49:50','2022-11-12 19:50:25',1,89,'1'),(765,'git',1,'2022-11-13 03:50:25','2022-11-12 19:50:25',0,89,'1'),(766,'HTML',1,'2022-11-13 04:04:45','2022-11-15 07:24:33',1,87,'0'),(769,'组件',1,'2022-11-13 04:05:03','2022-11-15 07:24:33',1,87,'0'),(770,'Vuejs',1,'2022-11-13 04:05:03','2022-11-15 07:24:33',1,87,'0'),(771,'Javascript',1,'2022-11-15 07:24:33','2022-11-15 07:24:33',0,87,'0'),(772,'测试',1,'2022-11-13 04:05:46','2022-11-12 20:08:19',1,90,'1'),(773,'Browser',1,'2022-11-13 04:07:28','2022-11-12 20:07:38',1,88,'0'),(774,'HTML',1,'2022-11-13 04:07:54','2022-11-12 20:09:33',1,91,'0');
/*!40000 ALTER TABLE `t_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `t_user`
--

DROP TABLE IF EXISTS `t_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `t_user` (
  `uid` int unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '姓名',
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '密码',
  `create_time` datetime NOT NULL COMMENT '注册时间',
  `update_time` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `is_delete` tinyint(1) DEFAULT '0',
  PRIMARY KEY (`uid`) USING BTREE,
  UNIQUE KEY `name` (`name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `t_user`
--

LOCK TABLES `t_user` WRITE;
/*!40000 ALTER TABLE `t_user` DISABLE KEYS */;
INSERT INTO `t_user` VALUES (1,'admin','mrwisveryman','2021-10-08 17:35:30','2021-12-03 06:34:48',0);
/*!40000 ALTER TABLE `t_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2022-11-20  0:33:00
